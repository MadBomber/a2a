{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A2A - Agent to Agent Protocol","text":"Welcome to **A2A**, a Ruby implementation of the Agent to Agent protocol for enabling communication and interoperability between AI agents.  The A2A (Agent2Agent) protocol is an open standard enabling communication between independent agentic applications. This Ruby gem provides a complete implementation including core data models, JSON-RPC 2.0 messaging, and base classes for building A2A clients and servers.         Build interoperable AI agents that speak the same language"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#complete-protocol-implementation","title":"\ud83c\udfd7 Complete Protocol Implementation","text":"<ul> <li>Full A2A Specification: Implements the complete A2A JSON schema</li> <li>JSON-RPC 2.0: Standards-compliant request/response messaging</li> <li>Rich Data Models: AgentCard, Task, Message, Artifact, and polymorphic Part types</li> <li>Type Safe: Designed for use with RBS type definitions</li> </ul>"},{"location":"#flexible-architecture","title":"\ud83d\udd0c Flexible Architecture","text":"<ul> <li>Client &amp; Server Base Classes: Build your own A2A implementations</li> <li>Extensible Design: Easy to add new part types and capabilities</li> <li>Clean Separation: Models, protocol, client, and server are independently testable</li> <li>Framework Agnostic: Works with any Ruby web framework</li> </ul>"},{"location":"#advanced-capabilities","title":"\ud83d\ude80 Advanced Capabilities","text":"<ul> <li>Task Lifecycle Management: Complete state machine for task progression</li> <li>Multi-turn Conversations: Session support for ongoing interactions</li> <li>Streaming Support: Base classes ready for Server-Sent Events (SSE)</li> <li>Push Notifications: Webhook configuration for proactive updates</li> <li>Error Handling: Comprehensive error hierarchy</li> </ul>"},{"location":"#developer-friendly","title":"\ud83d\udc8e Developer Friendly","text":"<ul> <li>Well Documented: Extensive API documentation and examples</li> <li>Clean APIs: Intuitive, Ruby-idiomatic interfaces</li> <li>Tested: Designed for comprehensive test coverage</li> <li>Examples Included: Working examples for common use cases</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>gem install a2a\n</code></pre>"},{"location":"#create-an-agent-card","title":"Create an Agent Card","text":"<pre><code>require 'a2a'\n\nagent_card = A2A::Models::AgentCard.new(\n  name: \"My Agent\",\n  url: \"https://example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: true,\n    push_notifications: false\n  },\n  skills: [\n    {\n      id: \"text-analysis\",\n      name: \"Text Analysis\",\n      description: \"Analyze and process text content\"\n    }\n  ]\n)\n</code></pre>"},{"location":"#work-with-tasks-and-messages","title":"Work with Tasks and Messages","text":"<pre><code># Create a user message\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Analyze this document\"\n)\n\n# Create a task\ntask = A2A::Models::Task.new(\n  id: \"task-123\",\n  status: { state: \"submitted\" }\n)\n\n# Check task state\nputs task.state.submitted?  # =&gt; true\n</code></pre>"},{"location":"#protocol-overview","title":"Protocol Overview","text":"<p>The A2A protocol defines how AI agents discover each other, exchange messages, manage tasks, and deliver results:</p> <p></p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Agent Card: Metadata describing an agent's capabilities and endpoint</li> <li>Task: Central unit of work with unique ID and lifecycle states</li> <li>Message: Communication turns between user and agent</li> <li>Parts: Polymorphic content (Text, File, Data)</li> <li>Artifacts: Agent-generated outputs</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>The gem is organized into clean, testable layers:</p> <pre><code>lib/a2a/\n\u251c\u2500\u2500 models/          # Data models from A2A spec\n\u2502   \u251c\u2500\u2500 agent_card.rb, task.rb, message.rb...\n\u251c\u2500\u2500 protocol/        # JSON-RPC implementation\n\u2502   \u251c\u2500\u2500 request.rb, response.rb, error.rb\n\u251c\u2500\u2500 client/          # Client base class\n\u2502   \u2514\u2500\u2500 base.rb\n\u251c\u2500\u2500 server/          # Server base class\n\u2502   \u2514\u2500\u2500 base.rb\n\u2514\u2500\u2500 utils/           # Utilities\n</code></pre> <p>See the Architecture Guide for detailed information.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation - Get A2A up and running</li> <li>Quick Start - Build your first A2A integration</li> <li>Getting Started Guide - Comprehensive tutorial</li> </ul>"},{"location":"#guides","title":"Guides","text":"<ul> <li>Creating Agent Cards - Define your agent's capabilities</li> <li>Working with Tasks - Task lifecycle and management</li> <li>Messages and Parts - Communication between agents</li> <li>Handling Artifacts - Working with agent outputs</li> <li>Error Handling - Robust error management</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Models - Complete model API documentation</li> <li>Protocol - JSON-RPC protocol classes</li> <li>Client - Client base class reference</li> <li>Server - Server base class reference</li> </ul>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Basic Usage - Common patterns and examples</li> <li>Building a Client - Implement an A2A client</li> <li>Building a Server - Implement an A2A server</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: madbomber/a2a</li> <li>Issues: Report bugs and request features</li> <li>RubyGems: a2a gem</li> <li>Protocol Spec: A2A Protocol Specification</li> </ul>"},{"location":"#whats-the-a2a-protocol","title":"What's the A2A Protocol?","text":"<p>The Agent2Agent (A2A) protocol is an open standard created by Google and the community to enable communication between AI agents built on different frameworks and platforms. It provides:</p> <ul> <li>Standard Discovery: Agents publish capabilities via Agent Cards</li> <li>Task Management: Structured workflow for agent interactions</li> <li>Multi-modal Support: Text, files, and structured data</li> <li>Real-time Updates: Streaming and push notifications</li> <li>Interoperability: Framework and vendor agnostic</li> </ul> <p>Learn more about the protocol at google.github.io/A2A.</p>"},{"location":"#license","title":"License","text":"<p>A2A is open source software. See the LICENSE file for details.</p> <p>Ready to get started? Head to the Installation guide to begin!</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide will help you install the A2A Ruby gem and get it running on your system.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":""},{"location":"installation/#required","title":"Required","text":"<ul> <li>Ruby: Version 3.4.0 or higher</li> <li>RubyGems: Usually comes with Ruby</li> </ul>"},{"location":"installation/#recommended","title":"Recommended","text":"<ul> <li>git: For version control</li> <li>bundler: For dependency management</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-install-from-rubygems-recommended","title":"Method 1: Install from RubyGems (Recommended)","text":"<p>The easiest way to install A2A is through RubyGems:</p> <pre><code>gem install a2a\n</code></pre>"},{"location":"installation/#method-2-install-from-source","title":"Method 2: Install from Source","text":"<p>If you want the latest development version:</p> <pre><code>git clone https://github.com/madbomber/a2a.git\ncd a2a\nbundle install\nrake install\n</code></pre>"},{"location":"installation/#method-3-using-bundler","title":"Method 3: Using Bundler","text":"<p>Add to your Gemfile:</p> <pre><code>gem 'a2a'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that A2A is working:</p> <pre><code>ruby -r a2a -e \"puts A2A.version\"\n</code></pre> <p>You should see the version number printed (e.g., <code>0.1.0.pre</code>).</p>"},{"location":"installation/#quick-test","title":"Quick Test","text":"<p>Let's verify everything works with a quick Ruby script:</p> <pre><code>#!/usr/bin/env ruby\nrequire 'a2a'\n\n# Create a simple agent card\nagent = A2A::Models::AgentCard.new(\n  name: \"Test Agent\",\n  url: \"https://example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: { streaming: false },\n  skills: [{ id: \"test\", name: \"Test Skill\" }]\n)\n\nputs \"\u2713 A2A gem loaded successfully!\"\nputs \"\u2713 Agent created: #{agent.name}\"\nputs \"\u2713 Version: #{A2A.version}\"\n</code></pre> <p>Save this as <code>test_a2a.rb</code> and run:</p> <pre><code>ruby test_a2a.rb\n</code></pre>"},{"location":"installation/#initial-setup","title":"Initial Setup","text":""},{"location":"installation/#1-create-a-project-directory","title":"1. Create a Project Directory","text":"<p>If you're building an A2A client or server:</p> <pre><code>mkdir my_a2a_project\ncd my_a2a_project\n</code></pre>"},{"location":"installation/#2-initialize-bundler-optional","title":"2. Initialize Bundler (Optional)","text":"<pre><code>bundle init\n</code></pre> <p>Edit the <code>Gemfile</code> to add the a2a gem:</p> <pre><code>source 'https://rubygems.org'\n\ngem 'a2a'\n\n# Optional: Add web framework for server implementations\ngem 'sinatra'  # or 'rails', 'roda', etc.\n\n# Optional: Add HTTP client for client implementations\ngem 'faraday'\n\n# Optional: Development dependencies\ngroup :development do\n  gem 'rspec'\n  gem 'rubocop'\nend\n</code></pre> <p>Then install:</p> <pre><code>bundle install\n</code></pre>"},{"location":"installation/#testing-your-installation","title":"Testing Your Installation","text":""},{"location":"installation/#test-1-load-the-gem","title":"Test 1: Load the Gem","text":"<pre><code>ruby -r a2a -e \"puts 'A2A loaded successfully'\"\n</code></pre>"},{"location":"installation/#test-2-create-models","title":"Test 2: Create Models","text":"<p>Create a file <code>test_models.rb</code>:</p> <pre><code>require 'a2a'\n\n# Test creating different models\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Hello, agent!\"\n)\n\ntask = A2A::Models::Task.new(\n  id: \"test-123\",\n  status: { state: \"submitted\" }\n)\n\nputs \"Message created: #{message.parts.first.text}\"\nputs \"Task state: #{task.state}\"\nputs \"All tests passed!\"\n</code></pre> <p>Run it:</p> <pre><code>ruby test_models.rb\n</code></pre>"},{"location":"installation/#test-3-run-examples","title":"Test 3: Run Examples","text":"<p>The gem includes working examples:</p> <pre><code>ruby examples/basic_usage.rb\n</code></pre> <p>You should see comprehensive output demonstrating various A2A features.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#cannot-load-such-file-a2a","title":"\"Cannot load such file -- a2a\"","text":"<p>Solution: Make sure the gem is installed:</p> <pre><code>gem list a2a\n</code></pre> <p>If not listed, reinstall:</p> <pre><code>gem install a2a\n</code></pre>"},{"location":"installation/#wrong-ruby-version","title":"\"Wrong Ruby version\"","text":"<p>Solution: A2A requires Ruby 3.4.0 or higher. Check your version:</p> <pre><code>ruby --version\n</code></pre> <p>Upgrade Ruby if needed using rbenv, rvm, or your system package manager.</p>"},{"location":"installation/#permission-errors","title":"Permission Errors","text":"<p>Solution: Try installing with the <code>--user-install</code> flag:</p> <pre><code>gem install a2a --user-install\n</code></pre> <p>Or use bundler in your project instead of system-wide installation.</p>"},{"location":"installation/#loaderror-when-requiring","title":"\"LoadError\" when requiring","text":"<p>Solution: Ensure your Ruby's gem bin directory is in your PATH:</p> <pre><code>echo $PATH\ngem environment\n</code></pre> <p>Add the gems directory to your PATH if needed.</p>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the GitHub Issues</li> <li>Review the Examples</li> <li>Read the API Documentation</li> <li>Create a new issue with:</li> <li>Your OS and Ruby version (<code>ruby --version</code>)</li> <li>The exact error message</li> <li>Steps to reproduce</li> </ol>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing to A2A development:</p> <pre><code># Clone the repository\ngit clone https://github.com/madbomber/a2a.git\ncd a2a\n\n# Install dependencies\nbundle install\n\n# Run tests\nbundle exec rspec\n\n# Run linter\nbundle exec rubocop\n\n# Build the gem\nbundle exec rake build\n\n# Install locally\nbundle exec rake install\n</code></pre>"},{"location":"installation/#additional-tools","title":"Additional Tools","text":""},{"location":"installation/#code-quality-tools","title":"Code Quality Tools","text":"<pre><code># Install development tools\ngem install rubocop\ngem install yard\ngem install rspec\n</code></pre>"},{"location":"installation/#type-checking","title":"Type Checking","text":"<p>A2A is designed to work with RBS:</p> <pre><code>gem install rbs\ngem install steep\n\n# Type check (once RBS signatures are added)\nsteep check\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Once A2A is installed:</p> <ol> <li>Read the Quick Start Guide</li> <li>Follow the Getting Started Tutorial</li> <li>Explore Code Examples</li> <li>Review the API Reference</li> </ol>"},{"location":"installation/#updating-a2a","title":"Updating A2A","text":"<p>To update to the latest version:</p> <pre><code>gem update a2a\n</code></pre> <p>Or if using Bundler:</p> <pre><code>bundle update a2a\n</code></pre> <p>Or if installed from source:</p> <pre><code>cd path/to/a2a\ngit pull\nbundle install\nrake install\n</code></pre> <p>Installation complete! Ready to build A2A agents? Continue to the Quick Start Guide.</p>"},{"location":"protocol-spec/","title":"Agent2Agent (A2A) Protocol Specification","text":"<p>An open protocol enabling communication and interoperability between opaque agentic applications.</p> <p>One of the biggest challenges in enterprise AI adoption is getting agents built on different frameworks and vendors to work together. That's why we created an open Agent2Agent (A2A) protocol, a collaborative way to help agents across different ecosystems communicate with each other. Google is driving this open protocol initiative for the industry because we believe this protocol will be critical to support multi-agent communication by giving your agents a common language \u2013 irrespective of the framework or vendor they are built on.</p> <p>With A2A, agents can show each other their capabilities and negotiate how they will interact with users (via text, forms, or bidirectional audio/video) \u2013 all while working securely together.</p>"},{"location":"protocol-spec/#see-a2a-in-action","title":"See A2A in Action","text":"<p>Watch this demo video to see how A2A enables seamless communication between different agent frameworks.</p>"},{"location":"protocol-spec/#conceptual-overview","title":"Conceptual Overview","text":"<p>The Agent2Agent (A2A) protocol facilitates communication between independent AI agents. Here are the core concepts:</p> <ul> <li>Agent Card: A public metadata file (usually at <code>/.well-known/agent.json</code>) describing an agent's capabilities, skills, endpoint URL, and authentication requirements. Clients use this for discovery.</li> <li>A2A Server: An agent exposing an HTTP endpoint that implements the A2A protocol methods (defined in the json specification). It receives requests and manages task execution.</li> <li>A2A Client: An application or another agent that consumes A2A services. It sends requests (like <code>tasks/send</code>) to an A2A Server's URL.</li> <li>Task: The central unit of work. A client initiates a task by sending a message (<code>tasks/send</code> or <code>tasks/sendSubscribe</code>). Tasks have unique IDs and progress through states (<code>submitted</code>, <code>working</code>, <code>input-required</code>, <code>completed</code>, <code>failed</code>, <code>canceled</code>).</li> <li>Message: Represents communication turns between the client (<code>role: \"user\"</code>) and the agent (<code>role: \"agent\"</code>). Messages contain <code>Parts</code>.</li> <li>Part: The fundamental content unit within a <code>Message</code> or <code>Artifact</code>. Can be <code>TextPart</code>, <code>FilePart</code> (with inline bytes or a URI), or <code>DataPart</code> (for structured JSON, e.g., forms).</li> <li>Artifact: Represents outputs generated by the agent during a task (e.g., generated files, final structured data). Artifacts also contain <code>Parts</code>.</li> <li>Streaming: For long-running tasks, servers supporting the <code>streaming</code> capability can use <code>tasks/sendSubscribe</code>. The client receives Server-Sent Events (SSE) containing <code>TaskStatusUpdateEvent</code> or <code>TaskArtifactUpdateEvent</code> messages, providing real-time progress.</li> <li>Push Notifications: Servers supporting <code>pushNotifications</code> can proactively send task updates to a client-provided webhook URL, configured via <code>tasks/pushNotification/set</code>.</li> </ul>"},{"location":"protocol-spec/#typical-flow","title":"Typical Flow","text":"<ol> <li>Discovery: Client fetches the Agent Card from the server's well-known URL.</li> <li>Initiation: Client sends a <code>tasks/send</code> or <code>tasks/sendSubscribe</code> request containing the initial user message and a unique Task ID.</li> <li>Processing:<ul> <li>(Streaming): Server sends SSE events (status updates, artifacts) as the task progresses.</li> <li>(Non-Streaming): Server processes the task synchronously and returns the final <code>Task</code> object in the response.</li> </ul> </li> <li>Interaction (Optional): If the task enters <code>input-required</code>, the client sends subsequent messages using the same Task ID via <code>tasks/send</code> or <code>tasks/sendSubscribe</code>.</li> <li>Completion: The task eventually reaches a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>).</li> </ol>"},{"location":"protocol-spec/#getting-started","title":"Getting Started","text":"<ul> <li>\ud83d\udcda Read the technical documentation</li> <li>\ud83d\udcdd Review the JSON specification</li> <li>\ud83c\udfac Use the official samples to see A2A in action<ul> <li>Sample A2A Client/Server (Python, JS)</li> <li>Multi-Agent Web App</li> <li>CLI (Python, JS)</li> </ul> </li> <li>\ud83e\udd16 Use the sample agents to see how to integrate A2A with agent frameworks<ul> <li>Agent Developer Kit (ADK)</li> <li>CrewAI</li> <li>LangGraph</li> <li>Genkit</li> </ul> </li> <li>\ud83d\udcd1 Review key topics<ul> <li>A2A and MCP</li> <li>Agent Discovery</li> <li>Enterprise Ready</li> <li>Push Notifications</li> </ul> </li> </ul>"},{"location":"protocol-spec/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see the contributing guide to get started.</p> <p>Have questions? Join the community in GitHub discussions.</p> <p>Help with protocol improvement feedback in GitHub issues.</p> <p>Want to send private feedback? Use this Google form</p>"},{"location":"protocol-spec/#whats-next","title":"What's Next","text":"<p>Future plans include improvements to the protocol itself and enhancements to the samples:</p> <p>Protocol Enhancements:</p> <ul> <li>Agent Discovery:<ul> <li>Formalize inclusion of authorization schemes and optional credentials directly within the <code>AgentCard</code>.</li> </ul> </li> <li>Agent Collaboration:<ul> <li>Investigate a <code>QuerySkill()</code> method for dynamically checking unsupported or unanticipated skills.</li> </ul> </li> <li>Task Lifecycle &amp; UX:<ul> <li>Support for dynamic UX negotiation within a task (e.g., agent adding audio/video mid-conversation).</li> </ul> </li> <li>Client Methods &amp; Transport:<ul> <li>Explore extending support to client-initiated methods (beyond task management).</li> <li>Improvements to streaming reliability and push notification mechanisms.</li> </ul> </li> </ul> <p>Sample &amp; Documentation Enhancements:</p> <ul> <li>Simplify \"Hello World\" examples.</li> <li>Include additional examples of agents integrated with different frameworks or showcasing specific A2A features.</li> <li>Provide more comprehensive documentation for the common client/server libraries.</li> <li>Generate human-readable HTML documentation from the JSON Schema.</li> </ul>"},{"location":"protocol-spec/#about","title":"About","text":"<p>A2A Protocol is an open source project run by Google LLC, under Apache 2.0 License and open to contributions from the entire community.</p>"},{"location":"protocol-spec/#related-resources","title":"Related Resources","text":"<ul> <li>Official A2A Protocol Repository</li> <li>A2A Ruby Gem Documentation</li> <li>JSON-RPC 2.0 Specification</li> </ul>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>Get up and running with A2A in minutes. This guide will walk you through the basics of using the A2A Ruby gem.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>First, install the gem:</p> <pre><code>gem install a2a\n</code></pre>"},{"location":"quickstart/#your-first-a2a-program","title":"Your First A2A Program","text":"<p>Create a file called <code>hello_a2a.rb</code>:</p> <pre><code>#!/usr/bin/env ruby\nrequire 'a2a'\n\n# 1. Create an Agent Card\nagent_card = A2A::Models::AgentCard.new(\n  name: \"Hello Agent\",\n  url: \"https://example.com/a2a\",\n  version: \"1.0.0\",\n  description: \"A friendly greeting agent\",\n  capabilities: {\n    streaming: false,\n    push_notifications: false\n  },\n  skills: [\n    {\n      id: \"greeting\",\n      name: \"Greeting\",\n      description: \"Generate friendly greetings\"\n    }\n  ]\n)\n\n# 2. Create a Message\nuser_message = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Say hello!\"\n)\n\n# 3. Create a Task\ntask = A2A::Models::Task.new(\n  id: \"task-#{Time.now.to_i}\",\n  status: {\n    state: \"submitted\"\n  }\n)\n\n# 4. Print results\nputs \"Agent: #{agent_card.name}\"\nputs \"Message: #{user_message.parts.first.text}\"\nputs \"Task ID: #{task.id}\"\nputs \"Task State: #{task.state}\"\n\n# 5. Simulate task progression\ntask = A2A::Models::Task.new(\n  id: task.id,\n  status: {\n    state: \"working\"\n  }\n)\n\nputs \"\\nTask is now: #{task.state}\"\n\n# 6. Complete with an artifact\ncompleted_task = A2A::Models::Task.new(\n  id: task.id,\n  status: {\n    state: \"completed\"\n  },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Greeting\",\n      parts: [\n        A2A::Models::TextPart.new(\n          text: \"Hello! How can I help you today?\"\n        )\n      ]\n    )\n  ]\n)\n\nputs \"Task completed!\"\nputs \"Response: #{completed_task.artifacts.first.parts.first.text}\"\n</code></pre> <p>Run it:</p> <pre><code>ruby hello_a2a.rb\n</code></pre>"},{"location":"quickstart/#core-concepts-in-5-minutes","title":"Core Concepts in 5 Minutes","text":""},{"location":"quickstart/#1-agent-cards-agent-discovery","title":"1. Agent Cards - Agent Discovery","text":"<p>Agent Cards describe what an agent can do:</p> <pre><code>agent_card = A2A::Models::AgentCard.new(\n  name: \"My Agent\",\n  url: \"https://myagent.example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: true,          # Supports SSE streaming\n    push_notifications: true  # Supports webhooks\n  },\n  skills: [\n    {\n      id: \"skill-1\",\n      name: \"Data Analysis\",\n      description: \"Analyze structured data\"\n    }\n  ]\n)\n</code></pre>"},{"location":"quickstart/#2-messages-communication","title":"2. Messages - Communication","text":"<p>Messages contain communication between user and agent:</p> <pre><code># Text message\nuser_msg = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Analyze this data\"\n)\n\n# Agent response with multiple parts\nagent_msg = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Analysis complete:\"),\n    A2A::Models::DataPart.new(\n      data: {\n        mean: 45.5,\n        median: 42,\n        mode: 40\n      }\n    )\n  ]\n)\n</code></pre>"},{"location":"quickstart/#3-tasks-work-units","title":"3. Tasks - Work Units","text":"<p>Tasks track work from submission to completion:</p> <pre><code># Create a new task\ntask = A2A::Models::Task.new(\n  id: \"unique-task-id\",\n  session_id: \"session-123\",  # For multi-turn conversations\n  status: {\n    state: \"submitted\"\n  }\n)\n\n# Check state\ntask.state.submitted?  # =&gt; true\ntask.state.terminal?   # =&gt; false\n\n# Progress through states\nstates = [\"submitted\", \"working\", \"completed\"]\n</code></pre>"},{"location":"quickstart/#4-artifacts-results","title":"4. Artifacts - Results","text":"<p>Artifacts are outputs generated by the agent:</p> <pre><code>artifact = A2A::Models::Artifact.new(\n  name: \"Analysis Results\",\n  description: \"Statistical analysis of dataset\",\n  parts: [\n    A2A::Models::DataPart.new(\n      data: {\n        summary: \"Dataset contains 1000 records\",\n        statistics: { mean: 42, std_dev: 12.5 }\n      }\n    )\n  ]\n)\n</code></pre>"},{"location":"quickstart/#5-parts-content-types","title":"5. Parts - Content Types","text":"<p>Parts are polymorphic content types:</p> <pre><code># Text Part\ntext = A2A::Models::TextPart.new(\n  text: \"Hello, world!\"\n)\n\n# File Part (by URI)\nfile = A2A::Models::FilePart.new(\n  file: {\n    name: \"data.csv\",\n    mime_type: \"text/csv\",\n    uri: \"https://example.com/data.csv\"\n  }\n)\n\n# File Part (inline bytes)\nfile_bytes = A2A::Models::FilePart.new(\n  file: {\n    name: \"report.pdf\",\n    mime_type: \"application/pdf\",\n    bytes: Base64.strict_encode64(pdf_content)\n  }\n)\n\n# Data Part (structured JSON)\ndata = A2A::Models::DataPart.new(\n  data: {\n    results: [1, 2, 3, 4, 5],\n    metadata: { processed_at: Time.now }\n  }\n)\n</code></pre>"},{"location":"quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/#pattern-1-serialize-to-json","title":"Pattern 1: Serialize to JSON","text":"<pre><code>require 'json'\n\nagent_card = A2A::Models::AgentCard.new(\n  name: \"My Agent\",\n  url: \"https://example.com\",\n  version: \"1.0.0\",\n  capabilities: { streaming: false },\n  skills: [{ id: \"test\", name: \"Test\" }]\n)\n\n# Convert to hash\nhash = agent_card.to_h\n\n# Convert to JSON\njson = JSON.pretty_generate(hash)\nputs json\n</code></pre>"},{"location":"quickstart/#pattern-2-deserialize-from-json","title":"Pattern 2: Deserialize from JSON","text":"<pre><code>require 'json'\n\njson_string = File.read('agent_card.json')\nhash = JSON.parse(json_string)\n\nagent_card = A2A::Models::AgentCard.from_hash(hash)\nputs agent_card.name\n</code></pre>"},{"location":"quickstart/#pattern-3-error-handling","title":"Pattern 3: Error Handling","text":"<pre><code>begin\n  # Try invalid state\n  state = A2A::Models::TaskState.new(\"invalid\")\nrescue ArgumentError =&gt; e\n  puts \"Error: #{e.message}\"\nend\n\nbegin\n  # Try to raise protocol error\n  raise A2A::TaskNotFoundError\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Error code: #{e.code}\"\n  puts \"Message: #{e.message}\"\nend\n</code></pre>"},{"location":"quickstart/#pattern-4-multi-turn-conversation","title":"Pattern 4: Multi-turn Conversation","text":"<pre><code>session_id = \"session-#{SecureRandom.uuid}\"\n\n# First message\ntask1 = A2A::Models::Task.new(\n  id: \"task-1\",\n  session_id: session_id,\n  status: { state: \"completed\" }\n)\n\n# Follow-up message in same session\ntask2 = A2A::Models::Task.new(\n  id: \"task-2\",\n  session_id: session_id,  # Same session!\n  status: { state: \"submitted\" }\n)\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":""},{"location":"quickstart/#learn-more","title":"Learn More","text":"<ul> <li>Getting Started Guide - Comprehensive tutorial</li> <li>Creating Agent Cards - Agent discovery</li> <li>Working with Tasks - Task lifecycle</li> <li>Messages and Parts - Communication</li> </ul>"},{"location":"quickstart/#build-something","title":"Build Something","text":"<ul> <li>Build a Client - Implement an A2A client</li> <li>Build a Server - Implement an A2A server</li> <li>Basic Examples - More code examples</li> </ul>"},{"location":"quickstart/#reference","title":"Reference","text":"<ul> <li>API Documentation - Complete API reference</li> <li>Architecture - System design</li> <li>Protocol Specification - Official A2A spec</li> </ul>"},{"location":"quickstart/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"quickstart/#use-factory-methods","title":"Use Factory Methods","text":"<pre><code># Instead of creating parts manually\nmessage = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [A2A::Models::TextPart.new(text: \"Hello\")]\n)\n\n# Use the factory method\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Hello\"\n)\n</code></pre>"},{"location":"quickstart/#check-task-states","title":"Check Task States","text":"<pre><code>task = A2A::Models::Task.new(\n  id: \"task-123\",\n  status: { state: \"completed\" }\n)\n\n# Use helper methods\ntask.state.completed?  # =&gt; true\ntask.state.terminal?   # =&gt; true (completed, failed, or canceled)\ntask.state.working?    # =&gt; false\n</code></pre>"},{"location":"quickstart/#validate-data","title":"Validate Data","text":"<p>The gem validates data automatically:</p> <pre><code># This will raise ArgumentError\nA2A::Models::TaskState.new(\"invalid-state\")\n\n# This will raise ArgumentError\nA2A::Models::FileContent.new(name: \"file.txt\")  # Missing bytes or uri\n</code></pre>"},{"location":"quickstart/#common-questions","title":"Common Questions","text":"<p>Q: How do I serve an Agent Card at <code>/.well-known/agent.json</code>?</p> <p>A: Use a web framework like Sinatra:</p> <pre><code>require 'sinatra'\nrequire 'a2a'\nrequire 'json'\n\nget '/.well-known/agent.json' do\n  content_type :json\n\n  agent = A2A::Models::AgentCard.new(\n    name: \"My Agent\",\n    url: \"https://#{request.host}/a2a\",\n    version: \"1.0.0\",\n    capabilities: { streaming: false },\n    skills: [{ id: \"test\", name: \"Test\" }]\n  )\n\n  JSON.generate(agent.to_h)\nend\n</code></pre> <p>Q: How do I implement an A2A server?</p> <p>A: Subclass <code>A2A::Server::Base</code> and implement the handler methods. See the Server Guide.</p> <p>Q: How do I make HTTP requests as a client?</p> <p>A: Subclass <code>A2A::Client::Base</code> and implement the HTTP logic. See the Client Guide.</p> <p>Ready for more? Continue to the Getting Started Guide for a comprehensive tutorial.</p>"},{"location":"the_handshake/","title":"The Handshake","text":"Your browser does not support the video tag.    <p> Agent-to-Agent Protocol: The Foundation of Interoperable AI Communication </p>"},{"location":"the_handshake/#about-this-video","title":"About This Video","text":"<p>This video illustrates the core concept of the Agent-to-Agent (A2A) protocol - the handshake between independent AI agents that enables seamless communication and interoperability.</p>"},{"location":"the_handshake/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Discovery: Agents find and identify each other through Agent Cards</li> <li>Protocol Compliance: Standardized communication using JSON-RPC 2.0</li> <li>Interoperability: Different agents working together seamlessly</li> <li>Task Exchange: Structured task submission and completion</li> </ul>"},{"location":"the_handshake/#learn-more","title":"Learn More","text":"<ul> <li>Getting Started Guide</li> <li>Protocol Specification</li> <li>API Reference</li> <li>Architecture Overview</li> </ul> <p>Back to Documentation Home</p>"},{"location":"advanced/conversations/","title":"Multi-Turn Conversations with Session Management","text":"<p>Comprehensive guide to implementing stateful multi-turn conversations and session management in the A2A protocol.</p>"},{"location":"advanced/conversations/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>When to Use Sessions</li> <li>Architecture</li> <li>Session Lifecycle</li> <li>Implementation Guide</li> <li>Server-Side Session Management</li> <li>Client-Side Session Handling</li> <li>Context Management</li> <li>State Handling</li> <li>Best Practices</li> <li>Complete Examples</li> <li>Testing Strategies</li> <li>Troubleshooting</li> </ul>"},{"location":"advanced/conversations/#overview","title":"Overview","text":"<p>Multi-turn conversations allow agents and clients to maintain context across multiple task exchanges. The A2A protocol supports sessions through the <code>sessionId</code> field in tasks, enabling agents to remember previous interactions and provide contextually aware responses.</p>"},{"location":"advanced/conversations/#session-concept","title":"Session Concept","text":"<p>A session represents a logical conversation boundary. All tasks with the same <code>sessionId</code> belong to the same conversation and share context.</p> <pre><code># First turn in conversation\ntask1 = A2A::Models::Task.new(\n  id: \"task-1\",\n  session_id: \"session-abc123\",  # Session identifier\n  status: { state: \"submitted\" }\n)\n\n# Second turn in same conversation\ntask2 = A2A::Models::Task.new(\n  id: \"task-2\",\n  session_id: \"session-abc123\",  # Same session\n  status: { state: \"submitted\" }\n)\n\n# New conversation\ntask3 = A2A::Models::Task.new(\n  id: \"task-3\",\n  session_id: \"session-xyz789\",  # Different session\n  status: { state: \"submitted\" }\n)\n</code></pre>"},{"location":"advanced/conversations/#when-to-use-sessions","title":"When to Use Sessions","text":"<p>Sessions are ideal for:</p> <ol> <li>Interactive Conversations: Back-and-forth dialogue between user and agent</li> <li>Multi-Step Workflows: Tasks that require multiple turns to complete</li> <li>Context-Dependent Tasks: Where previous turns inform current responses</li> <li>Progressive Refinement: Iterative improvement based on feedback</li> <li>Input-Required States: When agent needs clarification or additional data</li> </ol> <p>Don't use sessions for: - One-off independent requests - Tasks that don't benefit from context - High-volume stateless operations</p>"},{"location":"advanced/conversations/#architecture","title":"Architecture","text":"<pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1000 700\" style=\"background:transparent\"&gt;\n  &lt;!-- Client --&gt;\n  &lt;rect x=\"50\" y=\"50\" width=\"150\" height=\"80\" fill=\"#1e3a8a\" stroke=\"#3b82f6\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"125\" y=\"95\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;A2A Client&lt;/text&gt;\n\n  &lt;!-- Server --&gt;\n  &lt;rect x=\"800\" y=\"50\" width=\"150\" height=\"80\" fill=\"#1e3a8a\" stroke=\"#3b82f6\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"875\" y=\"95\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;A2A Server&lt;/text&gt;\n\n  &lt;!-- Session Store --&gt;\n  &lt;rect x=\"800\" y=\"200\" width=\"150\" height=\"80\" fill=\"#7c3aed\" stroke=\"#a78bfa\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"875\" y=\"235\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"14\" font-weight=\"bold\"&gt;Session Store&lt;/text&gt;\n  &lt;text x=\"875\" y=\"255\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;(Context + State)&lt;/text&gt;\n\n  &lt;!-- Agent --&gt;\n  &lt;rect x=\"800\" y=\"550\" width=\"150\" height=\"80\" fill=\"#064e3b\" stroke=\"#10b981\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"875\" y=\"595\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;Agent Core&lt;/text&gt;\n\n  &lt;!-- Turn 1: Initial Request --&gt;\n  &lt;line x1=\"200\" y1=\"90\" x2=\"790\" y2=\"90\" stroke=\"#3b82f6\" stroke-width=\"2\" marker-end=\"url(#arrowblue)\"/&gt;\n  &lt;text x=\"495\" y=\"75\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;1. task-1 (session-abc)&lt;/text&gt;\n\n  &lt;!-- Create Session --&gt;\n  &lt;line x1=\"875\" y1=\"130\" x2=\"875\" y2=\"190\" stroke=\"#a78bfa\" stroke-width=\"2\" stroke-dasharray=\"5,5\" marker-end=\"url(#arrowpurple)\"/&gt;\n  &lt;text x=\"905\" y=\"160\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Create&lt;/text&gt;\n\n  &lt;!-- Process --&gt;\n  &lt;line x1=\"875\" y1=\"280\" x2=\"875\" y2=\"540\" stroke=\"#f59e0b\" stroke-width=\"2\" marker-end=\"url(#arroworange)\"/&gt;\n\n  &lt;!-- Response 1 --&gt;\n  &lt;line x1=\"790\" y1=\"110\" x2=\"210\" y2=\"110\" stroke=\"#10b981\" stroke-width=\"2\" stroke-dasharray=\"5,5\"/&gt;\n  &lt;text x=\"495\" y=\"125\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;2. Response (input-required)&lt;/text&gt;\n\n  &lt;!-- Turn 2: Follow-up --&gt;\n  &lt;line x1=\"200\" y1=\"180\" x2=\"790\" y2=\"180\" stroke=\"#3b82f6\" stroke-width=\"2\" marker-end=\"url(#arrowblue)\"/&gt;\n  &lt;text x=\"495\" y=\"165\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;3. task-2 (session-abc) + user input&lt;/text&gt;\n\n  &lt;!-- Load Session --&gt;\n  &lt;line x1=\"875\" y1=\"220\" x2=\"875\" y2=\"180\" stroke=\"#a78bfa\" stroke-width=\"2\" stroke-dasharray=\"5,5\" marker-end=\"url(#arrowpurple)\"/&gt;\n  &lt;text x=\"920\" y=\"200\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Load Context&lt;/text&gt;\n\n  &lt;!-- Response 2 --&gt;\n  &lt;line x1=\"790\" y1=\"200\" x2=\"210\" y2=\"200\" stroke=\"#10b981\" stroke-width=\"2\" stroke-dasharray=\"5,5\"/&gt;\n  &lt;text x=\"495\" y=\"215\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;4. Response (working)&lt;/text&gt;\n\n  &lt;!-- Turn 3: Final Input --&gt;\n  &lt;line x1=\"200\" y1=\"270\" x2=\"790\" y2=\"270\" stroke=\"#3b82f6\" stroke-width=\"2\" marker-end=\"url(#arrowblue)\"/&gt;\n  &lt;text x=\"495\" y=\"255\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;5. task-3 (session-abc) + confirmation&lt;/text&gt;\n\n  &lt;!-- Update Session --&gt;\n  &lt;line x1=\"875\" y1=\"240\" x2=\"875\" y2=\"270\" stroke=\"#a78bfa\" stroke-width=\"2\" marker-end=\"url(#arrowpurple)\"/&gt;\n  &lt;text x=\"905\" y=\"255\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Update&lt;/text&gt;\n\n  &lt;!-- Final Response --&gt;\n  &lt;line x1=\"790\" y1=\"350\" x2=\"210\" y2=\"350\" stroke=\"#10b981\" stroke-width=\"2\" stroke-dasharray=\"5,5\"/&gt;\n  &lt;text x=\"495\" y=\"335\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;6. Response (completed)&lt;/text&gt;\n\n  &lt;!-- Conversation Flow Label --&gt;\n  &lt;rect x=\"350\" y=\"400\" width=\"300\" height=\"40\" fill=\"none\" stroke=\"#f59e0b\" stroke-width=\"2\" stroke-dasharray=\"5,5\" rx=\"5\"/&gt;\n  &lt;text x=\"500\" y=\"425\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"14\" font-weight=\"bold\"&gt;Multi-Turn Conversation&lt;/text&gt;\n\n  &lt;!-- Arrow markers --&gt;\n  &lt;defs&gt;\n    &lt;marker id=\"arrowblue\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#3b82f6\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowgreen\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#10b981\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arroworange\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#f59e0b\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowpurple\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#a78bfa\"/&gt;\n    &lt;/marker&gt;\n  &lt;/defs&gt;\n&lt;/svg&gt;\n</code></pre>"},{"location":"advanced/conversations/#flow-description","title":"Flow Description","text":"<ol> <li>Initial Request: Client sends first task with new session ID</li> <li>Create Session: Server initializes session context</li> <li>Agent Needs Input: Returns task in <code>input-required</code> state</li> <li>Follow-up Request: Client sends next task with same session ID and additional input</li> <li>Load Context: Server retrieves session context from previous turns</li> <li>Process with Context: Agent uses accumulated context to process request</li> <li>Update Session: Session state updated with new information</li> <li>Complete: Final response with <code>completed</code> state</li> </ol>"},{"location":"advanced/conversations/#session-lifecycle","title":"Session Lifecycle","text":""},{"location":"advanced/conversations/#state-diagram","title":"State Diagram","text":"<pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 800 500\" style=\"background:transparent\"&gt;\n  &lt;!-- New Session --&gt;\n  &lt;circle cx=\"400\" cy=\"80\" r=\"40\" fill=\"#064e3b\" stroke=\"#10b981\" stroke-width=\"2\"/&gt;\n  &lt;text x=\"400\" y=\"85\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\" font-weight=\"bold\"&gt;New&lt;/text&gt;\n  &lt;text x=\"400\" y=\"140\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;sessionId assigned&lt;/text&gt;\n\n  &lt;!-- Active Session --&gt;\n  &lt;circle cx=\"400\" cy=\"250\" r=\"50\" fill=\"#1e3a8a\" stroke=\"#3b82f6\" stroke-width=\"2\"/&gt;\n  &lt;text x=\"400\" y=\"245\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\" font-weight=\"bold\"&gt;Active&lt;/text&gt;\n  &lt;text x=\"400\" y=\"260\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Multi-turn&lt;/text&gt;\n  &lt;text x=\"400\" y=\"275\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;conversation&lt;/text&gt;\n\n  &lt;!-- Completed Session --&gt;\n  &lt;circle cx=\"200\" cy=\"420\" r=\"40\" fill=\"#065f46\" stroke=\"#10b981\" stroke-width=\"2\"/&gt;\n  &lt;text x=\"200\" y=\"415\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\" font-weight=\"bold\"&gt;Completed&lt;/text&gt;\n  &lt;text x=\"200\" y=\"430\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Goal achieved&lt;/text&gt;\n\n  &lt;!-- Expired Session --&gt;\n  &lt;circle cx=\"600\" cy=\"420\" r=\"40\" fill=\"#7f1d1d\" stroke=\"#ef4444\" stroke-width=\"2\"/&gt;\n  &lt;text x=\"600\" y=\"415\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\" font-weight=\"bold\"&gt;Expired&lt;/text&gt;\n  &lt;text x=\"600\" y=\"430\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Timeout/TTL&lt;/text&gt;\n\n  &lt;!-- Transitions --&gt;\n  &lt;line x1=\"400\" y1=\"120\" x2=\"400\" y2=\"195\" stroke=\"#10b981\" stroke-width=\"2\" marker-end=\"url(#arrowgreen)\"/&gt;\n  &lt;text x=\"430\" y=\"160\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;First task&lt;/text&gt;\n\n  &lt;path d=\"M 350,280 Q 280,350 220,385\" stroke=\"#10b981\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#arrowgreen)\"/&gt;\n  &lt;text x=\"280\" y=\"340\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Success&lt;/text&gt;\n\n  &lt;path d=\"M 450,280 Q 520,350 580,385\" stroke=\"#ef4444\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#arrowred)\"/&gt;\n  &lt;text x=\"500\" y=\"340\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Timeout&lt;/text&gt;\n\n  &lt;!-- Self loop for active --&gt;\n  &lt;path d=\"M 455,250 Q 500,250 500,280 Q 500,310 455,310\" stroke=\"#3b82f6\" stroke-width=\"2\" fill=\"none\" marker-end=\"url(#arrowblue)\"/&gt;\n  &lt;text x=\"510\" y=\"280\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;Continued turns&lt;/text&gt;\n\n  &lt;!-- Arrow markers --&gt;\n  &lt;defs&gt;\n    &lt;marker id=\"arrowblue\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#3b82f6\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowgreen\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#10b981\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowred\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#ef4444\"/&gt;\n    &lt;/marker&gt;\n  &lt;/defs&gt;\n&lt;/svg&gt;\n</code></pre>"},{"location":"advanced/conversations/#session-states","title":"Session States","text":"<ol> <li>New: Session created but no tasks processed yet</li> <li>Active: Session has active ongoing conversation</li> <li>Completed: All tasks in session completed successfully</li> <li>Expired: Session timeout or TTL exceeded</li> </ol>"},{"location":"advanced/conversations/#implementation-guide","title":"Implementation Guide","text":""},{"location":"advanced/conversations/#server-side-session-management","title":"Server-Side Session Management","text":""},{"location":"advanced/conversations/#session-manager","title":"Session Manager","text":"<pre><code>require 'a2a'\n\nclass SessionManager\n  DEFAULT_TTL = 3600 # 1 hour\n\n  def initialize(ttl: DEFAULT_TTL)\n    @sessions = {} # sessionId =&gt; Session\n    @ttl = ttl\n    @cleanup_thread = start_cleanup_thread\n  end\n\n  # Get or create session\n  def get_session(session_id)\n    cleanup_expired_sessions\n\n    @sessions[session_id] ||= Session.new(session_id, @ttl)\n  end\n\n  # Remove session\n  def remove_session(session_id)\n    @sessions.delete(session_id)\n  end\n\n  # Check if session exists\n  def session_exists?(session_id)\n    @sessions.key?(session_id) &amp;&amp; !@sessions[session_id].expired?\n  end\n\n  # Get session stats\n  def stats\n    {\n      total_sessions: @sessions.size,\n      active_sessions: @sessions.count { |_, s| !s.expired? }\n    }\n  end\n\n  private\n\n  def cleanup_expired_sessions\n    @sessions.delete_if { |_, session| session.expired? }\n  end\n\n  def start_cleanup_thread\n    Thread.new do\n      loop do\n        sleep(60) # Run cleanup every minute\n        cleanup_expired_sessions\n      rescue StandardError =&gt; e\n        debug_me \"Cleanup error: #{e.message}\"\n      end\n    end\n  end\nend\n\nclass Session\n  attr_reader :id, :created_at, :updated_at, :context, :task_history\n\n  def initialize(id, ttl)\n    @id = id\n    @ttl = ttl\n    @created_at = Time.now\n    @updated_at = Time.now\n    @context = {}\n    @task_history = []\n  end\n\n  # Add task to history\n  def add_task(task, message)\n    @task_history &lt;&lt; {\n      task_id: task.id,\n      message: message,\n      status: task.status,\n      timestamp: Time.now\n    }\n\n    touch\n  end\n\n  # Update context\n  def update_context(key, value)\n    @context[key] = value\n    touch\n  end\n\n  # Get context value\n  def get_context(key)\n    @context[key]\n  end\n\n  # Get all messages in conversation\n  def get_messages\n    @task_history.map { |entry| entry[:message] }\n  end\n\n  # Get last user message\n  def get_last_user_message\n    @task_history.reverse.find { |entry| entry[:message].role == 'user' }&amp;.dig(:message)\n  end\n\n  # Get last agent message\n  def get_last_agent_message\n    @task_history.reverse.find { |entry| entry[:message].role == 'agent' }&amp;.dig(:message)\n  end\n\n  # Check if expired\n  def expired?\n    Time.now - @updated_at &gt; @ttl\n  end\n\n  # Get session age\n  def age\n    Time.now - @created_at\n  end\n\n  # Get turn count\n  def turn_count\n    @task_history.size\n  end\n\n  private\n\n  def touch\n    @updated_at = Time.now\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#server-with-session-support","title":"Server with Session Support","text":"<pre><code>require 'a2a'\n\nclass A2AConversationalServer &lt; A2A::Server::Base\n  def initialize(agent_card)\n    super(agent_card)\n    @session_manager = SessionManager.new(ttl: 3600)\n    @task_store = {}\n  end\n\n  def handle_send_task(params)\n    task = A2A::Models::Task.from_hash(params['task'] || params[:task])\n    message = A2A::Models::Message.from_hash(params['message'] || params[:message])\n\n    # Get or create session\n    session = nil\n    if task.session_id\n      session = @session_manager.get_session(task.session_id)\n      debug_me \"Using existing session: #{task.session_id}\"\n    else\n      debug_me \"No session ID provided, processing as one-off task\"\n    end\n\n    # Add to session history\n    session&amp;.add_task(task, message)\n\n    # Process with context\n    result_task = process_with_context(task, message, session)\n\n    # Store task\n    @task_store[result_task.id] = result_task\n\n    result_task\n  end\n\n  def handle_get_task(params)\n    task_id = params['taskId'] || params[:taskId]\n\n    task = @task_store[task_id]\n    raise A2A::TaskNotFoundError unless task\n\n    task\n  end\n\n  private\n\n  def process_with_context(task, message, session)\n    # Extract user intent\n    user_text = message.parts.find { |p| p.is_a?(A2A::Models::TextPart) }&amp;.text\n\n    if session\n      # Multi-turn conversation logic\n      process_multi_turn(task, message, session, user_text)\n    else\n      # Single turn logic\n      process_single_turn(task, message, user_text)\n    end\n  end\n\n  def process_multi_turn(task, message, session, user_text)\n    # Get conversation history\n    previous_messages = session.get_messages\n\n    debug_me \"Processing turn #{session.turn_count} in session #{session.id}\"\n    debug_me \"Previous messages: #{previous_messages.size}\"\n\n    # Check if we have required context\n    if session.get_context(:waiting_for_details) &amp;&amp; session.get_context(:topic)\n      # We asked for details and now have them\n      topic = session.get_context(:topic)\n\n      session.update_context(:waiting_for_details, false)\n      session.update_context(:details_provided, user_text)\n\n      # Generate complete response\n      response_text = generate_detailed_response(topic, user_text, previous_messages)\n\n      result_task = A2A::Models::Task.new(\n        id: task.id,\n        session_id: task.session_id,\n        status: {\n          state: 'completed',\n          message: A2A::Models::Message.text(\n            role: 'agent',\n            text: response_text\n          ),\n          timestamp: Time.now.utc.iso8601\n        },\n        artifacts: [create_summary_artifact(session)],\n        metadata: {\n          session_turns: session.turn_count\n        }\n      )\n\n      # Session complete, could clean up\n      # @session_manager.remove_session(session.id)\n\n      result_task\n\n    elsif requires_more_info?(user_text)\n      # Need to ask for clarification\n      session.update_context(:topic, extract_topic(user_text))\n      session.update_context(:waiting_for_details, true)\n\n      A2A::Models::Task.new(\n        id: task.id,\n        session_id: task.session_id,\n        status: {\n          state: 'input-required',\n          message: A2A::Models::Message.text(\n            role: 'agent',\n            text: \"I'd be happy to help with that. Could you provide more details about what specifically you'd like to know?\"\n          ),\n          timestamp: Time.now.utc.iso8601\n        }\n      )\n\n    else\n      # Can answer directly\n      response_text = generate_response(user_text, previous_messages)\n\n      A2A::Models::Task.new(\n        id: task.id,\n        session_id: task.session_id,\n        status: {\n          state: 'completed',\n          message: A2A::Models::Message.text(\n            role: 'agent',\n            text: response_text\n          ),\n          timestamp: Time.now.utc.iso8601\n        }\n      )\n    end\n  end\n\n  def process_single_turn(task, message, user_text)\n    # Simple one-off processing\n    response_text = generate_response(user_text, [])\n\n    A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: {\n        state: 'completed',\n        message: A2A::Models::Message.text(\n          role: 'agent',\n          text: response_text\n        ),\n        timestamp: Time.now.utc.iso8601\n      }\n    )\n  end\n\n  def requires_more_info?(text)\n    # Simple heuristic - in practice use NLP\n    text.length &lt; 20 || text.split.size &lt; 5\n  end\n\n  def extract_topic(text)\n    # Extract main topic - simplified\n    text.split.find { |word| word.length &gt; 5 } || \"general query\"\n  end\n\n  def generate_response(text, context_messages)\n    # Generate response using context\n    context_summary = if context_messages.any?\n      \"Based on our previous conversation... \"\n    else\n      \"\"\n    end\n\n    \"#{context_summary}Here's information about: #{text}\"\n  end\n\n  def generate_detailed_response(topic, details, context)\n    \"Great! Based on your question about #{topic} and the details you provided (#{details}), here's a comprehensive answer...\"\n  end\n\n  def create_summary_artifact(session)\n    A2A::Models::Artifact.new(\n      name: \"Conversation Summary\",\n      parts: [\n        A2A::Models::DataPart.new(\n          data: {\n            session_id: session.id,\n            turn_count: session.turn_count,\n            duration: session.age.round(2),\n            topics: session.context.keys.map(&amp;:to_s)\n          }\n        )\n      ]\n    )\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#client-side-session-handling","title":"Client-Side Session Handling","text":""},{"location":"advanced/conversations/#conversational-client","title":"Conversational Client","text":"<pre><code>require 'a2a'\nrequire 'securerandom'\n\nclass A2AConversationalClient &lt; A2A::Client::Base\n  def initialize(agent_url)\n    super(agent_url)\n    @http_client = HTTP.timeout(connect: 5, write: 10, read: 10)\n    @current_session = nil\n  end\n\n  # Start new conversation\n  def start_conversation\n    @current_session = ConversationSession.new\n    debug_me \"Started conversation: #{@current_session.id}\"\n    @current_session\n  end\n\n  # Send message in current conversation\n  def send_message(text, session: nil)\n    session ||= @current_session\n    raise ArgumentError, \"No active session\" unless session\n\n    message = A2A::Models::Message.text(role: 'user', text: text)\n\n    task = send_task(\n      task_id: \"task-#{SecureRandom.uuid}\",\n      message: message,\n      session_id: session.id\n    )\n\n    # Add to session history\n    session.add_turn(message, task)\n\n    task\n  end\n\n  # End conversation\n  def end_conversation\n    session = @current_session\n    @current_session = nil\n    debug_me \"Ended conversation: #{session.id}\"\n    session\n  end\n\n  # Get current session\n  def current_session\n    @current_session\n  end\n\n  def send_task(task_id:, message:, session_id: nil)\n    task = A2A::Models::Task.new(\n      id: task_id,\n      session_id: session_id,\n      status: {\n        state: 'submitted',\n        timestamp: Time.now.utc.iso8601\n      }\n    )\n\n    request = {\n      jsonrpc: \"2.0\",\n      id: task_id,\n      method: \"tasks/send\",\n      params: {\n        task: task.to_h,\n        message: message.to_h\n      }\n    }\n\n    response = @http_client.post(\n      agent_url,\n      json: request,\n      headers: { 'Content-Type' =&gt; 'application/json' }\n    )\n\n    unless response.status.success?\n      raise A2A::InternalError, \"HTTP #{response.status}: #{response.body}\"\n    end\n\n    result = JSON.parse(response.body, symbolize_names: true)\n    A2A::Models::Task.from_hash(result[:result])\n  end\nend\n\nclass ConversationSession\n  attr_reader :id, :created_at, :turns\n\n  def initialize\n    @id = \"session-#{SecureRandom.uuid}\"\n    @created_at = Time.now\n    @turns = []\n  end\n\n  def add_turn(user_message, agent_response)\n    @turns &lt;&lt; {\n      user: user_message,\n      agent: agent_response,\n      timestamp: Time.now\n    }\n  end\n\n  def turn_count\n    @turns.size\n  end\n\n  def get_context_messages\n    messages = []\n    @turns.each do |turn|\n      messages &lt;&lt; turn[:user]\n      if turn[:agent].status.message\n        messages &lt;&lt; turn[:agent].status.message\n      end\n    end\n    messages\n  end\n\n  def last_user_message\n    @turns.last&amp;.dig(:user)\n  end\n\n  def last_agent_response\n    @turns.last&amp;.dig(:agent)\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#using-the-conversational-client","title":"Using the Conversational Client","text":"<pre><code># Interactive conversation example\nclient = A2AConversationalClient.new('https://api.example.com/a2a')\n\n# Start conversation\nsession = client.start_conversation\n\n# Turn 1\nresponse1 = client.send_message(\"Tell me about machine learning\")\n\nif response1.status.state.value == 'input-required'\n  # Agent needs more info\n  agent_msg = response1.status.message.parts.first.text\n  debug_me \"Agent: #{agent_msg}\"\n\n  # Turn 2 - Provide details\n  response2 = client.send_message(\n    \"I'm interested in supervised learning algorithms for classification\",\n    session: session\n  )\n\n  if response2.status.state.completed?\n    agent_msg = response2.status.message.parts.first.text\n    debug_me \"Agent: #{agent_msg}\"\n\n    # Check for artifacts\n    if response2.artifacts&amp;.any?\n      debug_me \"Received #{response2.artifacts.size} artifacts\"\n    end\n  end\nend\n\n# End conversation\nfinal_session = client.end_conversation\ndebug_me \"Conversation had #{final_session.turn_count} turns\"\n</code></pre>"},{"location":"advanced/conversations/#context-management","title":"Context Management","text":""},{"location":"advanced/conversations/#context-strategies","title":"Context Strategies","text":"<pre><code>class ContextManager\n  def initialize\n    @contexts = {}\n  end\n\n  # Store conversation context\n  def set_context(session_id, key, value)\n    @contexts[session_id] ||= {}\n    @contexts[session_id][key] = {\n      value: value,\n      timestamp: Time.now\n    }\n  end\n\n  # Get context value\n  def get_context(session_id, key)\n    @contexts.dig(session_id, key, :value)\n  end\n\n  # Get all context\n  def get_all_context(session_id)\n    @contexts[session_id]&amp;.transform_values { |v| v[:value] } || {}\n  end\n\n  # Check if context exists\n  def has_context?(session_id, key)\n    @contexts.dig(session_id, key).present?\n  end\n\n  # Clear session context\n  def clear_session(session_id)\n    @contexts.delete(session_id)\n  end\n\n  # Get context age\n  def context_age(session_id, key)\n    timestamp = @contexts.dig(session_id, key, :timestamp)\n    return nil unless timestamp\n\n    Time.now - timestamp\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#context-types","title":"Context Types","text":"<pre><code>module ContextTypes\n  # User preferences\n  class UserPreferences\n    attr_accessor :language, :format, :verbosity\n\n    def initialize\n      @language = 'en'\n      @format = 'text'\n      @verbosity = 'normal'\n    end\n  end\n\n  # Conversation state\n  class ConversationState\n    attr_accessor :current_topic, :subtopics_discussed, :pending_questions\n\n    def initialize\n      @current_topic = nil\n      @subtopics_discussed = []\n      @pending_questions = []\n    end\n\n    def add_subtopic(topic)\n      @subtopics_discussed &lt;&lt; topic unless @subtopics_discussed.include?(topic)\n    end\n  end\n\n  # Task context\n  class TaskContext\n    attr_accessor :original_request, :refinements, :constraints\n\n    def initialize(original_request)\n      @original_request = original_request\n      @refinements = []\n      @constraints = {}\n    end\n\n    def add_refinement(refinement)\n      @refinements &lt;&lt; refinement\n    end\n\n    def add_constraint(key, value)\n      @constraints[key] = value\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#state-handling","title":"State Handling","text":""},{"location":"advanced/conversations/#managing-input-required-state","title":"Managing Input-Required State","text":"<pre><code>class InputRequiredHandler\n  def handle_input_required(task, session)\n    # Extract what input is needed\n    agent_message = task.status.message\n    input_request = extract_input_request(agent_message)\n\n    # Store what we're waiting for\n    session.update_context(:awaiting_input, input_request)\n    session.update_context(:awaiting_input_task_id, task.id)\n\n    debug_me \"Session #{session.id} now awaiting: #{input_request}\"\n  end\n\n  def handle_input_provided(task, message, session)\n    awaited_input = session.get_context(:awaiting_input)\n\n    unless awaited_input\n      debug_me \"Warning: Received input but not awaiting any\"\n      return\n    end\n\n    # Extract provided input\n    user_text = message.parts.find { |p| p.is_a?(A2A::Models::TextPart) }&amp;.text\n\n    # Store provided input\n    session.update_context(\"provided_#{awaited_input}\", user_text)\n    session.update_context(:awaiting_input, nil)\n\n    debug_me \"Received awaited input: #{awaited_input} = #{user_text}\"\n  end\n\n  private\n\n  def extract_input_request(message)\n    # Parse agent message to understand what's needed\n    # This is simplified - real implementation would use NLP\n    text = message.parts.first&amp;.text || \"\"\n\n    if text.include?(\"details\")\n      :details\n    elsif text.include?(\"confirm\")\n      :confirmation\n    elsif text.include?(\"choose\") || text.include?(\"select\")\n      :choice\n    else\n      :general_input\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#state-persistence","title":"State Persistence","text":"<pre><code>require 'json'\n\nclass PersistentSessionManager &lt; SessionManager\n  def initialize(storage_path: './sessions', ttl: 3600)\n    super(ttl: ttl)\n    @storage_path = storage_path\n    FileUtils.mkdir_p(@storage_path)\n    load_sessions\n  end\n\n  def get_session(session_id)\n    unless @sessions[session_id]\n      # Try to load from disk\n      loaded = load_session_from_disk(session_id)\n      @sessions[session_id] = loaded if loaded\n    end\n\n    super\n  end\n\n  def save_session(session)\n    File.write(\n      session_file_path(session.id),\n      serialize_session(session)\n    )\n  end\n\n  private\n\n  def load_sessions\n    return unless Dir.exist?(@storage_path)\n\n    Dir.glob(File.join(@storage_path, '*.json')).each do |file|\n      begin\n        data = JSON.parse(File.read(file), symbolize_names: true)\n        session = deserialize_session(data)\n        @sessions[session.id] = session unless session.expired?\n      rescue StandardError =&gt; e\n        debug_me \"Failed to load session from #{file}: #{e.message}\"\n      end\n    end\n\n    debug_me \"Loaded #{@sessions.size} sessions from disk\"\n  end\n\n  def load_session_from_disk(session_id)\n    file_path = session_file_path(session_id)\n    return nil unless File.exist?(file_path)\n\n    data = JSON.parse(File.read(file_path), symbolize_names: true)\n    deserialize_session(data)\n  rescue StandardError =&gt; e\n    debug_me \"Failed to load session #{session_id}: #{e.message}\"\n    nil\n  end\n\n  def session_file_path(session_id)\n    File.join(@storage_path, \"#{session_id}.json\")\n  end\n\n  def serialize_session(session)\n    JSON.pretty_generate({\n      id: session.id,\n      created_at: session.created_at.iso8601,\n      updated_at: session.updated_at.iso8601,\n      context: session.context,\n      task_history: session.task_history.map { |entry|\n        {\n          task_id: entry[:task_id],\n          message: entry[:message].to_h,\n          status: entry[:status].to_h,\n          timestamp: entry[:timestamp].iso8601\n        }\n      }\n    })\n  end\n\n  def deserialize_session(data)\n    session = Session.new(data[:id], @ttl)\n    session.instance_variable_set(:@created_at, Time.parse(data[:created_at]))\n    session.instance_variable_set(:@updated_at, Time.parse(data[:updated_at]))\n    session.instance_variable_set(:@context, data[:context])\n\n    task_history = data[:task_history].map do |entry|\n      {\n        task_id: entry[:task_id],\n        message: A2A::Models::Message.from_hash(entry[:message]),\n        status: A2A::Models::TaskStatus.from_hash(entry[:status]),\n        timestamp: Time.parse(entry[:timestamp])\n      }\n    end\n    session.instance_variable_set(:@task_history, task_history)\n\n    session\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#best-practices","title":"Best Practices","text":""},{"location":"advanced/conversations/#1-always-include-session-id-for-multi-turn","title":"1. Always Include Session ID for Multi-Turn","text":"<pre><code>def send_followup_message(text, previous_task)\n  # Reuse session ID from previous task\n  send_task(\n    task_id: \"task-#{SecureRandom.uuid}\",\n    message: A2A::Models::Message.text(role: 'user', text: text),\n    session_id: previous_task.session_id  # Important!\n  )\nend\n</code></pre>"},{"location":"advanced/conversations/#2-set-appropriate-session-ttl","title":"2. Set Appropriate Session TTL","text":"<pre><code># Short conversations (chatbot)\nshort_session_manager = SessionManager.new(ttl: 900) # 15 minutes\n\n# Long conversations (research assistant)\nlong_session_manager = SessionManager.new(ttl: 7200) # 2 hours\n\n# Extended workflows (multi-day projects)\nextended_session_manager = SessionManager.new(ttl: 86400) # 24 hours\n</code></pre>"},{"location":"advanced/conversations/#3-clean-up-context","title":"3. Clean Up Context","text":"<pre><code>class Session\n  def cleanup_old_context(max_age: 3600)\n    @context.delete_if do |key, value|\n      if value.is_a?(Hash) &amp;&amp; value[:timestamp]\n        Time.now - value[:timestamp] &gt; max_age\n      else\n        false\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#4-limit-history-size","title":"4. Limit History Size","text":"<pre><code>class Session\n  MAX_HISTORY = 50\n\n  def add_task(task, message)\n    @task_history &lt;&lt; {\n      task_id: task.id,\n      message: message,\n      status: task.status,\n      timestamp: Time.now\n    }\n\n    # Keep only recent history\n    @task_history = @task_history.last(MAX_HISTORY) if @task_history.size &gt; MAX_HISTORY\n\n    touch\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#5-handle-session-expiration-gracefully","title":"5. Handle Session Expiration Gracefully","text":"<pre><code>def get_session_safe(session_id)\n  session = @session_manager.get_session(session_id)\n\n  if session.expired?\n    debug_me \"Session #{session_id} expired, creating new one\"\n    @session_manager.remove_session(session_id)\n    session = @session_manager.get_session(session_id)\n  end\n\n  session\nend\n</code></pre>"},{"location":"advanced/conversations/#complete-examples","title":"Complete Examples","text":""},{"location":"advanced/conversations/#multi-step-form-workflow","title":"Multi-Step Form Workflow","text":"<pre><code>class FormWorkflowServer &lt; A2AConversationalServer\n  FORM_FIELDS = %i[name email phone_number address preferences]\n\n  def process_multi_turn(task, message, session, user_text)\n    # Check form completion status\n    completed_fields = session.get_context(:completed_fields) || []\n    current_field = session.get_context(:current_field)\n\n    if current_field\n      # Save provided value\n      session.update_context(current_field, user_text)\n      completed_fields &lt;&lt; current_field\n      session.update_context(:completed_fields, completed_fields)\n    end\n\n    # Find next required field\n    next_field = FORM_FIELDS.find { |f| !completed_fields.include?(f) }\n\n    if next_field\n      # Ask for next field\n      session.update_context(:current_field, next_field)\n\n      prompt = generate_field_prompt(next_field)\n\n      A2A::Models::Task.new(\n        id: task.id,\n        session_id: task.session_id,\n        status: {\n          state: 'input-required',\n          message: A2A::Models::Message.text(role: 'agent', text: prompt),\n          timestamp: Time.now.utc.iso8601\n        },\n        metadata: {\n          progress: \"#{completed_fields.size}/#{FORM_FIELDS.size}\"\n        }\n      )\n    else\n      # Form complete\n      form_data = FORM_FIELDS.each_with_object({}) do |field, hash|\n        hash[field] = session.get_context(field)\n      end\n\n      artifact = A2A::Models::Artifact.new(\n        name: \"Completed Form\",\n        parts: [\n          A2A::Models::DataPart.new(data: form_data)\n        ]\n      )\n\n      A2A::Models::Task.new(\n        id: task.id,\n        session_id: task.session_id,\n        status: {\n          state: 'completed',\n          message: A2A::Models::Message.text(\n            role: 'agent',\n            text: \"Thank you! Your form has been completed.\"\n          ),\n          timestamp: Time.now.utc.iso8601\n        },\n        artifacts: [artifact]\n      )\n    end\n  end\n\n  private\n\n  def generate_field_prompt(field)\n    prompts = {\n      name: \"What is your full name?\",\n      email: \"What is your email address?\",\n      phone_number: \"What is your phone number?\",\n      address: \"What is your mailing address?\",\n      preferences: \"What are your preferences?\"\n    }\n\n    prompts[field]\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#interactive-tutorial-agent","title":"Interactive Tutorial Agent","text":"<pre><code>class TutorialAgent\n  def initialize(session_manager)\n    @session_manager = session_manager\n    @lessons = load_lessons\n  end\n\n  def process_message(task, message, session)\n    user_text = extract_text(message)\n\n    # Check lesson progress\n    current_lesson = session.get_context(:current_lesson) || 0\n    lesson_step = session.get_context(:lesson_step) || 0\n\n    lesson = @lessons[current_lesson]\n\n    if user_text.downcase.include?('next')\n      # Move to next step\n      lesson_step += 1\n\n      if lesson_step &gt;= lesson[:steps].size\n        # Lesson complete\n        current_lesson += 1\n        lesson_step = 0\n\n        if current_lesson &gt;= @lessons.size\n          # Tutorial complete!\n          return create_completion_task(task, session)\n        end\n\n        lesson = @lessons[current_lesson]\n      end\n\n      session.update_context(:current_lesson, current_lesson)\n      session.update_context(:lesson_step, lesson_step)\n\n      create_lesson_task(task, session, lesson, lesson_step)\n\n    elsif user_text.downcase.include?('help')\n      # Provide hint\n      create_hint_task(task, lesson, lesson_step)\n\n    elsif user_text.downcase.include?('repeat')\n      # Repeat current step\n      create_lesson_task(task, session, lesson, lesson_step)\n\n    else\n      # Validate answer\n      if validate_answer(user_text, lesson, lesson_step)\n        session.update_context(:lesson_step, lesson_step + 1)\n        create_correct_answer_task(task, session, lesson)\n      else\n        create_incorrect_answer_task(task, lesson, lesson_step)\n      end\n    end\n  end\n\n  private\n\n  def load_lessons\n    [\n      {\n        title: \"Introduction to A2A\",\n        steps: [\n          \"What does A2A stand for? (type your answer)\",\n          \"Name one capability an agent can have\",\n          \"What is a Task in A2A?\"\n        ],\n        answers: [\n          [\"agent2agent\", \"agent to agent\"],\n          [\"streaming\", \"push notifications\", \"state transition history\"],\n          [\"unit of work\", \"central unit\"]\n        ]\n      }\n      # ... more lessons\n    ]\n  end\n\n  def validate_answer(text, lesson, step)\n    correct_answers = lesson[:answers][step] || []\n    correct_answers.any? { |answer| text.downcase.include?(answer.downcase) }\n  end\n\n  def create_lesson_task(task, session, lesson, step)\n    progress = \"Lesson #{session.get_context(:current_lesson) + 1}/#{@lessons.size}, Step #{step + 1}/#{lesson[:steps].size}\"\n\n    A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: {\n        state: 'input-required',\n        message: A2A::Models::Message.text(\n          role: 'agent',\n          text: \"#{progress}\\n\\n#{lesson[:steps][step]}\\n\\n(type 'help' for a hint, 'next' to skip)\"\n        ),\n        timestamp: Time.now.utc.iso8601\n      }\n    )\n  end\n\n  def create_completion_task(task, session)\n    A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: {\n        state: 'completed',\n        message: A2A::Models::Message.text(\n          role: 'agent',\n          text: \"Congratulations! You've completed the A2A tutorial!\"\n        ),\n        timestamp: Time.now.utc.iso8601\n      },\n      artifacts: [\n        A2A::Models::Artifact.new(\n          name: \"Tutorial Certificate\",\n          parts: [\n            A2A::Models::DataPart.new(\n              data: {\n                session_id: session.id,\n                completed_at: Time.now.iso8601,\n                lessons_completed: @lessons.size\n              }\n            )\n          ]\n        )\n      ]\n    )\n  end\n\n  # Additional helper methods...\nend\n</code></pre>"},{"location":"advanced/conversations/#testing-strategies","title":"Testing Strategies","text":""},{"location":"advanced/conversations/#unit-testing-sessions","title":"Unit Testing Sessions","text":"<pre><code>RSpec.describe SessionManager do\n  let(:manager) { SessionManager.new(ttl: 60) }\n\n  describe '#get_session' do\n    it 'creates new session if not exists' do\n      session = manager.get_session('session-1')\n\n      expect(session).to be_a(Session)\n      expect(session.id).to eq('session-1')\n    end\n\n    it 'returns existing session' do\n      session1 = manager.get_session('session-1')\n      session2 = manager.get_session('session-1')\n\n      expect(session1).to eq(session2)\n    end\n  end\n\n  describe 'session expiration' do\n    it 'removes expired sessions' do\n      session = manager.get_session('session-1')\n\n      # Simulate time passage\n      allow(Time).to receive(:now).and_return(Time.now + 120)\n\n      expect(session.expired?).to be true\n      expect(manager.session_exists?('session-1')).to be false\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#integration-testing-conversations","title":"Integration Testing Conversations","text":"<pre><code>RSpec.describe 'Multi-turn conversation' do\n  let(:client) { A2AConversationalClient.new('https://api.test/a2a') }\n\n  it 'maintains context across turns' do\n    stub_requests\n\n    session = client.start_conversation\n\n    # Turn 1\n    response1 = client.send_message(\"Hello\", session: session)\n    expect(response1.session_id).to eq(session.id)\n\n    # Turn 2 - same session\n    response2 = client.send_message(\"Tell me more\", session: session)\n    expect(response2.session_id).to eq(session.id)\n\n    expect(session.turn_count).to eq(2)\n  end\n\n  def stub_requests\n    stub_request(:post, 'https://api.test/a2a')\n      .to_return(status: 200, body: mock_response.to_json)\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/conversations/#issue-session-not-found","title":"Issue: Session Not Found","text":"<p>Solution: Check session expiration and implement graceful degradation</p> <pre><code>def handle_send_task(params)\n  task = A2A::Models::Task.from_hash(params['task'])\n\n  if task.session_id &amp;&amp; !@session_manager.session_exists?(task.session_id)\n    debug_me \"Session #{task.session_id} not found or expired\"\n\n    # Option 1: Create new session with same ID\n    session = @session_manager.get_session(task.session_id)\n\n    # Option 2: Return error\n    # raise A2A::InvalidParamsError, \"Session expired or not found\"\n\n    # Option 3: Process without context\n    # session = nil\n  end\n\n  # Process normally\nend\n</code></pre>"},{"location":"advanced/conversations/#issue-context-growing-too-large","title":"Issue: Context Growing Too Large","text":"<p>Solution: Implement context pruning</p> <pre><code>class Session\n  MAX_CONTEXT_SIZE = 1000 # bytes\n\n  def update_context(key, value)\n    @context[key] = value\n\n    # Check size\n    prune_context_if_needed\n    touch\n  end\n\n  private\n\n  def prune_context_if_needed\n    size = estimate_context_size\n\n    if size &gt; MAX_CONTEXT_SIZE\n      # Remove oldest non-critical context\n      prune_old_context\n    end\n  end\n\n  def estimate_context_size\n    @context.to_json.bytesize\n  end\n\n  def prune_old_context\n    # Keep only essential context\n    essential_keys = [:current_state, :user_id, :topic]\n    @context = @context.slice(*essential_keys)\n  end\nend\n</code></pre>"},{"location":"advanced/conversations/#related-documentation","title":"Related Documentation","text":"<ul> <li>Streaming - Using sessions with streaming</li> <li>Push Notifications - Async updates in conversations</li> <li>Task Lifecycle - Understanding task states</li> <li>Messages - Message structure and roles</li> </ul>"},{"location":"advanced/conversations/#further-reading","title":"Further Reading","text":"<ul> <li>A2A Protocol Specification</li> <li>Conversation Design Best Practices</li> <li>Session Management Patterns</li> </ul>"},{"location":"advanced/push-notifications/","title":"Push Notifications with Webhooks","text":"<p>Comprehensive guide to implementing asynchronous task updates using webhook-based push notifications in the A2A protocol.</p>"},{"location":"advanced/push-notifications/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>When to Use Push Notifications</li> <li>Architecture</li> <li>Protocol Details</li> <li>Implementation Guide</li> <li>Server-Side Implementation</li> <li>Client-Side Webhook Receiver</li> <li>Security</li> <li>Retry Logic</li> <li>Best Practices</li> <li>Complete Examples</li> <li>Testing Strategies</li> <li>Troubleshooting</li> </ul>"},{"location":"advanced/push-notifications/#overview","title":"Overview","text":"<p>Push notifications enable agents to proactively send task updates to clients via HTTP webhooks. Instead of clients polling for updates or maintaining an open SSE connection, the server pushes updates to a client-specified webhook URL whenever task state changes.</p>"},{"location":"advanced/push-notifications/#push-notifications-vs-streaming","title":"Push Notifications vs Streaming","text":"Feature Push Notifications Streaming (SSE) Connection Stateless webhooks Persistent connection Use Case Long-running background tasks Real-time interactive tasks Reliability Retry logic required Automatic reconnection Scalability Highly scalable Limited by concurrent connections Latency Slightly higher Minimal Complexity Higher (webhook security) Lower"},{"location":"advanced/push-notifications/#push-notification-capability","title":"Push Notification Capability","text":"<p>Agents indicate push notification support in their AgentCard:</p> <pre><code>require 'a2a'\n\nagent_card = A2A::Models::AgentCard.new(\n  name: \"Background Processing Agent\",\n  url: \"https://api.example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: false,\n    push_notifications: true,  # Indicates webhook support\n    state_transition_history: false\n  }\n)\n</code></pre>"},{"location":"advanced/push-notifications/#when-to-use-push-notifications","title":"When to Use Push Notifications","text":"<p>Push notifications are ideal for:</p> <ol> <li>Long-Running Background Tasks: Tasks that take minutes to hours</li> <li>Batch Processing: Processing large datasets asynchronously</li> <li>Scheduled Jobs: Tasks that run at specific times</li> <li>Resource-Intensive Operations: Video encoding, large file processing</li> <li>Distributed Systems: When client may not be continuously connected</li> <li>Mobile/Offline Clients: Clients that aren't always online</li> </ol> <p>Don't use push notifications for: - Quick synchronous tasks (use regular <code>tasks/send</code>) - Real-time interactive conversations (use streaming) - When immediate response is required</p>"},{"location":"advanced/push-notifications/#architecture","title":"Architecture","text":"<pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 900 700\" style=\"background:transparent\"&gt;\n  &lt;!-- Client --&gt;\n  &lt;rect x=\"50\" y=\"50\" width=\"150\" height=\"80\" fill=\"#1e3a8a\" stroke=\"#3b82f6\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"125\" y=\"95\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;A2A Client&lt;/text&gt;\n\n  &lt;!-- Webhook Endpoint --&gt;\n  &lt;rect x=\"50\" y=\"250\" width=\"150\" height=\"80\" fill=\"#7c3aed\" stroke=\"#a78bfa\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"125\" y=\"285\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"14\" font-weight=\"bold\"&gt;Client Webhook&lt;/text&gt;\n  &lt;text x=\"125\" y=\"305\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;Receiver&lt;/text&gt;\n\n  &lt;!-- Server --&gt;\n  &lt;rect x=\"700\" y=\"50\" width=\"150\" height=\"80\" fill=\"#1e3a8a\" stroke=\"#3b82f6\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"775\" y=\"95\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;A2A Server&lt;/text&gt;\n\n  &lt;!-- Agent --&gt;\n  &lt;rect x=\"700\" y=\"550\" width=\"150\" height=\"80\" fill=\"#064e3b\" stroke=\"#10b981\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"775\" y=\"595\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;Agent Core&lt;/text&gt;\n\n  &lt;!-- Notification Queue --&gt;\n  &lt;rect x=\"700\" y=\"250\" width=\"150\" height=\"80\" fill=\"#b45309\" stroke=\"#f59e0b\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"775\" y=\"285\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"14\" font-weight=\"bold\"&gt;Notification&lt;/text&gt;\n  &lt;text x=\"775\" y=\"305\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"14\" font-weight=\"bold\"&gt;Queue&lt;/text&gt;\n\n  &lt;!-- Step 1: Send Task --&gt;\n  &lt;line x1=\"200\" y1=\"90\" x2=\"690\" y2=\"90\" stroke=\"#3b82f6\" stroke-width=\"2\" marker-end=\"url(#arrowblue)\"/&gt;\n  &lt;text x=\"445\" y=\"75\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;1. POST tasks/send&lt;/text&gt;\n\n  &lt;!-- Step 2: Set Push Config --&gt;\n  &lt;line x1=\"200\" y1=\"110\" x2=\"690\" y2=\"110\" stroke=\"#a78bfa\" stroke-width=\"2\" marker-end=\"url(#arrowpurple)\"/&gt;\n  &lt;text x=\"445\" y=\"125\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;2. tasks/pushNotification/set&lt;/text&gt;\n\n  &lt;!-- Step 3: Immediate Response --&gt;\n  &lt;line x1=\"690\" y1=\"140\" x2=\"210\" y2=\"140\" stroke=\"#10b981\" stroke-width=\"2\" stroke-dasharray=\"5,5\"/&gt;\n  &lt;text x=\"445\" y=\"155\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;3. Response (task accepted)&lt;/text&gt;\n\n  &lt;!-- Step 4: Processing --&gt;\n  &lt;line x1=\"775\" y1=\"130\" x2=\"775\" y2=\"540\" stroke=\"#f59e0b\" stroke-width=\"2\" marker-end=\"url(#arroworange)\"/&gt;\n  &lt;text x=\"805\" y=\"335\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;4. Process&lt;/text&gt;\n\n  &lt;!-- Step 5: Queue Updates --&gt;\n  &lt;line x1=\"775\" y1=\"330\" x2=\"775\" y2=\"250\" stroke=\"#f59e0b\" stroke-width=\"2\" marker-end=\"url(#arroworange)\" stroke-dasharray=\"5,5\"/&gt;\n  &lt;text x=\"805\" y=\"290\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;5. Enqueue&lt;/text&gt;\n\n  &lt;!-- Step 6: Push Update --&gt;\n  &lt;line x1=\"690\" y1=\"290\" x2=\"210\" y2=\"290\" stroke=\"#ef4444\" stroke-width=\"3\" marker-end=\"url(#arrowred)\"/&gt;\n  &lt;text x=\"445\" y=\"275\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;6. POST webhook (status update)&lt;/text&gt;\n\n  &lt;!-- Step 7: Another Update --&gt;\n  &lt;line x1=\"690\" y1=\"315\" x2=\"210\" y2=\"315\" stroke=\"#ef4444\" stroke-width=\"3\" marker-end=\"url(#arrowred)\"/&gt;\n  &lt;text x=\"445\" y=\"340\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;7. POST webhook (artifact update)&lt;/text&gt;\n\n  &lt;!-- Step 8: Completion --&gt;\n  &lt;line x1=\"690\" y1=\"350\" x2=\"210\" y2=\"350\" stroke=\"#ef4444\" stroke-width=\"3\" marker-end=\"url(#arrowred)\"/&gt;\n  &lt;text x=\"445\" y=\"365\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;8. POST webhook (completed)&lt;/text&gt;\n\n  &lt;!-- Client queries final state --&gt;\n  &lt;line x1=\"200\" y1=\"400\" x2=\"690\" y2=\"400\" stroke=\"#3b82f6\" stroke-width=\"2\" stroke-dasharray=\"5,5\" marker-end=\"url(#arrowblue)\"/&gt;\n  &lt;text x=\"445\" y=\"415\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"11\"&gt;9. tasks/get (optional)&lt;/text&gt;\n\n  &lt;!-- Arrow markers --&gt;\n  &lt;defs&gt;\n    &lt;marker id=\"arrowblue\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#3b82f6\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowgreen\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#10b981\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arroworange\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#f59e0b\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowpurple\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#a78bfa\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowred\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#ef4444\"/&gt;\n    &lt;/marker&gt;\n  &lt;/defs&gt;\n&lt;/svg&gt;\n</code></pre>"},{"location":"advanced/push-notifications/#flow-description","title":"Flow Description","text":"<ol> <li>Client Initiates: Sends <code>tasks/send</code> to submit task</li> <li>Configure Webhook: Calls <code>tasks/pushNotification/set</code> with webhook URL</li> <li>Immediate Response: Server returns accepted task</li> <li>Async Processing: Agent processes task in background</li> <li>Queue Updates: Server queues notification events 6-8. Push Updates: Server POSTs updates to client webhook</li> <li>Optional Query: Client can query final state with <code>tasks/get</code></li> </ol>"},{"location":"advanced/push-notifications/#protocol-details","title":"Protocol Details","text":""},{"location":"advanced/push-notifications/#setting-push-notification-configuration","title":"Setting Push Notification Configuration","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-456\",\n  \"method\": \"tasks/pushNotification/set\",\n  \"params\": {\n    \"taskId\": \"task-123\",\n    \"config\": {\n      \"url\": \"https://client.example.com/webhooks/a2a\",\n      \"token\": \"secret_webhook_token_12345\",\n      \"authentication\": {\n        \"type\": \"bearer\",\n        \"credentials\": {\n          \"token\": \"client_auth_token\"\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"advanced/push-notifications/#push-notification-payload","title":"Push Notification Payload","text":"<p>The server POSTs this to the client's webhook URL:</p> <pre><code>{\n  \"taskId\": \"task-123\",\n  \"event\": {\n    \"type\": \"TaskStatusUpdateEvent\",\n    \"task\": {\n      \"id\": \"task-123\",\n      \"status\": {\n        \"state\": \"working\",\n        \"message\": {\n          \"role\": \"agent\",\n          \"parts\": [\n            { \"text\": \"Processing 50% complete...\" }\n          ]\n        },\n        \"timestamp\": \"2025-10-21T10:30:00Z\"\n      }\n    }\n  }\n}\n</code></pre> <p>Or for artifact updates:</p> <pre><code>{\n  \"taskId\": \"task-123\",\n  \"event\": {\n    \"type\": \"TaskArtifactUpdateEvent\",\n    \"taskId\": \"task-123\",\n    \"artifact\": {\n      \"name\": \"Intermediate Results\",\n      \"parts\": [\n        {\n          \"data\": {\n            \"processed\": 5000,\n            \"total\": 10000\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"advanced/push-notifications/#implementation-guide","title":"Implementation Guide","text":""},{"location":"advanced/push-notifications/#server-side-implementation","title":"Server-Side Implementation","text":""},{"location":"advanced/push-notifications/#push-notification-manager","title":"Push Notification Manager","text":"<pre><code>require 'a2a'\nrequire 'http'\nrequire 'json'\n\nclass PushNotificationManager\n  def initialize\n    @configurations = {} # taskId =&gt; config\n    @retry_queue = Queue.new\n    @worker_thread = start_worker\n  end\n\n  # Store push notification configuration\n  def set_config(task_id, config)\n    validate_config!(config)\n\n    @configurations[task_id] = A2A::Models::PushNotificationConfig.from_hash(config)\n\n    debug_me \"Push notification configured for task #{task_id}\"\n  end\n\n  # Get push notification configuration\n  def get_config(task_id)\n    @configurations[task_id]\n  end\n\n  # Remove configuration when task completes\n  def remove_config(task_id)\n    @configurations.delete(task_id)\n  end\n\n  # Send task status update notification\n  def notify_status_update(task)\n    config = @configurations[task.id]\n    return unless config\n\n    event = {\n      taskId: task.id,\n      event: {\n        type: 'TaskStatusUpdateEvent',\n        task: task.to_h\n      }\n    }\n\n    send_notification(config, event)\n  end\n\n  # Send task artifact update notification\n  def notify_artifact_update(task_id, artifact)\n    config = @configurations[task_id]\n    return unless config\n\n    event = {\n      taskId: task_id,\n      event: {\n        type: 'TaskArtifactUpdateEvent',\n        taskId: task_id,\n        artifact: artifact.to_h\n      }\n    }\n\n    send_notification(config, event)\n  end\n\n  private\n\n  def validate_config!(config)\n    raise ArgumentError, \"URL is required\" unless config[:url] || config['url']\n\n    url = config[:url] || config['url']\n    uri = URI.parse(url)\n\n    raise ArgumentError, \"URL must use HTTPS\" unless uri.scheme == 'https'\n    raise ArgumentError, \"URL must have a host\" unless uri.host\n  rescue URI::InvalidURIError =&gt; e\n    raise ArgumentError, \"Invalid URL: #{e.message}\"\n  end\n\n  def send_notification(config, event, attempt: 1)\n    max_attempts = 5\n\n    begin\n      debug_me \"Sending push notification (attempt #{attempt})\"\n\n      response = build_http_client(config).post(\n        config.url,\n        json: event,\n        headers: build_headers(config)\n      )\n\n      if response.status.success?\n        debug_me \"Push notification delivered successfully\"\n      else\n        handle_failed_delivery(config, event, attempt, response)\n      end\n\n    rescue HTTP::Error, Errno::ECONNREFUSED =&gt; e\n      debug_me \"Push notification failed: #{e.message}\"\n      handle_failed_delivery(config, event, attempt, nil)\n    end\n  end\n\n  def build_http_client(config)\n    HTTP.timeout(\n      connect: 5,\n      write: 10,\n      read: 10\n    )\n  end\n\n  def build_headers(config)\n    headers = {\n      'Content-Type' =&gt; 'application/json',\n      'User-Agent' =&gt; 'A2A-Server/1.0'\n    }\n\n    # Add authentication if configured\n    if config.authentication\n      case config.authentication['type'] || config.authentication[:type]\n      when 'bearer'\n        token = config.authentication.dig('credentials', 'token') ||\n                config.authentication.dig(:credentials, :token)\n        headers['Authorization'] = \"Bearer #{token}\"\n      end\n    end\n\n    # Add webhook verification token\n    if config.token\n      headers['X-Webhook-Token'] = config.token\n    end\n\n    headers\n  end\n\n  def handle_failed_delivery(config, event, attempt, response)\n    max_attempts = 5\n\n    if attempt &lt; max_attempts\n      # Exponential backoff: 2s, 4s, 8s, 16s, 32s\n      delay = 2 ** attempt\n\n      debug_me \"Retrying in #{delay} seconds...\"\n\n      Thread.new do\n        sleep(delay)\n        send_notification(config, event, attempt: attempt + 1)\n      end\n    else\n      debug_me \"Push notification failed after #{max_attempts} attempts\"\n      # Could store in dead letter queue for manual review\n    end\n  end\n\n  def start_worker\n    # Background worker for processing retry queue\n    Thread.new do\n      loop do\n        begin\n          # Process retry queue\n          sleep(1)\n        rescue StandardError =&gt; e\n          debug_me \"Worker error: #{e.message}\"\n        end\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#server-integration","title":"Server Integration","text":"<pre><code>require 'a2a'\n\nclass A2APushServer &lt; A2A::Server::Base\n  def initialize(agent_card)\n    super(agent_card)\n    @push_manager = PushNotificationManager.new\n    @task_store = {} # Simple in-memory store\n  end\n\n  def handle_send_task(params)\n    task = A2A::Models::Task.from_hash(params['task'] || params[:task])\n    message = A2A::Models::Message.from_hash(params['message'] || params[:message])\n\n    # Store task\n    @task_store[task.id] = task\n\n    # Process asynchronously\n    Thread.new do\n      process_task_async(task, message)\n    end\n\n    # Return immediately with submitted state\n    task\n  end\n\n  def handle_set_push_notification(params)\n    task_id = params['taskId'] || params[:taskId]\n    config = params['config'] || params[:config]\n\n    unless @task_store[task_id]\n      raise A2A::TaskNotFoundError, \"Task #{task_id} not found\"\n    end\n\n    @push_manager.set_config(task_id, config)\n\n    # Return success (no specific response defined in spec)\n    nil\n  end\n\n  def handle_get_push_notification(params)\n    task_id = params['taskId'] || params[:taskId]\n\n    unless @task_store[task_id]\n      raise A2A::TaskNotFoundError, \"Task #{task_id} not found\"\n    end\n\n    config = @push_manager.get_config(task_id)\n\n    unless config\n      raise A2A::UnsupportedOperationError, \"No push notification configured for task\"\n    end\n\n    config\n  end\n\n  private\n\n  def process_task_async(task, message)\n    begin\n      # Update to working\n      task = update_task(task, 'working', \"Starting processing...\")\n      @push_manager.notify_status_update(task)\n\n      # Simulate multi-step processing\n      steps = [\n        { progress: 25, message: \"Phase 1: Data collection...\" },\n        { progress: 50, message: \"Phase 2: Analysis...\" },\n        { progress: 75, message: \"Phase 3: Report generation...\" },\n        { progress: 100, message: \"Phase 4: Finalization...\" }\n      ]\n\n      steps.each do |step|\n        sleep(5) # Simulate work\n\n        task = update_task(task, 'working', step[:message])\n        @push_manager.notify_status_update(task)\n\n        # Send intermediate artifact at 50%\n        if step[:progress] == 50\n          artifact = create_intermediate_artifact(task.id, step[:progress])\n          @push_manager.notify_artifact_update(task.id, artifact)\n        end\n      end\n\n      # Generate final artifact\n      final_artifact = create_final_artifact(task.id)\n\n      # Complete task\n      task = A2A::Models::Task.new(\n        id: task.id,\n        session_id: task.session_id,\n        status: {\n          state: 'completed',\n          message: A2A::Models::Message.text(\n            role: 'agent',\n            text: \"Processing complete\"\n          ),\n          timestamp: Time.now.utc.iso8601\n        },\n        artifacts: [final_artifact],\n        metadata: task.metadata\n      )\n\n      @task_store[task.id] = task\n      @push_manager.notify_status_update(task)\n\n      # Clean up configuration\n      @push_manager.remove_config(task.id)\n\n    rescue StandardError =&gt; e\n      debug_me \"Task processing error: #{e.message}\"\n\n      task = update_task(task, 'failed', e.message)\n      @task_store[task.id] = task\n      @push_manager.notify_status_update(task)\n      @push_manager.remove_config(task.id)\n    end\n  end\n\n  def update_task(task, state, message_text)\n    updated = A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: {\n        state: state,\n        message: A2A::Models::Message.text(\n          role: 'agent',\n          text: message_text\n        ),\n        timestamp: Time.now.utc.iso8601\n      },\n      artifacts: task.artifacts,\n      metadata: task.metadata\n    )\n\n    @task_store[task.id] = updated\n    updated\n  end\n\n  def create_intermediate_artifact(task_id, progress)\n    A2A::Models::Artifact.new(\n      name: \"Progress Report\",\n      parts: [\n        A2A::Models::DataPart.new(\n          data: {\n            progress: progress,\n            status: \"In Progress\",\n            timestamp: Time.now.utc.iso8601\n          }\n        )\n      ]\n    )\n  end\n\n  def create_final_artifact(task_id)\n    A2A::Models::Artifact.new(\n      name: \"Final Results\",\n      description: \"Complete processing results\",\n      parts: [\n        A2A::Models::TextPart.new(\n          text: \"Processing completed successfully\"\n        ),\n        A2A::Models::DataPart.new(\n          data: {\n            total_processed: 10000,\n            success_rate: 0.98,\n            completion_time: Time.now.utc.iso8601\n          }\n        )\n      ],\n      metadata: {\n        task_id: task_id,\n        version: \"1.0\"\n      }\n    )\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#client-side-webhook-receiver","title":"Client-Side Webhook Receiver","text":""},{"location":"advanced/push-notifications/#sinatra-webhook-endpoint","title":"Sinatra Webhook Endpoint","text":"<pre><code>require 'sinatra'\nrequire 'json'\nrequire 'securerandom'\n\n# Webhook verification token\nWEBHOOK_TOKEN = ENV['WEBHOOK_TOKEN'] || SecureRandom.hex(32)\n\n# Store to track task updates\ntask_updates = {}\n\n# Webhook endpoint\npost '/webhooks/a2a' do\n  request.body.rewind\n  payload_body = request.body.read\n\n  # Verify webhook token\n  provided_token = request.env['HTTP_X_WEBHOOK_TOKEN']\n\n  unless provided_token == WEBHOOK_TOKEN\n    halt 401, JSON.generate({ error: 'Invalid webhook token' })\n  end\n\n  # Parse payload\n  begin\n    payload = JSON.parse(payload_body, symbolize_names: true)\n  rescue JSON::ParserError\n    halt 400, JSON.generate({ error: 'Invalid JSON' })\n  end\n\n  # Extract task ID and event\n  task_id = payload[:taskId]\n  event = payload[:event]\n  event_type = event[:type]\n\n  debug_me \"Received webhook: #{event_type} for task #{task_id}\"\n\n  # Process event\n  case event_type\n  when 'TaskStatusUpdateEvent'\n    handle_status_update(task_id, event[:task], task_updates)\n\n  when 'TaskArtifactUpdateEvent'\n    handle_artifact_update(task_id, event[:artifact], task_updates)\n\n  else\n    debug_me \"Unknown event type: #{event_type}\"\n  end\n\n  # Return 200 OK to acknowledge receipt\n  status 200\n  content_type :json\n  JSON.generate({ received: true })\nend\n\ndef handle_status_update(task_id, task_data, store)\n  task = A2A::Models::Task.from_hash(task_data)\n\n  # Store update\n  store[task_id] ||= { task: nil, artifacts: [] }\n  store[task_id][:task] = task\n\n  # Log status\n  state = task.status.state.value\n  message = task.status.message&amp;.parts&amp;.first&amp;.text\n\n  debug_me \"Task #{task_id}: #{state}\"\n  debug_me \"  Message: #{message}\" if message\n\n  # Handle terminal states\n  if task.status.state.terminal?\n    debug_me \"Task #{task_id} reached terminal state: #{state}\"\n\n    # Could trigger additional processing here\n    case state\n    when 'completed'\n      handle_task_completion(task_id, store)\n    when 'failed'\n      handle_task_failure(task_id, store)\n    end\n  end\nend\n\ndef handle_artifact_update(task_id, artifact_data, store)\n  artifact = A2A::Models::Artifact.from_hash(artifact_data)\n\n  # Store artifact\n  store[task_id] ||= { task: nil, artifacts: [] }\n  store[task_id][:artifacts] &lt;&lt; artifact\n\n  debug_me \"Task #{task_id}: Received artifact '#{artifact.name}'\"\n\n  # Process artifact content\n  artifact.parts.each do |part|\n    case part\n    when A2A::Models::TextPart\n      debug_me \"  Text: #{part.text[0..100]}...\"\n\n    when A2A::Models::DataPart\n      debug_me \"  Data: #{part.data.keys.join(', ')}\"\n\n    when A2A::Models::FilePart\n      if part.file[:bytes]\n        save_artifact_file(task_id, artifact.name, part.file[:bytes])\n      end\n    end\n  end\nend\n\ndef handle_task_completion(task_id, store)\n  debug_me \"Processing completed task #{task_id}\"\n\n  task_data = store[task_id]\n  task = task_data[:task]\n  artifacts = task_data[:artifacts]\n\n  debug_me \"  Total artifacts: #{artifacts.size}\"\n\n  # Process final results\n  # ... custom logic here ...\nend\n\ndef handle_task_failure(task_id, store)\n  debug_me \"Processing failed task #{task_id}\"\n\n  task = store[task_id][:task]\n  error_message = task.status.message&amp;.parts&amp;.first&amp;.text\n\n  debug_me \"  Error: #{error_message}\"\n\n  # Handle failure\n  # ... custom logic here ...\nend\n\ndef save_artifact_file(task_id, artifact_name, base64_bytes)\n  filename = \"downloads/#{task_id}/#{artifact_name.gsub(/\\s+/, '_')}\"\n  FileUtils.mkdir_p(File.dirname(filename))\n\n  File.write(filename, Base64.decode64(base64_bytes))\n  debug_me \"  Saved file: #{filename}\"\nend\n</code></pre>"},{"location":"advanced/push-notifications/#client-implementation","title":"Client Implementation","text":"<pre><code>require 'a2a'\nrequire 'http'\nrequire 'json'\n\nclass A2APushClient &lt; A2A::Client::Base\n  def initialize(agent_url, webhook_url, webhook_token)\n    super(agent_url)\n    @webhook_url = webhook_url\n    @webhook_token = webhook_token\n    @http_client = HTTP.timeout(connect: 5, write: 10, read: 10)\n  end\n\n  def send_task_with_push(task_id:, message:, session_id: nil)\n    # Step 1: Send task\n    task = send_task(\n      task_id: task_id,\n      message: message,\n      session_id: session_id\n    )\n\n    # Step 2: Configure push notifications\n    set_push_notification(\n      task_id: task_id,\n      config: build_push_config\n    )\n\n    debug_me \"Task #{task_id} submitted with push notifications\"\n    task\n  end\n\n  def send_task(task_id:, message:, session_id: nil)\n    task = A2A::Models::Task.new(\n      id: task_id,\n      session_id: session_id,\n      status: {\n        state: 'submitted',\n        timestamp: Time.now.utc.iso8601\n      }\n    )\n\n    request = {\n      jsonrpc: \"2.0\",\n      id: task_id,\n      method: \"tasks/send\",\n      params: {\n        task: task.to_h,\n        message: message.to_h\n      }\n    }\n\n    response = @http_client.post(\n      agent_url,\n      json: request,\n      headers: { 'Content-Type' =&gt; 'application/json' }\n    )\n\n    unless response.status.success?\n      raise A2A::InternalError, \"HTTP #{response.status}: #{response.body}\"\n    end\n\n    result = JSON.parse(response.body, symbolize_names: true)\n    A2A::Models::Task.from_hash(result[:result])\n  end\n\n  def set_push_notification(task_id:, config:)\n    request = {\n      jsonrpc: \"2.0\",\n      id: SecureRandom.uuid,\n      method: \"tasks/pushNotification/set\",\n      params: {\n        taskId: task_id,\n        config: config.to_h\n      }\n    }\n\n    response = @http_client.post(\n      agent_url,\n      json: request,\n      headers: { 'Content-Type' =&gt; 'application/json' }\n    )\n\n    unless response.status.success?\n      raise A2A::InternalError, \"Failed to set push notification: #{response.body}\"\n    end\n\n    debug_me \"Push notification configured for task #{task_id}\"\n  end\n\n  def get_push_notification(task_id:)\n    request = {\n      jsonrpc: \"2.0\",\n      id: SecureRandom.uuid,\n      method: \"tasks/pushNotification/get\",\n      params: {\n        taskId: task_id\n      }\n    }\n\n    response = @http_client.post(\n      agent_url,\n      json: request,\n      headers: { 'Content-Type' =&gt; 'application/json' }\n    )\n\n    unless response.status.success?\n      raise A2A::InternalError, \"Failed to get push notification: #{response.body}\"\n    end\n\n    result = JSON.parse(response.body, symbolize_names: true)\n    A2A::Models::PushNotificationConfig.from_hash(result[:result])\n  end\n\n  private\n\n  def build_push_config\n    A2A::Models::PushNotificationConfig.new(\n      url: @webhook_url,\n      token: @webhook_token,\n      authentication: nil # Add if needed\n    )\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#security","title":"Security","text":""},{"location":"advanced/push-notifications/#webhook-token-verification","title":"Webhook Token Verification","text":"<p>Always verify webhook requests:</p> <pre><code>def verify_webhook_token(request)\n  provided_token = request.env['HTTP_X_WEBHOOK_TOKEN']\n  expected_token = ENV['WEBHOOK_TOKEN']\n\n  unless provided_token &amp;&amp; provided_token == expected_token\n    halt 401, JSON.generate({ error: 'Unauthorized' })\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#https-only","title":"HTTPS Only","text":"<pre><code>def validate_webhook_url(url)\n  uri = URI.parse(url)\n\n  unless uri.scheme == 'https'\n    raise ArgumentError, \"Webhook URL must use HTTPS\"\n  end\n\n  unless uri.host\n    raise ArgumentError, \"Webhook URL must have a valid host\"\n  end\nrescue URI::InvalidURIError =&gt; e\n  raise ArgumentError, \"Invalid webhook URL: #{e.message}\"\nend\n</code></pre>"},{"location":"advanced/push-notifications/#request-signing","title":"Request Signing","text":"<p>For enhanced security, sign webhook payloads:</p> <pre><code>require 'openssl'\n\nclass SignedWebhookManager &lt; PushNotificationManager\n  def initialize(signing_secret)\n    super()\n    @signing_secret = signing_secret\n  end\n\n  private\n\n  def send_notification(config, event, attempt: 1)\n    payload = JSON.generate(event)\n    signature = generate_signature(payload)\n\n    headers = build_headers(config).merge({\n      'X-Webhook-Signature' =&gt; signature,\n      'X-Webhook-Timestamp' =&gt; Time.now.to_i.to_s\n    })\n\n    response = HTTP.headers(headers).post(config.url, body: payload)\n\n    # ... handle response ...\n  end\n\n  def generate_signature(payload)\n    OpenSSL::HMAC.hexdigest(\n      OpenSSL::Digest.new('sha256'),\n      @signing_secret,\n      payload\n    )\n  end\nend\n\n# Client verification\ndef verify_webhook_signature(request, signing_secret)\n  payload = request.body.read\n  request.body.rewind\n\n  provided_signature = request.env['HTTP_X_WEBHOOK_SIGNATURE']\n  timestamp = request.env['HTTP_X_WEBHOOK_TIMESTAMP']\n\n  # Prevent replay attacks (5 minute window)\n  if timestamp.to_i &lt; Time.now.to_i - 300\n    halt 401, JSON.generate({ error: 'Webhook expired' })\n  end\n\n  expected_signature = OpenSSL::HMAC.hexdigest(\n    OpenSSL::Digest.new('sha256'),\n    signing_secret,\n    payload\n  )\n\n  unless secure_compare(provided_signature, expected_signature)\n    halt 401, JSON.generate({ error: 'Invalid signature' })\n  end\nend\n\ndef secure_compare(a, b)\n  return false unless a.bytesize == b.bytesize\n\n  l = a.unpack(\"C#{a.bytesize}\")\n  res = 0\n  b.each_byte { |byte| res |= byte ^ l.shift }\n  res == 0\nend\n</code></pre>"},{"location":"advanced/push-notifications/#retry-logic","title":"Retry Logic","text":""},{"location":"advanced/push-notifications/#exponential-backoff","title":"Exponential Backoff","text":"<pre><code>def send_with_retry(config, event, attempt: 1)\n  max_attempts = 5\n  base_delay = 2 # seconds\n\n  begin\n    send_notification(config, event)\n\n  rescue HTTP::Error =&gt; e\n    if attempt &lt; max_attempts\n      delay = base_delay ** attempt # 2, 4, 8, 16, 32 seconds\n      debug_me \"Retry #{attempt}/#{max_attempts} in #{delay}s\"\n\n      sleep(delay)\n      send_with_retry(config, event, attempt: attempt + 1)\n    else\n      debug_me \"Failed after #{max_attempts} attempts\"\n      store_in_dead_letter_queue(config, event)\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>class WebhookCircuitBreaker\n  def initialize(failure_threshold: 5, timeout: 60)\n    @failure_threshold = failure_threshold\n    @timeout = timeout\n    @failures = Hash.new(0)\n    @opened_at = {}\n  end\n\n  def call(url)\n    if circuit_open?(url)\n      raise CircuitOpenError, \"Circuit breaker open for #{url}\"\n    end\n\n    begin\n      yield\n      reset_failures(url)\n    rescue StandardError =&gt; e\n      record_failure(url)\n      raise e\n    end\n  end\n\n  private\n\n  def circuit_open?(url)\n    return false unless @opened_at[url]\n\n    # Check if timeout has passed\n    if Time.now - @opened_at[url] &gt; @timeout\n      reset_failures(url)\n      false\n    else\n      true\n    end\n  end\n\n  def record_failure(url)\n    @failures[url] += 1\n\n    if @failures[url] &gt;= @failure_threshold\n      @opened_at[url] = Time.now\n      debug_me \"Circuit breaker opened for #{url}\"\n    end\n  end\n\n  def reset_failures(url)\n    @failures.delete(url)\n    @opened_at.delete(url)\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#best-practices","title":"Best Practices","text":""},{"location":"advanced/push-notifications/#1-always-return-200-ok-quickly","title":"1. Always Return 200 OK Quickly","text":"<pre><code>post '/webhooks/a2a' do\n  # Verify token\n  verify_webhook_token(request)\n\n  # Parse payload\n  payload = JSON.parse(request.body.read, symbolize_names: true)\n\n  # Process asynchronously\n  Thread.new do\n    process_webhook_payload(payload)\n  end\n\n  # Return immediately\n  status 200\n  JSON.generate({ received: true })\nend\n</code></pre>"},{"location":"advanced/push-notifications/#2-implement-idempotency","title":"2. Implement Idempotency","text":"<pre><code>class WebhookReceiver\n  def initialize\n    @processed_events = Set.new\n  end\n\n  def handle_webhook(payload)\n    event_id = generate_event_id(payload)\n\n    if @processed_events.include?(event_id)\n      debug_me \"Duplicate event #{event_id}, skipping\"\n      return\n    end\n\n    @processed_events.add(event_id)\n\n    # Process event\n    process_event(payload)\n  end\n\n  private\n\n  def generate_event_id(payload)\n    # Combine task ID and event type and timestamp\n    \"#{payload[:taskId]}-#{payload[:event][:type]}-#{payload[:event][:task][:status][:timestamp]}\"\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#3-store-webhook-history","title":"3. Store Webhook History","text":"<pre><code>class WebhookLogger\n  def log_webhook(payload, status)\n    DB[:webhook_logs].insert(\n      task_id: payload[:taskId],\n      event_type: payload[:event][:type],\n      payload: JSON.generate(payload),\n      status: status,\n      received_at: Time.now\n    )\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#4-monitor-webhook-health","title":"4. Monitor Webhook Health","text":"<pre><code>class WebhookMonitor\n  def initialize\n    @metrics = {\n      received: 0,\n      processed: 0,\n      failed: 0\n    }\n  end\n\n  def record_received\n    @metrics[:received] += 1\n  end\n\n  def record_processed\n    @metrics[:processed] += 1\n  end\n\n  def record_failed\n    @metrics[:failed] += 1\n  end\n\n  def report\n    {\n      received: @metrics[:received],\n      processed: @metrics[:processed],\n      failed: @metrics[:failed],\n      success_rate: calculate_success_rate\n    }\n  end\n\n  private\n\n  def calculate_success_rate\n    return 0.0 if @metrics[:received].zero?\n\n    (@metrics[:processed].to_f / @metrics[:received] * 100).round(2)\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#complete-examples","title":"Complete Examples","text":""},{"location":"advanced/push-notifications/#background-job-processing","title":"Background Job Processing","text":"<pre><code># Server-side background job processor\nclass BackgroundJobServer &lt; A2APushServer\n  def handle_send_task(params)\n    task = A2A::Models::Task.from_hash(params['task'])\n    message = A2A::Models::Message.from_hash(params['message'])\n\n    # Extract job type from message\n    job_type = extract_job_type(message)\n\n    # Queue job for processing\n    job_id = queue_job(task.id, job_type, message)\n\n    debug_me \"Job #{job_id} queued for task #{task.id}\"\n\n    # Return immediately\n    task\n  end\n\n  private\n\n  def queue_job(task_id, job_type, message)\n    job = {\n      id: SecureRandom.uuid,\n      task_id: task_id,\n      type: job_type,\n      message: message,\n      created_at: Time.now\n    }\n\n    @job_queue &lt;&lt; job\n\n    # Start worker if needed\n    ensure_worker_running\n\n    job[:id]\n  end\n\n  def ensure_worker_running\n    return if @worker_running\n\n    @worker_running = true\n\n    Thread.new do\n      loop do\n        process_next_job\n        sleep(1)\n      end\n    end\n  end\n\n  def process_next_job\n    return if @job_queue.empty?\n\n    job = @job_queue.pop\n    task_id = job[:task_id]\n    task = @task_store[task_id]\n\n    begin\n      # Update to working\n      task = update_task(task, 'working', \"Processing #{job[:type]}...\")\n      @push_manager.notify_status_update(task)\n\n      # Process job based on type\n      result = case job[:type]\n      when 'video_encoding'\n        process_video_encoding(job)\n      when 'data_analysis'\n        process_data_analysis(job)\n      when 'report_generation'\n        process_report_generation(job)\n      else\n        raise \"Unknown job type: #{job[:type]}\"\n      end\n\n      # Create result artifact\n      artifact = create_result_artifact(task_id, result)\n\n      # Complete task\n      task = A2A::Models::Task.new(\n        id: task.id,\n        session_id: task.session_id,\n        status: {\n          state: 'completed',\n          message: A2A::Models::Message.text(\n            role: 'agent',\n            text: \"Job completed: #{job[:type]}\"\n          ),\n          timestamp: Time.now.utc.iso8601\n        },\n        artifacts: [artifact]\n      )\n\n      @task_store[task_id] = task\n      @push_manager.notify_status_update(task)\n      @push_manager.remove_config(task_id)\n\n    rescue StandardError =&gt; e\n      debug_me \"Job processing error: #{e.message}\"\n      task = update_task(task, 'failed', e.message)\n      @push_manager.notify_status_update(task)\n      @push_manager.remove_config(task_id)\n    end\n  end\n\n  def process_video_encoding(job)\n    # Simulate video encoding\n    10.times do |i|\n      sleep(2)\n      progress = ((i + 1) * 10)\n      task = @task_store[job[:task_id]]\n      task = update_task(task, 'working', \"Encoding: #{progress}%\")\n      @push_manager.notify_status_update(task)\n    end\n\n    { format: 'mp4', size: 1024000, duration: 120 }\n  end\n\n  def process_data_analysis(job)\n    # Simulate data analysis\n    { insights: [\"trend1\", \"trend2\"], confidence: 0.95 }\n  end\n\n  def process_report_generation(job)\n    # Simulate report generation\n    { pages: 25, charts: 8, tables: 12 }\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#testing-strategies","title":"Testing Strategies","text":""},{"location":"advanced/push-notifications/#testing-webhook-delivery","title":"Testing Webhook Delivery","text":"<pre><code>require 'webmock/rspec'\n\nRSpec.describe PushNotificationManager do\n  let(:manager) { described_class.new }\n\n  describe '#notify_status_update' do\n    it 'sends POST request to webhook URL' do\n      config = {\n        url: 'https://client.test/webhook',\n        token: 'test-token'\n      }\n\n      manager.set_config('task-1', config)\n\n      task = build_task(id: 'task-1', state: 'working')\n\n      stub = stub_request(:post, 'https://client.test/webhook')\n        .with(\n          headers: {\n            'Content-Type' =&gt; 'application/json',\n            'X-Webhook-Token' =&gt; 'test-token'\n          }\n        )\n        .to_return(status: 200)\n\n      manager.notify_status_update(task)\n\n      expect(stub).to have_been_requested\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#testing-webhook-receiver","title":"Testing Webhook Receiver","text":"<pre><code>RSpec.describe 'Webhook endpoint' do\n  it 'accepts valid webhook payloads' do\n    payload = {\n      taskId: 'task-1',\n      event: {\n        type: 'TaskStatusUpdateEvent',\n        task: build_task_hash\n      }\n    }\n\n    header 'X-Webhook-Token', WEBHOOK_TOKEN\n\n    post '/webhooks/a2a', JSON.generate(payload),\n         { 'CONTENT_TYPE' =&gt; 'application/json' }\n\n    expect(last_response.status).to eq(200)\n  end\n\n  it 'rejects requests with invalid token' do\n    payload = { taskId: 'task-1', event: {} }\n\n    header 'X-Webhook-Token', 'invalid'\n\n    post '/webhooks/a2a', JSON.generate(payload),\n         { 'CONTENT_TYPE' =&gt; 'application/json' }\n\n    expect(last_response.status).to eq(401)\n  end\nend\n</code></pre>"},{"location":"advanced/push-notifications/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/push-notifications/#issue-webhook-not-receiving-requests","title":"Issue: Webhook Not Receiving Requests","text":"<p>Solutions: 1. Verify URL is publicly accessible 2. Check firewall rules 3. Test with webhook.site or requestbin.com 4. Verify HTTPS certificate is valid</p> <pre><code># Test webhook URL\ndef test_webhook_url(url)\n  response = HTTP.post(url, json: { test: true })\n\n  if response.status.success?\n    debug_me \"Webhook URL is reachable\"\n  else\n    debug_me \"Webhook URL returned #{response.status}\"\n  end\nrescue HTTP::Error =&gt; e\n  debug_me \"Webhook URL unreachable: #{e.message}\"\nend\n</code></pre>"},{"location":"advanced/push-notifications/#issue-duplicate-webhook-deliveries","title":"Issue: Duplicate Webhook Deliveries","text":"<p>Solution: Implement idempotency keys</p> <pre><code>def handle_webhook_with_idempotency(payload)\n  idempotency_key = extract_idempotency_key(payload)\n\n  if already_processed?(idempotency_key)\n    debug_me \"Skipping duplicate webhook: #{idempotency_key}\"\n    return\n  end\n\n  mark_as_processed(idempotency_key)\n  process_webhook(payload)\nend\n</code></pre>"},{"location":"advanced/push-notifications/#issue-webhook-timeout","title":"Issue: Webhook Timeout","text":"<p>Solution: Return 200 immediately, process async</p> <pre><code>post '/webhooks/a2a' do\n  payload = JSON.parse(request.body.read)\n\n  # Queue for async processing\n  WEBHOOK_QUEUE &lt;&lt; payload\n\n  # Return immediately\n  status 200\n  JSON.generate({ received: true })\nend\n</code></pre>"},{"location":"advanced/push-notifications/#related-documentation","title":"Related Documentation","text":"<ul> <li>Streaming - Alternative for real-time updates</li> <li>Multi-Turn Conversations - Session management</li> <li>Error Handling - Error handling guide</li> <li>Task Lifecycle - Understanding task states</li> </ul>"},{"location":"advanced/push-notifications/#further-reading","title":"Further Reading","text":"<ul> <li>Webhook Security Best Practices</li> <li>A2A Protocol Specification</li> <li>JSON-RPC 2.0</li> </ul>"},{"location":"advanced/streaming/","title":"Streaming with Server-Sent Events (SSE)","text":"<p>Comprehensive guide to implementing real-time task updates using Server-Sent Events in the A2A protocol.</p>"},{"location":"advanced/streaming/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>When to Use Streaming</li> <li>Architecture</li> <li>Protocol Details</li> <li>Implementation Guide</li> <li>Server-Side Implementation</li> <li>Client-Side Implementation</li> <li>Event Types</li> <li>Error Handling</li> <li>Best Practices</li> <li>Complete Examples</li> <li>Testing Strategies</li> <li>Troubleshooting</li> </ul>"},{"location":"advanced/streaming/#overview","title":"Overview","text":"<p>Streaming in A2A uses Server-Sent Events (SSE) to provide real-time updates for long-running tasks. Unlike traditional HTTP request-response patterns, SSE establishes a persistent connection that allows the server to push updates to the client as the task progresses.</p>"},{"location":"advanced/streaming/#why-sse","title":"Why SSE?","text":"<p>SSE offers several advantages for agent communication:</p> <ul> <li>Unidirectional: Perfect for server-to-client updates</li> <li>Simple: Built on HTTP, no WebSocket complexity</li> <li>Automatic Reconnection: Browsers handle reconnection automatically</li> <li>Event IDs: Natural support for resuming interrupted streams</li> <li>Text-Based: Easy to debug and monitor</li> </ul>"},{"location":"advanced/streaming/#streaming-capability","title":"Streaming Capability","text":"<p>Agents indicate streaming support in their AgentCard:</p> <pre><code>require 'a2a'\n\nagent_card = A2A::Models::AgentCard.new(\n  name: \"Streaming Agent\",\n  url: \"https://api.example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: true,  # Indicates SSE support\n    push_notifications: false,\n    state_transition_history: false\n  }\n)\n</code></pre>"},{"location":"advanced/streaming/#when-to-use-streaming","title":"When to Use Streaming","text":"<p>Streaming is ideal for:</p> <ol> <li>Long-Running Tasks: Tasks that take more than a few seconds</li> <li>Progressive Results: When partial results should be shown immediately</li> <li>Multi-Step Processes: Tasks with distinct processing phases</li> <li>Real-Time Feedback: When users need to see progress updates</li> <li>Interruptible Work: Tasks that may require user input mid-execution</li> </ol> <p>Don't use streaming for: - Quick tasks (under 2 seconds) - Simple request-response interactions - Tasks with no intermediate state</p>"},{"location":"advanced/streaming/#architecture","title":"Architecture","text":"<pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 800 600\" style=\"background:transparent\"&gt;\n  &lt;!-- Client --&gt;\n  &lt;rect x=\"50\" y=\"50\" width=\"150\" height=\"80\" fill=\"#1e3a8a\" stroke=\"#3b82f6\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"125\" y=\"95\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;A2A Client&lt;/text&gt;\n\n  &lt;!-- Server --&gt;\n  &lt;rect x=\"600\" y=\"50\" width=\"150\" height=\"80\" fill=\"#1e3a8a\" stroke=\"#3b82f6\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"675\" y=\"95\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;A2A Server&lt;/text&gt;\n\n  &lt;!-- Agent --&gt;\n  &lt;rect x=\"600\" y=\"470\" width=\"150\" height=\"80\" fill=\"#064e3b\" stroke=\"#10b981\" stroke-width=\"2\" rx=\"5\"/&gt;\n  &lt;text x=\"675\" y=\"515\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\"&gt;Agent Core&lt;/text&gt;\n\n  &lt;!-- Request --&gt;\n  &lt;line x1=\"200\" y1=\"90\" x2=\"590\" y2=\"90\" stroke=\"#3b82f6\" stroke-width=\"2\" marker-end=\"url(#arrowblue)\"/&gt;\n  &lt;text x=\"400\" y=\"80\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;POST tasks/sendSubscribe&lt;/text&gt;\n\n  &lt;!-- SSE Connection --&gt;\n  &lt;line x1=\"600\" y1=\"130\" x2=\"200\" y2=\"130\" stroke=\"#10b981\" stroke-width=\"2\" stroke-dasharray=\"5,5\"/&gt;\n  &lt;text x=\"400\" y=\"120\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;SSE Connection Established&lt;/text&gt;\n\n  &lt;!-- Processing --&gt;\n  &lt;line x1=\"675\" y1=\"130\" x2=\"675\" y2=\"460\" stroke=\"#f59e0b\" stroke-width=\"2\" marker-end=\"url(#arroworange)\"/&gt;\n  &lt;text x=\"705\" y=\"295\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;Processing&lt;/text&gt;\n\n  &lt;!-- Events --&gt;\n  &lt;line x1=\"590\" y1=\"200\" x2=\"210\" y2=\"200\" stroke=\"#8b5cf6\" stroke-width=\"2\" marker-end=\"url(#arrowpurple)\"/&gt;\n  &lt;text x=\"400\" y=\"190\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;TaskStatusUpdateEvent&lt;/text&gt;\n\n  &lt;line x1=\"590\" y1=\"280\" x2=\"210\" y2=\"280\" stroke=\"#8b5cf6\" stroke-width=\"2\" marker-end=\"url(#arrowpurple)\"/&gt;\n  &lt;text x=\"400\" y=\"270\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;TaskArtifactUpdateEvent&lt;/text&gt;\n\n  &lt;line x1=\"590\" y1=\"360\" x2=\"210\" y2=\"360\" stroke=\"#8b5cf6\" stroke-width=\"2\" marker-end=\"url(#arrowpurple)\"/&gt;\n  &lt;text x=\"400\" y=\"350\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;TaskStatusUpdateEvent (completed)&lt;/text&gt;\n\n  &lt;!-- Connection Close --&gt;\n  &lt;line x1=\"590\" y1=\"440\" x2=\"210\" y2=\"440\" stroke=\"#ef4444\" stroke-width=\"2\" stroke-dasharray=\"5,5\"/&gt;\n  &lt;text x=\"400\" y=\"430\" text-anchor=\"middle\" fill=\"#fff\" font-family=\"Arial\" font-size=\"12\"&gt;Connection Closed&lt;/text&gt;\n\n  &lt;!-- Arrow markers --&gt;\n  &lt;defs&gt;\n    &lt;marker id=\"arrowblue\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#3b82f6\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowgreen\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#10b981\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arroworange\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#f59e0b\"/&gt;\n    &lt;/marker&gt;\n    &lt;marker id=\"arrowpurple\" markerWidth=\"10\" markerHeight=\"10\" refX=\"9\" refY=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\"&gt;\n      &lt;path d=\"M0,0 L0,6 L9,3 z\" fill=\"#8b5cf6\"/&gt;\n    &lt;/marker&gt;\n  &lt;/defs&gt;\n&lt;/svg&gt;\n</code></pre>"},{"location":"advanced/streaming/#flow-description","title":"Flow Description","text":"<ol> <li>Client Initiates: Sends <code>tasks/sendSubscribe</code> JSON-RPC request</li> <li>Server Establishes SSE: Returns HTTP 200 with <code>Content-Type: text/event-stream</code></li> <li>Agent Processes: Performs work asynchronously</li> <li>Server Streams Events: Sends <code>TaskStatusUpdateEvent</code> and <code>TaskArtifactUpdateEvent</code> as progress occurs</li> <li>Completion: Final event with terminal state, connection closes</li> </ol>"},{"location":"advanced/streaming/#protocol-details","title":"Protocol Details","text":""},{"location":"advanced/streaming/#json-rpc-method","title":"JSON-RPC Method","text":"<p>Streaming uses the <code>tasks/sendSubscribe</code> method:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-123\",\n  \"method\": \"tasks/sendSubscribe\",\n  \"params\": {\n    \"task\": {\n      \"id\": \"task-456\",\n      \"sessionId\": \"session-789\",\n      \"status\": {\n        \"state\": \"submitted\",\n        \"timestamp\": \"2025-10-21T10:00:00Z\"\n      }\n    },\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"text\": \"Generate a detailed market analysis report\"\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"advanced/streaming/#http-response-headers","title":"HTTP Response Headers","text":"<p>The server must set these headers for SSE:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\nX-Accel-Buffering: no\n</code></pre>"},{"location":"advanced/streaming/#sse-event-format","title":"SSE Event Format","text":"<p>Each event follows the SSE specification:</p> <pre><code>data: {\"jsonrpc\":\"2.0\",\"id\":\"req-123\",\"result\":{\"type\":\"TaskStatusUpdateEvent\",\"task\":{...}}}\n\ndata: {\"jsonrpc\":\"2.0\",\"id\":\"req-123\",\"result\":{\"type\":\"TaskArtifactUpdateEvent\",\"taskId\":\"task-456\",\"artifact\":{...}}}\n\ndata: {\"jsonrpc\":\"2.0\",\"id\":\"req-123\",\"result\":{\"type\":\"TaskStatusUpdateEvent\",\"task\":{\"status\":{\"state\":\"completed\"}}}}\n</code></pre>"},{"location":"advanced/streaming/#implementation-guide","title":"Implementation Guide","text":""},{"location":"advanced/streaming/#server-side-implementation","title":"Server-Side Implementation","text":""},{"location":"advanced/streaming/#using-rack-sinatrarails","title":"Using Rack (Sinatra/Rails)","text":"<pre><code>require 'a2a'\nrequire 'json'\n\nclass A2AStreamingServer &lt; A2A::Server::Base\n  # Handle streaming task submission\n  def handle_send_task_streaming(params)\n    task_data = params['task'] || params[:task]\n    message_data = params['message'] || params[:message]\n\n    task = A2A::Models::Task.from_hash(task_data)\n    message = A2A::Models::Message.from_hash(message_data)\n\n    # Return an Enumerator that yields SSE events\n    Enumerator.new do |yielder|\n      stream_task_execution(task, message, yielder)\n    end\n  end\n\n  private\n\n  def stream_task_execution(task, message, yielder)\n    begin\n      # Send initial \"working\" status\n      task = update_task_status(task, 'working',\n        \"Starting analysis...\")\n      yield_task_status(task, yielder)\n\n      # Simulate multi-step processing\n      steps = [\n        \"Collecting market data...\",\n        \"Analyzing trends...\",\n        \"Generating visualizations...\",\n        \"Compiling final report...\"\n      ]\n\n      steps.each_with_index do |step_message, index|\n        sleep(2) # Simulate work\n\n        # Update status\n        task = update_task_status(task, 'working', step_message)\n        yield_task_status(task, yielder)\n\n        # Generate intermediate artifacts\n        if index == 1\n          artifact = create_data_artifact(\n            \"Preliminary Analysis\",\n            { trends: [\"upward\", \"volatile\"], confidence: 0.75 }\n          )\n          yield_artifact_update(task.id, artifact, yielder)\n        end\n      end\n\n      # Generate final artifact\n      final_artifact = create_report_artifact(task.id)\n      yield_artifact_update(task.id, final_artifact, yielder)\n\n      # Complete the task\n      task = update_task_status(task, 'completed', \"Analysis complete\")\n      task.instance_variable_set(:@artifacts, [final_artifact])\n      yield_task_status(task, yielder)\n\n    rescue StandardError =&gt; e\n      # Handle errors by sending failed status\n      debug_me \"Error in streaming: #{e.message}\"\n      task = update_task_status(task, 'failed', e.message)\n      yield_task_status(task, yielder)\n    ensure\n      # Connection will close after final yield\n    end\n  end\n\n  def yield_task_status(task, yielder)\n    event = {\n      jsonrpc: \"2.0\",\n      id: task.id,\n      result: {\n        type: \"TaskStatusUpdateEvent\",\n        task: task.to_h\n      }\n    }\n    yielder &lt;&lt; format_sse_event(event)\n  end\n\n  def yield_artifact_update(task_id, artifact, yielder)\n    event = {\n      jsonrpc: \"2.0\",\n      id: task_id,\n      result: {\n        type: \"TaskArtifactUpdateEvent\",\n        taskId: task_id,\n        artifact: artifact.to_h\n      }\n    }\n    yielder &lt;&lt; format_sse_event(event)\n  end\n\n  def format_sse_event(data)\n    \"data: #{JSON.generate(data)}\\n\\n\"\n  end\n\n  def update_task_status(task, state, message_text)\n    A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: {\n        state: state,\n        message: A2A::Models::Message.text(\n          role: 'agent',\n          text: message_text\n        ),\n        timestamp: Time.now.utc.iso8601\n      },\n      artifacts: task.artifacts,\n      metadata: task.metadata\n    )\n  end\n\n  def create_data_artifact(name, data)\n    A2A::Models::Artifact.new(\n      name: name,\n      parts: [\n        A2A::Models::DataPart.new(data: data)\n      ],\n      metadata: {\n        generated_at: Time.now.utc.iso8601\n      }\n    )\n  end\n\n  def create_report_artifact(task_id)\n    A2A::Models::Artifact.new(\n      name: \"Market Analysis Report\",\n      description: \"Comprehensive market analysis with trends and predictions\",\n      parts: [\n        A2A::Models::TextPart.new(\n          text: \"# Market Analysis Report\\n\\nDetailed analysis shows...\"\n        ),\n        A2A::Models::DataPart.new(\n          data: {\n            summary: {\n              market_trend: \"bullish\",\n              risk_level: \"moderate\",\n              confidence: 0.89\n            },\n            key_findings: [\n              \"Strong growth in technology sector\",\n              \"Increased volatility in energy markets\",\n              \"Emerging opportunities in healthcare\"\n            ],\n            recommendations: [\n              \"Diversify portfolio across sectors\",\n              \"Monitor regulatory changes\",\n              \"Consider long-term positions\"\n            ]\n          }\n        )\n      ],\n      metadata: {\n        task_id: task_id,\n        generated_at: Time.now.utc.iso8601,\n        format: \"markdown+json\"\n      }\n    )\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#sinatra-application","title":"Sinatra Application","text":"<pre><code>require 'sinatra'\nrequire 'sinatra/streaming'\nrequire 'json'\nrequire_relative 'a2a_streaming_server'\n\n# Configure streaming\nset :server, :puma\nset :threaded, true\n\n# Agent card endpoint\nget '/.well-known/agent.json' do\n  content_type :json\n\n  agent_card = A2A::Models::AgentCard.new(\n    name: \"Market Analysis Agent\",\n    url: \"#{request.base_url}/a2a\",\n    version: \"1.0.0\",\n    description: \"Provides detailed market analysis and insights\",\n    capabilities: {\n      streaming: true,\n      push_notifications: false,\n      state_transition_history: false\n    },\n    skills: [\n      {\n        id: \"market-analysis\",\n        name: \"Market Analysis\",\n        description: \"Analyze market trends and generate reports\",\n        tags: [\"finance\", \"analysis\", \"reporting\"]\n      }\n    ]\n  )\n\n  JSON.generate(agent_card.to_h)\nend\n\n# A2A endpoint with streaming\npost '/a2a' do\n  request_body = JSON.parse(request.body.read)\n\n  # Parse JSON-RPC request\n  method_name = request_body['method']\n  params = request_body['params']\n  request_id = request_body['id']\n\n  server = A2AStreamingServer.new(nil)\n\n  case method_name\n  when 'tasks/sendSubscribe'\n    # Set SSE headers\n    content_type 'text/event-stream'\n    headers 'Cache-Control' =&gt; 'no-cache',\n            'Connection' =&gt; 'keep-alive',\n            'X-Accel-Buffering' =&gt; 'no'\n\n    # Stream events\n    stream :keep_open do |out|\n      begin\n        event_enum = server.handle_send_task_streaming(params)\n\n        event_enum.each do |sse_data|\n          out &lt;&lt; sse_data\n        end\n      ensure\n        out.close\n      end\n    end\n\n  when 'tasks/send'\n    # Non-streaming task handling\n    content_type :json\n    task = server.handle_send_task(params)\n\n    response = {\n      jsonrpc: \"2.0\",\n      id: request_id,\n      result: task.to_h\n    }\n\n    JSON.generate(response)\n\n  else\n    status 400\n    content_type :json\n\n    error_response = {\n      jsonrpc: \"2.0\",\n      id: request_id,\n      error: {\n        code: -32601,\n        message: \"Method not found\"\n      }\n    }\n\n    JSON.generate(error_response)\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#client-side-implementation","title":"Client-Side Implementation","text":""},{"location":"advanced/streaming/#basic-streaming-client","title":"Basic Streaming Client","text":"<pre><code>require 'a2a'\nrequire 'http'\nrequire 'json'\n\nclass A2AStreamingClient &lt; A2A::Client::Base\n  def initialize(agent_url)\n    super(agent_url)\n    @http_client = HTTP.timeout(connect: 5, read: 300)\n  end\n\n  def send_task_streaming(task_id:, message:, session_id: nil, &amp;block)\n    raise ArgumentError, \"Block required for streaming\" unless block_given?\n\n    # Build the request\n    request = build_streaming_request(task_id, message, session_id)\n\n    # Make SSE request\n    response = @http_client.post(\n      agent_url,\n      json: request,\n      headers: {\n        'Accept' =&gt; 'text/event-stream'\n      }\n    )\n\n    unless response.status.success?\n      raise A2A::InternalError, \"HTTP #{response.status}: #{response.body}\"\n    end\n\n    # Parse SSE stream\n    parse_sse_stream(response.body, &amp;block)\n  end\n\n  private\n\n  def build_streaming_request(task_id, message, session_id)\n    task = A2A::Models::Task.new(\n      id: task_id,\n      session_id: session_id,\n      status: {\n        state: 'submitted',\n        timestamp: Time.now.utc.iso8601\n      }\n    )\n\n    {\n      jsonrpc: \"2.0\",\n      id: task_id,\n      method: \"tasks/sendSubscribe\",\n      params: {\n        task: task.to_h,\n        message: message.to_h\n      }\n    }\n  end\n\n  def parse_sse_stream(body_enum, &amp;block)\n    buffer = \"\"\n\n    body_enum.each do |chunk|\n      buffer &lt;&lt; chunk\n\n      # Process complete events\n      while buffer.include?(\"\\n\\n\")\n        event_data, buffer = buffer.split(\"\\n\\n\", 2)\n\n        # Parse SSE event\n        if event_data.start_with?(\"data: \")\n          json_data = event_data.sub(/^data: /, '').strip\n          next if json_data.empty?\n\n          begin\n            event = JSON.parse(json_data, symbolize_names: true)\n            process_event(event, &amp;block)\n          rescue JSON::ParserError =&gt; e\n            debug_me \"Failed to parse SSE event: #{e.message}\"\n          end\n        end\n      end\n    end\n  end\n\n  def process_event(event)\n    return unless event[:result]\n\n    result = event[:result]\n    event_type = result[:type]\n\n    case event_type\n    when 'TaskStatusUpdateEvent'\n      task = A2A::Models::Task.from_hash(result[:task])\n      yield :status, task\n\n    when 'TaskArtifactUpdateEvent'\n      task_id = result[:taskId]\n      artifact = A2A::Models::Artifact.from_hash(result[:artifact])\n      yield :artifact, task_id, artifact\n\n    else\n      debug_me \"Unknown event type: #{event_type}\"\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#using-the-streaming-client","title":"Using the Streaming Client","text":"<pre><code>require_relative 'a2a_streaming_client'\n\nclient = A2AStreamingClient.new('https://api.example.com/a2a')\n\nmessage = A2A::Models::Message.text(\n  role: 'user',\n  text: 'Analyze the current state of the technology sector'\n)\n\ntask_id = \"task-#{SecureRandom.uuid}\"\nartifacts = []\nfinal_task = nil\n\nbegin\n  client.send_task_streaming(\n    task_id: task_id,\n    message: message,\n    session_id: \"session-#{SecureRandom.uuid}\"\n  ) do |event_type, *args|\n    case event_type\n    when :status\n      task = args[0]\n      debug_me \"Status: #{task.status.state.value}\"\n\n      if task.status.message\n        debug_me \"Message: #{task.status.message.parts.first&amp;.text}\"\n      end\n\n      final_task = task\n\n      # Break if terminal state\n      break if task.status.state.terminal?\n\n    when :artifact\n      task_id, artifact = args\n      debug_me \"Received artifact: #{artifact.name}\"\n      artifacts &lt;&lt; artifact\n\n      # Display artifact content\n      artifact.parts.each do |part|\n        case part\n        when A2A::Models::TextPart\n          debug_me \"Text: #{part.text[0..100]}...\"\n        when A2A::Models::DataPart\n          debug_me \"Data: #{part.data.inspect}\"\n        end\n      end\n    end\n  end\n\n  debug_me \"Task completed with #{artifacts.size} artifacts\"\n\nrescue StandardError =&gt; e\n  debug_me \"Streaming error: #{e.message}\"\nend\n</code></pre>"},{"location":"advanced/streaming/#event-types","title":"Event Types","text":""},{"location":"advanced/streaming/#taskstatusupdateevent","title":"TaskStatusUpdateEvent","text":"<p>Sent when task status changes:</p> <pre><code># Server sends:\n{\n  jsonrpc: \"2.0\",\n  id: \"task-123\",\n  result: {\n    type: \"TaskStatusUpdateEvent\",\n    task: {\n      id: \"task-123\",\n      sessionId: \"session-456\",\n      status: {\n        state: \"working\",\n        message: {\n          role: \"agent\",\n          parts: [\n            { text: \"Processing data...\" }\n          ]\n        },\n        timestamp: \"2025-10-21T10:05:30Z\"\n      }\n    }\n  }\n}\n</code></pre> <p>When to send: - Task state transitions (submitted \u2192 working \u2192 completed) - Progress updates during long operations - Error conditions (\u2192 failed) - User input required (\u2192 input-required)</p>"},{"location":"advanced/streaming/#taskartifactupdateevent","title":"TaskArtifactUpdateEvent","text":"<p>Sent when artifacts are generated:</p> <pre><code># Server sends:\n{\n  jsonrpc: \"2.0\",\n  id: \"task-123\",\n  result: {\n    type: \"TaskArtifactUpdateEvent\",\n    taskId: \"task-123\",\n    artifact: {\n      name: \"Intermediate Results\",\n      description: \"Partial analysis results\",\n      parts: [\n        {\n          data: {\n            processed_records: 1000,\n            estimated_completion: \"70%\"\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>When to send: - Partial results become available - Progressive output (e.g., streaming text generation) - Intermediate files generated - Multi-artifact tasks (charts, tables, reports)</p>"},{"location":"advanced/streaming/#error-handling","title":"Error Handling","text":""},{"location":"advanced/streaming/#connection-errors","title":"Connection Errors","text":"<pre><code>def send_task_streaming_with_retry(task_id:, message:, max_retries: 3)\n  retries = 0\n\n  begin\n    send_task_streaming(task_id: task_id, message: message) do |event_type, *args|\n      yield event_type, *args\n    end\n\n  rescue HTTP::TimeoutError, HTTP::ConnectionError =&gt; e\n    retries += 1\n\n    if retries &lt;= max_retries\n      debug_me \"Connection error, retrying (#{retries}/#{max_retries})...\"\n      sleep(2 ** retries) # Exponential backoff\n      retry\n    else\n      raise A2A::InternalError, \"Max retries exceeded: #{e.message}\"\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#server-side-error-events","title":"Server-Side Error Events","text":"<pre><code>def stream_with_error_handling(task, message, yielder)\n  begin\n    # Processing logic\n    process_task(task, message, yielder)\n\n  rescue ValidationError =&gt; e\n    # Send error status update\n    error_task = A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: {\n        state: 'failed',\n        message: A2A::Models::Message.text(\n          role: 'agent',\n          text: \"Validation failed: #{e.message}\"\n        ),\n        timestamp: Time.now.utc.iso8601\n      }\n    )\n\n    yield_task_status(error_task, yielder)\n\n  rescue StandardError =&gt; e\n    debug_me \"Unexpected error: #{e.message}\"\n    debug_me e.backtrace.join(\"\\n\")\n\n    # Send generic error\n    error_task = A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: {\n        state: 'failed',\n        message: A2A::Models::Message.text(\n          role: 'agent',\n          text: \"An error occurred while processing your request\"\n        ),\n        timestamp: Time.now.utc.iso8601\n      }\n    )\n\n    yield_task_status(error_task, yielder)\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#client-side-timeout-handling","title":"Client-Side Timeout Handling","text":"<pre><code>class StreamingTimeout &lt; StandardError; end\n\ndef send_task_streaming_with_timeout(task_id:, message:, timeout: 300)\n  start_time = Time.now\n\n  send_task_streaming(task_id: task_id, message: message) do |event_type, *args|\n    # Check timeout\n    elapsed = Time.now - start_time\n    if elapsed &gt; timeout\n      raise StreamingTimeout, \"Streaming exceeded #{timeout}s timeout\"\n    end\n\n    yield event_type, *args\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#best-practices","title":"Best Practices","text":""},{"location":"advanced/streaming/#1-send-frequent-status-updates","title":"1. Send Frequent Status Updates","text":"<p>Keep clients informed of progress:</p> <pre><code>def process_large_dataset(task, data, yielder)\n  total = data.size\n  batch_size = 100\n\n  data.each_slice(batch_size).with_index do |batch, index|\n    # Process batch\n    results = process_batch(batch)\n\n    # Update progress every batch\n    progress = ((index + 1) * batch_size * 100.0 / total).round(1)\n    task = update_task_status(\n      task,\n      'working',\n      \"Processing: #{progress}% complete (#{(index + 1) * batch_size}/#{total})\"\n    )\n    yield_task_status(task, yielder)\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#2-use-meaningful-event-timing","title":"2. Use Meaningful Event Timing","text":"<p>Don't spam events - batch updates when appropriate:</p> <pre><code>def stream_with_throttling(task, yielder)\n  last_update = Time.now\n  min_interval = 1.0 # Minimum 1 second between updates\n\n  loop do\n    work_result = do_some_work\n\n    # Only send update if enough time has passed\n    if Time.now - last_update &gt;= min_interval\n      task = update_task_status(task, 'working', work_result.message)\n      yield_task_status(task, yielder)\n      last_update = Time.now\n    end\n\n    break if work_complete?\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#3-always-send-terminal-state","title":"3. Always Send Terminal State","text":"<p>Ensure clients know when the task is complete:</p> <pre><code>def stream_task(task, message, yielder)\n  begin\n    # Processing\n    process_work(task, message, yielder)\n\n  ensure\n    # Always send final status\n    unless task.status.state.terminal?\n      final_task = update_task_status(task, 'completed', \"Processing complete\")\n      yield_task_status(final_task, yielder)\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#4-include-event-ids-for-resumability","title":"4. Include Event IDs for Resumability","text":"<p>Add event IDs to support reconnection:</p> <pre><code>def format_sse_event_with_id(data, event_id)\n  &lt;&lt;~SSE\n    id: #{event_id}\n    data: #{JSON.generate(data)}\n\n  SSE\nend\n\ndef stream_with_event_ids(task, yielder)\n  event_counter = 0\n\n  loop do\n    event_counter += 1\n\n    # Generate event\n    event_data = create_status_event(task)\n\n    # Send with ID\n    yielder &lt;&lt; format_sse_event_with_id(event_data, event_counter)\n\n    break if task.status.state.terminal?\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#5-implement-keep-alive","title":"5. Implement Keep-Alive","text":"<p>Prevent connection timeouts with periodic pings:</p> <pre><code>def stream_with_keepalive(task, message, yielder)\n  last_event = Time.now\n  keepalive_interval = 30 # seconds\n\n  processing_thread = Thread.new do\n    process_task(task, message, yielder)\n  end\n\n  until processing_thread.join(1)\n    # Send comment as keep-alive if no recent events\n    if Time.now - last_event &gt; keepalive_interval\n      yielder &lt;&lt; \": keepalive\\n\\n\"\n      last_event = Time.now\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#complete-examples","title":"Complete Examples","text":""},{"location":"advanced/streaming/#multi-step-document-processing","title":"Multi-Step Document Processing","text":"<pre><code>class DocumentProcessingServer &lt; A2A::Server::Base\n  def handle_send_task_streaming(params)\n    task = A2A::Models::Task.from_hash(params['task'])\n    message = A2A::Models::Message.from_hash(params['message'])\n\n    Enumerator.new do |yielder|\n      stream_document_processing(task, message, yielder)\n    end\n  end\n\n  private\n\n  def stream_document_processing(task, message, yielder)\n    # Extract document from message\n    document_part = message.parts.find { |p| p.is_a?(A2A::Models::FilePart) }\n\n    unless document_part\n      fail_task(task, \"No document provided\", yielder)\n      return\n    end\n\n    # Step 1: Extract text\n    update_and_yield(task, 'working', \"Extracting text from document...\", yielder)\n    text_content = extract_text(document_part)\n\n    # Step 2: Analyze content\n    update_and_yield(task, 'working', \"Analyzing document structure...\", yielder)\n    structure = analyze_structure(text_content)\n\n    # Send intermediate artifact\n    structure_artifact = A2A::Models::Artifact.new(\n      name: \"Document Structure\",\n      parts: [A2A::Models::DataPart.new(data: structure)]\n    )\n    yield_artifact_update(task.id, structure_artifact, yielder)\n\n    # Step 3: Extract entities\n    update_and_yield(task, 'working', \"Extracting entities...\", yielder)\n    entities = extract_entities(text_content)\n\n    # Step 4: Generate summary\n    update_and_yield(task, 'working', \"Generating summary...\", yielder)\n    summary = generate_summary(text_content)\n\n    # Send final artifacts\n    summary_artifact = A2A::Models::Artifact.new(\n      name: \"Document Summary\",\n      parts: [\n        A2A::Models::TextPart.new(text: summary),\n        A2A::Models::DataPart.new(data: {\n          entities: entities,\n          word_count: text_content.split.size,\n          structure: structure\n        })\n      ]\n    )\n\n    yield_artifact_update(task.id, summary_artifact, yielder)\n\n    # Complete\n    task.instance_variable_set(:@artifacts, [structure_artifact, summary_artifact])\n    update_and_yield(task, 'completed', \"Document processing complete\", yielder)\n  end\n\n  def update_and_yield(task, state, message_text, yielder)\n    task = update_task_status(task, state, message_text)\n    yield_task_status(task, yielder)\n    task\n  end\n\n  def fail_task(task, error_message, yielder)\n    task = update_task_status(task, 'failed', error_message)\n    yield_task_status(task, yielder)\n  end\n\n  def extract_text(file_part)\n    # Simulate text extraction\n    \"Sample document content...\"\n  end\n\n  def analyze_structure(text)\n    { sections: 5, paragraphs: 23, headings: 8 }\n  end\n\n  def extract_entities(text)\n    [\"Company A\", \"Product B\", \"Location C\"]\n  end\n\n  def generate_summary(text)\n    \"This document discusses...\"\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#real-time-data-analysis-client","title":"Real-Time Data Analysis Client","text":"<pre><code>class AnalysisClient\n  def initialize(agent_url)\n    @client = A2AStreamingClient.new(agent_url)\n    @progress_bar = nil\n  end\n\n  def analyze_dataset(dataset_file)\n    message = create_analysis_message(dataset_file)\n    task_id = \"analysis-#{SecureRandom.uuid}\"\n\n    artifacts = []\n    status_messages = []\n\n    debug_me \"Starting analysis...\"\n\n    @client.send_task_streaming(\n      task_id: task_id,\n      message: message\n    ) do |event_type, *args|\n      case event_type\n      when :status\n        task = args[0]\n        handle_status_update(task, status_messages)\n\n      when :artifact\n        _, artifact = args\n        artifacts &lt;&lt; artifact\n        handle_artifact(artifact)\n      end\n    end\n\n    debug_me \"\\nAnalysis complete!\"\n    debug_me \"Received #{artifacts.size} artifacts\"\n\n    artifacts\n  end\n\n  private\n\n  def create_analysis_message(file_path)\n    file_content = File.binread(file_path)\n\n    A2A::Models::Message.new(\n      role: 'user',\n      parts: [\n        A2A::Models::TextPart.new(\n          text: \"Analyze this dataset and provide insights\"\n        ),\n        A2A::Models::FilePart.new(\n          file: {\n            name: File.basename(file_path),\n            mime_type: 'text/csv',\n            bytes: Base64.strict_encode64(file_content)\n          }\n        )\n      ]\n    )\n  end\n\n  def handle_status_update(task, status_messages)\n    state = task.status.state.value\n\n    if task.status.message\n      msg = task.status.message.parts.first&amp;.text\n      status_messages &lt;&lt; msg if msg\n\n      # Show progress\n      debug_me \"[#{state.upcase}] #{msg}\"\n\n      # Parse percentage if present\n      if msg =~ /(\\d+)%/\n        update_progress_bar($1.to_i)\n      end\n    end\n  end\n\n  def handle_artifact(artifact)\n    debug_me \"\\nReceived: #{artifact.name}\"\n\n    artifact.parts.each do |part|\n      case part\n      when A2A::Models::DataPart\n        # Display key metrics\n        if part.data[:summary]\n          debug_me \"Summary: #{part.data[:summary].inspect}\"\n        end\n\n      when A2A::Models::FilePart\n        # Save file artifacts\n        if part.file[:bytes]\n          save_artifact_file(artifact.name, part.file[:bytes])\n        end\n      end\n    end\n  end\n\n  def update_progress_bar(percentage)\n    # Visual progress indicator\n    bar_width = 50\n    filled = (bar_width * percentage / 100.0).round\n    bar = \"#{'=' * filled}#{' ' * (bar_width - filled)}\"\n    print \"\\r[#{bar}] #{percentage}%\"\n  end\n\n  def save_artifact_file(name, base64_bytes)\n    filename = \"output/#{name.gsub(/\\s+/, '_')}\"\n    File.write(filename, Base64.decode64(base64_bytes))\n    debug_me \"Saved: #{filename}\"\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#testing-strategies","title":"Testing Strategies","text":""},{"location":"advanced/streaming/#unit-testing-server-streaming","title":"Unit Testing Server Streaming","text":"<pre><code>require 'rspec'\n\nRSpec.describe A2AStreamingServer do\n  let(:server) { described_class.new(agent_card) }\n  let(:agent_card) { build_agent_card }\n\n  describe '#handle_send_task_streaming' do\n    it 'yields multiple status events' do\n      task = build_task\n      message = build_message\n      params = { task: task.to_h, message: message.to_h }\n\n      events = []\n      enum = server.handle_send_task_streaming(params)\n\n      enum.each do |event_data|\n        # Parse SSE format\n        json_str = event_data.sub(/^data: /, '').strip\n        events &lt;&lt; JSON.parse(json_str, symbolize_names: true)\n      end\n\n      expect(events.size).to be &gt; 1\n      expect(events.first[:result][:type]).to eq('TaskStatusUpdateEvent')\n    end\n\n    it 'sends terminal state as final event' do\n      params = { task: build_task.to_h, message: build_message.to_h }\n      enum = server.handle_send_task_streaming(params)\n\n      final_event = nil\n      enum.each do |event_data|\n        json_str = event_data.sub(/^data: /, '').strip\n        final_event = JSON.parse(json_str, symbolize_names: true)\n      end\n\n      task_state = final_event[:result][:task][:status][:state]\n      expect(['completed', 'failed', 'canceled']).to include(task_state)\n    end\n\n    it 'yields artifact events when artifacts generated' do\n      params = { task: build_task.to_h, message: build_message.to_h }\n      enum = server.handle_send_task_streaming(params)\n\n      artifact_events = enum.map do |event_data|\n        json_str = event_data.sub(/^data: /, '').strip\n        JSON.parse(json_str, symbolize_names: true)\n      end.select { |e| e[:result][:type] == 'TaskArtifactUpdateEvent' }\n\n      expect(artifact_events.size).to be &gt; 0\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#integration-testing-with-mock-sse","title":"Integration Testing with Mock SSE","text":"<pre><code>require 'webmock/rspec'\n\nRSpec.describe A2AStreamingClient do\n  let(:client) { described_class.new('https://api.test/a2a') }\n\n  describe '#send_task_streaming' do\n    it 'processes SSE events correctly' do\n      # Mock SSE response\n      sse_body = &lt;&lt;~SSE\n        data: {\"jsonrpc\":\"2.0\",\"id\":\"task-1\",\"result\":{\"type\":\"TaskStatusUpdateEvent\",\"task\":{\"id\":\"task-1\",\"status\":{\"state\":\"working\"}}}}\n\n        data: {\"jsonrpc\":\"2.0\",\"id\":\"task-1\",\"result\":{\"type\":\"TaskArtifactUpdateEvent\",\"taskId\":\"task-1\",\"artifact\":{\"name\":\"Test\"}}}\n\n        data: {\"jsonrpc\":\"2.0\",\"id\":\"task-1\",\"result\":{\"type\":\"TaskStatusUpdateEvent\",\"task\":{\"id\":\"task-1\",\"status\":{\"state\":\"completed\"}}}}\n\n      SSE\n\n      stub_request(:post, 'https://api.test/a2a')\n        .to_return(\n          status: 200,\n          body: sse_body,\n          headers: { 'Content-Type' =&gt; 'text/event-stream' }\n        )\n\n      events = []\n      message = A2A::Models::Message.text(role: 'user', text: 'test')\n\n      client.send_task_streaming(\n        task_id: 'task-1',\n        message: message\n      ) do |event_type, *args|\n        events &lt;&lt; [event_type, args]\n      end\n\n      expect(events.size).to eq(3)\n      expect(events[0][0]).to eq(:status)\n      expect(events[1][0]).to eq(:artifact)\n      expect(events[2][0]).to eq(:status)\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/streaming/#issue-connection-drops-unexpectedly","title":"Issue: Connection Drops Unexpectedly","text":"<p>Symptoms: SSE connection closes before task completes</p> <p>Solutions: 1. Implement keep-alive comments 2. Check for proxy timeouts (nginx, CloudFlare) 3. Verify server doesn't buffer responses 4. Add connection monitoring</p> <pre><code># Server-side keep-alive\ndef stream_with_monitoring(task, yielder)\n  Thread.new do\n    loop do\n      sleep(30)\n      yielder &lt;&lt; \": ping\\n\\n\"\n    end\n  end\n\n  # Main processing\n  process_task(task, yielder)\nend\n</code></pre>"},{"location":"advanced/streaming/#issue-events-not-received-in-real-time","title":"Issue: Events Not Received in Real-Time","text":"<p>Symptoms: Events arrive in batches instead of streaming</p> <p>Solutions: 1. Disable response buffering 2. Flush output after each event 3. Check reverse proxy configuration</p> <pre><code># Sinatra - disable buffering\nset :stream, true\n\n# Nginx configuration\n# proxy_buffering off;\n# proxy_cache off;\n</code></pre>"},{"location":"advanced/streaming/#issue-memory-leaks-in-long-streams","title":"Issue: Memory Leaks in Long Streams","text":"<p>Symptoms: Server memory grows during long tasks</p> <p>Solutions: 1. Stream large data in chunks 2. Don't accumulate events in memory 3. Clean up resources after each event</p> <pre><code>def stream_efficiently(task, yielder)\n  # Don't do this - accumulates in memory\n  # all_events = []\n  # process.each { |e| all_events &lt;&lt; e }\n  # all_events.each { |e| yielder &lt;&lt; e }\n\n  # Do this instead - stream directly\n  process_data do |event|\n    yielder &lt;&lt; format_sse_event(event)\n    # Event is garbage collected after yield\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#issue-client-cant-reconnect-after-disconnect","title":"Issue: Client Can't Reconnect After Disconnect","text":"<p>Symptoms: Lost connection requires full restart</p> <p>Solutions: 1. Implement event IDs 2. Use <code>tasks/resubscribe</code> method 3. Store last event ID client-side</p> <pre><code>class ResilientClient\n  def stream_with_resume(task_id, message)\n    last_event_id = nil\n\n    begin\n      send_task_streaming(task_id: task_id, message: message) do |event_type, *args|\n        yield event_type, *args\n        # Track last event (if server sends IDs)\n        last_event_id = extract_event_id(args)\n      end\n\n    rescue ConnectionError =&gt; e\n      debug_me \"Connection lost, attempting resume...\"\n      # Use resubscribe with last event ID\n      resubscribe(task_id, last_event_id) do |event_type, *args|\n        yield event_type, *args\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/streaming/#related-documentation","title":"Related Documentation","text":"<ul> <li>Push Notifications - Alternative to streaming for long tasks</li> <li>Multi-Turn Conversations - Using sessions with streaming</li> <li>Error Handling - Comprehensive error handling guide</li> <li>Task Lifecycle - Understanding task states</li> </ul>"},{"location":"advanced/streaming/#further-reading","title":"Further Reading","text":"<ul> <li>Server-Sent Events Specification</li> <li>A2A Protocol Specification</li> <li>JSON-RPC 2.0</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for the A2A (Agent-to-Agent) Ruby gem.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>The A2A gem provides a Ruby implementation of the Agent-to-Agent protocol, enabling seamless communication and interoperability between autonomous agent applications. This reference documents all public classes, methods, and interfaces available in the gem.</p>"},{"location":"api/#quick-navigation","title":"Quick Navigation","text":""},{"location":"api/#core-components","title":"Core Components","text":"<ul> <li>Models - Data models for tasks, messages, artifacts, and agent cards</li> <li>Protocol - JSON-RPC protocol implementation for request/response handling</li> <li>Client - Client base class for consuming A2A services</li> <li>Server - Server base class for exposing A2A endpoints</li> </ul>"},{"location":"api/#architecture","title":"Architecture","text":"<p>The A2A gem is organized into four main layers:</p>"},{"location":"api/#1-models-layer-a2amodels","title":"1. Models Layer (<code>A2A::Models</code>)","text":"<p>Data structures representing the A2A protocol entities:</p> <ul> <li>Task Management: <code>Task</code>, <code>TaskStatus</code>, <code>TaskState</code></li> <li>Communication: <code>Message</code>, <code>Artifact</code>, <code>Part</code> (and subclasses)</li> <li>Agent Metadata: <code>AgentCard</code>, <code>AgentCapabilities</code>, <code>AgentSkill</code>, <code>AgentProvider</code>, <code>AgentAuthentication</code></li> <li>Configuration: <code>PushNotificationConfig</code></li> </ul> <p>View Models Documentation</p>"},{"location":"api/#2-protocol-layer-a2aprotocol","title":"2. Protocol Layer (<code>A2A::Protocol</code>)","text":"<p>JSON-RPC 2.0 protocol implementation:</p> <ul> <li><code>Request</code> - JSON-RPC request representation</li> <li><code>Response</code> - JSON-RPC response representation</li> <li><code>Error</code> - Protocol error handling</li> </ul> <p>View Protocol Documentation</p>"},{"location":"api/#3-client-layer-a2aclient","title":"3. Client Layer (<code>A2A::Client</code>)","text":"<p>Client implementation for consuming A2A services:</p> <ul> <li>Agent discovery via <code>/.well-known/agent.json</code></li> <li>Task submission and management</li> <li>Streaming support</li> <li>Push notification configuration</li> </ul> <p>View Client Documentation</p>"},{"location":"api/#4-server-layer-a2aserver","title":"4. Server Layer (<code>A2A::Server</code>)","text":"<p>Server implementation for exposing A2A endpoints:</p> <ul> <li>Request handling</li> <li>Task lifecycle management</li> <li>Streaming support</li> <li>Push notification support</li> </ul> <p>View Server Documentation</p>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>The gem defines a comprehensive error hierarchy based on JSON-RPC error codes:</p>"},{"location":"api/#base-errors","title":"Base Errors","text":"<ul> <li><code>A2A::Error</code> - Base error class</li> <li><code>A2A::JSONRPCError</code> - Base for all JSON-RPC errors (with code and data)</li> </ul>"},{"location":"api/#standard-json-rpc-errors","title":"Standard JSON-RPC Errors","text":"Error Class Code Description <code>JSONParseError</code> -32700 Invalid JSON payload <code>InvalidRequestError</code> -32600 Request payload validation error <code>MethodNotFoundError</code> -32601 Method not found <code>InvalidParamsError</code> -32602 Invalid parameters <code>InternalError</code> -32603 Internal error"},{"location":"api/#a2a-specific-errors","title":"A2A-Specific Errors","text":"Error Class Code Description <code>TaskNotFoundError</code> -32001 Task not found <code>TaskNotCancelableError</code> -32002 Task cannot be canceled <code>PushNotificationNotSupportedError</code> -32003 Push notifications not supported <code>UnsupportedOperationError</code> -32004 Operation not supported"},{"location":"api/#common-patterns","title":"Common Patterns","text":""},{"location":"api/#creating-a-message","title":"Creating a Message","text":"<pre><code># Text message\nmessage = A2A::Models::Message.text(\n  role: 'user',\n  text: 'Hello, agent!'\n)\n\n# Message with multiple parts\nmessage = A2A::Models::Message.new(\n  role: 'user',\n  parts: [\n    A2A::Models::TextPart.new(text: 'Please analyze this file:'),\n    A2A::Models::FilePart.new(\n      file: {\n        name: 'data.csv',\n        mime_type: 'text/csv',\n        bytes: Base64.strict_encode64(File.read('data.csv'))\n      }\n    )\n  ]\n)\n</code></pre>"},{"location":"api/#creating-a-task","title":"Creating a Task","text":"<pre><code>task = A2A::Models::Task.new(\n  id: SecureRandom.uuid,\n  status: {\n    state: 'submitted',\n    timestamp: Time.now.utc.iso8601\n  },\n  session_id: 'session-123'\n)\n</code></pre>"},{"location":"api/#working-with-artifacts","title":"Working with Artifacts","text":"<pre><code>artifact = A2A::Models::Artifact.new(\n  name: 'analysis-results',\n  description: 'Analysis of the provided data',\n  parts: [\n    A2A::Models::TextPart.new(text: 'Analysis complete.'),\n    A2A::Models::DataPart.new(\n      data: {\n        summary: { total: 100, processed: 95 }\n      }\n    )\n  ],\n  index: 0\n)\n</code></pre>"},{"location":"api/#serialization","title":"Serialization","text":"<p>All model classes support JSON serialization:</p> <pre><code># To hash\nhash = task.to_h\n\n# To JSON string\njson = task.to_json\n\n# From hash\ntask = A2A::Models::Task.from_hash(hash)\n</code></pre>"},{"location":"api/#version-information","title":"Version Information","text":"<pre><code># Get gem version\nA2A.version  # =&gt; \"0.1.0\" (or current version)\n</code></pre>"},{"location":"api/#module-structure","title":"Module Structure","text":"<pre><code>A2A\n\u251c\u2500\u2500 VERSION               # Gem version constant\n\u251c\u2500\u2500 Error                 # Error classes\n\u251c\u2500\u2500 Models                # Data models\n\u2502   \u251c\u2500\u2500 Part              # Base class for message/artifact parts\n\u2502   \u2502   \u251c\u2500\u2500 TextPart\n\u2502   \u2502   \u251c\u2500\u2500 FilePart\n\u2502   \u2502   \u2514\u2500\u2500 DataPart\n\u2502   \u251c\u2500\u2500 FileContent       # File representation\n\u2502   \u251c\u2500\u2500 Message           # Communication turns\n\u2502   \u251c\u2500\u2500 Artifact          # Agent outputs\n\u2502   \u251c\u2500\u2500 TaskState         # Task state enumeration\n\u2502   \u251c\u2500\u2500 TaskStatus        # Task status with state and message\n\u2502   \u251c\u2500\u2500 Task              # Central unit of work\n\u2502   \u251c\u2500\u2500 AgentCard         # Agent metadata\n\u2502   \u251c\u2500\u2500 AgentCapabilities # Agent capabilities\n\u2502   \u251c\u2500\u2500 AgentSkill        # Agent skill definition\n\u2502   \u251c\u2500\u2500 AgentProvider     # Provider information\n\u2502   \u251c\u2500\u2500 AgentAuthentication # Auth configuration\n\u2502   \u2514\u2500\u2500 PushNotificationConfig # Push notification settings\n\u251c\u2500\u2500 Protocol              # JSON-RPC protocol\n\u2502   \u251c\u2500\u2500 Request\n\u2502   \u251c\u2500\u2500 Response\n\u2502   \u2514\u2500\u2500 Error\n\u251c\u2500\u2500 Client                # Client implementation\n\u2502   \u2514\u2500\u2500 Base\n\u2514\u2500\u2500 Server                # Server implementation\n    \u2514\u2500\u2500 Base\n</code></pre>"},{"location":"api/#see-also","title":"See Also","text":"<ul> <li>Installation Guide</li> <li>Quick Start</li> <li>Getting Started Guide</li> <li>Architecture Documentation</li> <li>GitHub Repository</li> </ul> <p>Back to Documentation Home</p>"},{"location":"api/client/","title":"Client API Reference","text":"<p>Complete reference for the A2A client base class (<code>A2A::Client::Base</code>).</p>"},{"location":"api/client/#overview","title":"Overview","text":"<p>The Client layer provides a base class for implementing A2A clients that consume A2A services. Clients discover agents, send tasks, manage task lifecycle, and handle streaming responses.</p> <p>Source: <code>lib/a2a/client/base.rb</code></p>"},{"location":"api/client/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Class: A2A::Client::Base</li> <li>Constructor</li> <li>Instance Attributes</li> <li>Instance Methods<ul> <li>Agent Discovery</li> <li>Task Management</li> <li>Push Notifications</li> </ul> </li> <li>Implementation Guide</li> <li>Usage Examples</li> </ul>"},{"location":"api/client/#class-a2aclientbase","title":"Class: A2A::Client::Base","text":"<p>Base class for A2A clients. An A2A client consumes A2A services by sending requests to an A2A server.</p> <p>This is an abstract base class that defines the interface for A2A clients. Subclasses must implement the abstract methods to provide concrete HTTP/network implementations.</p>"},{"location":"api/client/#constructor","title":"Constructor","text":"<pre><code>A2A::Client::Base.new(agent_url)\n</code></pre> <p>Parameters:</p> <ul> <li><code>agent_url</code> (String, required) - The base URL of the agent's A2A endpoint</li> </ul> <p>Returns: <code>Client::Base</code> instance</p> <p>Example:</p> <pre><code>class MyA2AClient &lt; A2A::Client::Base\n  # Implementation here\nend\n\nclient = MyA2AClient.new('https://agent.example.com')\n</code></pre>"},{"location":"api/client/#instance-attributes","title":"Instance Attributes","text":""},{"location":"api/client/#agent_url","title":"<code>#agent_url</code>","text":"<p>Returns the agent's base URL.</p> <p>Returns: <code>String</code></p> <p>Example:</p> <pre><code>client.agent_url  # =&gt; \"https://agent.example.com\"\n</code></pre>"},{"location":"api/client/#agent_card","title":"<code>#agent_card</code>","text":"<p>Returns the discovered agent card (nil until <code>discover</code> is called).</p> <p>Returns: <code>A2A::Models::AgentCard</code> or <code>nil</code></p> <p>Example:</p> <pre><code>client.discover\nclient.agent_card  # =&gt; #&lt;A2A::Models::AgentCard:...&gt;\nclient.agent_card.name  # =&gt; \"DataAnalyzer\"\n</code></pre>"},{"location":"api/client/#instance-methods","title":"Instance Methods","text":""},{"location":"api/client/#agent-discovery","title":"Agent Discovery","text":""},{"location":"api/client/#discover","title":"<code>#discover</code>","text":"<p>Discover the agent by fetching its AgentCard from <code>/.well-known/agent.json</code>.</p> <p>Returns: Implementation-defined (typically the AgentCard)</p> <p>Raises: <code>NotImplementedError</code> - Subclasses must implement this method</p> <p>Example Implementation:</p> <pre><code>class MyA2AClient &lt; A2A::Client::Base\n  def discover\n    require 'net/http'\n    require 'json'\n\n    uri = URI.join(@agent_url, '/.well-known/agent.json')\n    response = Net::HTTP.get_response(uri)\n\n    if response.is_a?(Net::HTTPSuccess)\n      card_data = JSON.parse(response.body)\n      @agent_card = A2A::Models::AgentCard.from_hash(card_data)\n    else\n      raise \"Failed to discover agent: #{response.code}\"\n    end\n\n    @agent_card\n  end\nend\n</code></pre> <p>Usage:</p> <pre><code>client = MyA2AClient.new('https://agent.example.com')\nagent_card = client.discover\n\nputs \"Agent: #{agent_card.name}\"\nputs \"Version: #{agent_card.version}\"\nputs \"Capabilities:\"\nputs \"  - Streaming: #{agent_card.capabilities.streaming?}\"\nputs \"  - Push Notifications: #{agent_card.capabilities.push_notifications?}\"\n\nagent_card.skills.each do |skill|\n  puts \"Skill: #{skill.name} - #{skill.description}\"\nend\n</code></pre>"},{"location":"api/client/#task-management","title":"Task Management","text":""},{"location":"api/client/#send_tasktask_id-message-session_id-nil","title":"<code>#send_task(task_id:, message:, session_id: nil)</code>","text":"<p>Send a task to the agent.</p> <p>Parameters:</p> <ul> <li><code>task_id</code> (String, required) - Unique task identifier</li> <li><code>message</code> (A2A::Models::Message, required) - The message to send</li> <li><code>session_id</code> (String, optional) - Optional session ID for multi-turn conversations</li> </ul> <p>Returns: <code>A2A::Models::Task</code> - The task response</p> <p>Raises: <code>NotImplementedError</code> - Subclasses must implement this method</p> <p>Example Implementation:</p> <pre><code>class MyA2AClient &lt; A2A::Client::Base\n  def send_task(task_id:, message:, session_id: nil)\n    require 'net/http'\n    require 'json'\n\n    # Build request\n    request = A2A::Protocol::Request.new(\n      method: 'tasks/send',\n      params: {\n        taskId: task_id,\n        sessionId: session_id,\n        message: message.to_h\n      }.compact,\n      id: generate_request_id\n    )\n\n    # Send HTTP request\n    uri = URI(@agent_url)\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = (uri.scheme == 'https')\n\n    http_request = Net::HTTP::Post.new('/', 'Content-Type' =&gt; 'application/json')\n    http_request.body = request.to_json\n\n    http_response = http.request(http_request)\n\n    # Parse response\n    response = A2A::Protocol::Response.from_hash(JSON.parse(http_response.body))\n\n    if response.success?\n      A2A::Models::Task.from_hash(response.result)\n    else\n      raise \"Task failed: #{response.error}\"\n    end\n  end\n\n  private\n\n  def generate_request_id\n    @request_counter ||= 0\n    @request_counter += 1\n  end\nend\n</code></pre> <p>Usage:</p> <pre><code># Create a message\nmessage = A2A::Models::Message.text(\n  role: 'user',\n  text: 'Analyze this sales data and provide insights.'\n)\n\n# Send the task\ntask = client.send_task(\n  task_id: SecureRandom.uuid,\n  message: message,\n  session_id: 'session-123'\n)\n\nputs \"Task ID: #{task.id}\"\nputs \"State: #{task.state}\"\nputs \"Session: #{task.session_id}\"\n</code></pre>"},{"location":"api/client/#send_task_streamingtask_id-message-session_id-nil-block","title":"<code>#send_task_streaming(task_id:, message:, session_id: nil, &amp;block)</code>","text":"<p>Send a task with streaming support. The block is called with each event as the task progresses.</p> <p>Parameters:</p> <ul> <li><code>task_id</code> (String, required) - Unique task identifier</li> <li><code>message</code> (A2A::Models::Message, required) - The message to send</li> <li><code>session_id</code> (String, optional) - Optional session ID</li> <li><code>block</code> (Block, required) - Block that receives streaming events</li> </ul> <p>Yields: Event objects (task status updates and artifact updates)</p> <p>Returns: Implementation-defined</p> <p>Raises: <code>NotImplementedError</code> - Subclasses must implement this method</p> <p>Example Implementation:</p> <pre><code>class MyA2AClient &lt; A2A::Client::Base\n  def send_task_streaming(task_id:, message:, session_id: nil, &amp;block)\n    require 'net/http'\n    require 'json'\n\n    # Build request\n    request = A2A::Protocol::Request.new(\n      method: 'tasks/sendSubscribe',\n      params: {\n        taskId: task_id,\n        sessionId: session_id,\n        message: message.to_h\n      }.compact,\n      id: generate_request_id\n    )\n\n    # Send HTTP request with streaming\n    uri = URI(@agent_url)\n    Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https') do |http|\n      http_request = Net::HTTP::Post.new('/', 'Content-Type' =&gt; 'application/json')\n      http_request.body = request.to_json\n\n      http.request(http_request) do |response|\n        response.read_body do |chunk|\n          # Parse Server-Sent Events\n          chunk.split(\"\\n\\n\").each do |event_data|\n            next if event_data.strip.empty?\n\n            # Parse event\n            event = parse_sse_event(event_data)\n            yield event if event\n          end\n        end\n      end\n    end\n  end\n\n  private\n\n  def parse_sse_event(event_data)\n    lines = event_data.split(\"\\n\")\n    data_line = lines.find { |l| l.start_with?('data: ') }\n    return nil unless data_line\n\n    json_data = data_line.sub('data: ', '')\n    JSON.parse(json_data)\n  end\nend\n</code></pre> <p>Usage:</p> <pre><code>message = A2A::Models::Message.text(\n  role: 'user',\n  text: 'Generate a detailed report on Q4 sales.'\n)\n\nclient.send_task_streaming(\n  task_id: SecureRandom.uuid,\n  message: message\n) do |event|\n  case event['type']\n  when 'taskStatus'\n    status = A2A::Models::TaskStatus.from_hash(event['taskStatus'])\n    puts \"Status: #{status.state}\"\n\n  when 'artifactUpdate'\n    artifact = A2A::Models::Artifact.from_hash(event['artifact'])\n    puts \"Artifact: #{artifact.name}\"\n    artifact.parts.each do |part|\n      puts \"  #{part.type}: #{part.text}\" if part.is_a?(A2A::Models::TextPart)\n    end\n  end\nend\n</code></pre>"},{"location":"api/client/#get_tasktask_id","title":"<code>#get_task(task_id:)</code>","text":"<p>Get the current status of a task.</p> <p>Parameters:</p> <ul> <li><code>task_id</code> (String, required) - The task identifier</li> </ul> <p>Returns: <code>A2A::Models::Task</code> - The task</p> <p>Raises: <code>NotImplementedError</code> - Subclasses must implement this method</p> <p>Example Implementation:</p> <pre><code>class MyA2AClient &lt; A2A::Client::Base\n  def get_task(task_id:)\n    require 'net/http'\n    require 'json'\n\n    request = A2A::Protocol::Request.new(\n      method: 'tasks/get',\n      params: { taskId: task_id },\n      id: generate_request_id\n    )\n\n    uri = URI(@agent_url)\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = (uri.scheme == 'https')\n\n    http_request = Net::HTTP::Post.new('/', 'Content-Type' =&gt; 'application/json')\n    http_request.body = request.to_json\n\n    http_response = http.request(http_request)\n    response = A2A::Protocol::Response.from_hash(JSON.parse(http_response.body))\n\n    if response.success?\n      A2A::Models::Task.from_hash(response.result)\n    else\n      raise A2A::TaskNotFoundError.new if response.error['code'] == -32001\n      raise \"Failed to get task: #{response.error}\"\n    end\n  end\nend\n</code></pre> <p>Usage:</p> <pre><code>task = client.get_task(task_id: 'task-123')\n\nputs \"Task: #{task.id}\"\nputs \"State: #{task.state}\"\nputs \"Submitted at: #{task.status.timestamp}\"\n\nif task.state.completed?\n  puts \"Task completed!\"\n  task.artifacts.each do |artifact|\n    puts \"Artifact: #{artifact.name}\"\n  end\nelsif task.state.failed?\n  puts \"Task failed: #{task.status.message}\"\nend\n</code></pre>"},{"location":"api/client/#cancel_tasktask_id","title":"<code>#cancel_task(task_id:)</code>","text":"<p>Cancel a task.</p> <p>Parameters:</p> <ul> <li><code>task_id</code> (String, required) - The task identifier</li> </ul> <p>Returns: <code>A2A::Models::Task</code> - The canceled task</p> <p>Raises:   - <code>NotImplementedError</code> - Subclasses must implement this method   - <code>A2A::TaskNotCancelableError</code> - If the task cannot be canceled</p> <p>Example Implementation:</p> <pre><code>class MyA2AClient &lt; A2A::Client::Base\n  def cancel_task(task_id:)\n    require 'net/http'\n    require 'json'\n\n    request = A2A::Protocol::Request.new(\n      method: 'tasks/cancel',\n      params: { taskId: task_id },\n      id: generate_request_id\n    )\n\n    uri = URI(@agent_url)\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = (uri.scheme == 'https')\n\n    http_request = Net::HTTP::Post.new('/', 'Content-Type' =&gt; 'application/json')\n    http_request.body = request.to_json\n\n    http_response = http.request(http_request)\n    response = A2A::Protocol::Response.from_hash(JSON.parse(http_response.body))\n\n    if response.success?\n      A2A::Models::Task.from_hash(response.result)\n    else\n      case response.error['code']\n      when -32001\n        raise A2A::TaskNotFoundError.new\n      when -32002\n        raise A2A::TaskNotCancelableError.new\n      else\n        raise \"Failed to cancel task: #{response.error}\"\n      end\n    end\n  end\nend\n</code></pre> <p>Usage:</p> <pre><code>begin\n  task = client.cancel_task(task_id: 'task-123')\n  puts \"Task canceled: #{task.state.canceled?}\"\nrescue A2A::TaskNotCancelableError\n  puts \"Task cannot be canceled (already completed or failed)\"\nrescue A2A::TaskNotFoundError\n  puts \"Task not found\"\nend\n</code></pre>"},{"location":"api/client/#push-notifications","title":"Push Notifications","text":""},{"location":"api/client/#set_push_notificationtask_id-config","title":"<code>#set_push_notification(task_id:, config:)</code>","text":"<p>Set push notification configuration for a task.</p> <p>Parameters:</p> <ul> <li><code>task_id</code> (String, required) - The task identifier</li> <li><code>config</code> (A2A::Models::PushNotificationConfig, required) - The push notification configuration</li> </ul> <p>Returns: Implementation-defined</p> <p>Raises:   - <code>NotImplementedError</code> - Subclasses must implement this method   - <code>A2A::PushNotificationNotSupportedError</code> - If push notifications are not supported</p> <p>Example Implementation:</p> <pre><code>class MyA2AClient &lt; A2A::Client::Base\n  def set_push_notification(task_id:, config:)\n    require 'net/http'\n    require 'json'\n\n    request = A2A::Protocol::Request.new(\n      method: 'tasks/pushNotification/set',\n      params: {\n        taskId: task_id,\n        config: config.to_h\n      },\n      id: generate_request_id\n    )\n\n    uri = URI(@agent_url)\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = (uri.scheme == 'https')\n\n    http_request = Net::HTTP::Post.new('/', 'Content-Type' =&gt; 'application/json')\n    http_request.body = request.to_json\n\n    http_response = http.request(http_request)\n    response = A2A::Protocol::Response.from_hash(JSON.parse(http_response.body))\n\n    unless response.success?\n      raise A2A::PushNotificationNotSupportedError.new if response.error['code'] == -32003\n      raise \"Failed to set push notification: #{response.error}\"\n    end\n\n    true\n  end\nend\n</code></pre> <p>Usage:</p> <pre><code>config = A2A::Models::PushNotificationConfig.new(\n  url: 'https://myclient.example.com/notifications',\n  token: 'secret-token-123'\n)\n\nbegin\n  client.set_push_notification(task_id: 'task-123', config: config)\n  puts \"Push notifications configured\"\nrescue A2A::PushNotificationNotSupportedError\n  puts \"Agent doesn't support push notifications\"\nend\n</code></pre>"},{"location":"api/client/#get_push_notificationtask_id","title":"<code>#get_push_notification(task_id:)</code>","text":"<p>Get push notification configuration for a task.</p> <p>Parameters:</p> <ul> <li><code>task_id</code> (String, required) - The task identifier</li> </ul> <p>Returns: <code>A2A::Models::PushNotificationConfig</code> - The configuration</p> <p>Raises:   - <code>NotImplementedError</code> - Subclasses must implement this method   - <code>A2A::PushNotificationNotSupportedError</code> - If push notifications are not supported</p> <p>Example Implementation:</p> <pre><code>class MyA2AClient &lt; A2A::Client::Base\n  def get_push_notification(task_id:)\n    require 'net/http'\n    require 'json'\n\n    request = A2A::Protocol::Request.new(\n      method: 'tasks/pushNotification/get',\n      params: { taskId: task_id },\n      id: generate_request_id\n    )\n\n    uri = URI(@agent_url)\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = (uri.scheme == 'https')\n\n    http_request = Net::HTTP::Post.new('/', 'Content-Type' =&gt; 'application/json')\n    http_request.body = request.to_json\n\n    http_response = http.request(http_request)\n    response = A2A::Protocol::Response.from_hash(JSON.parse(http_response.body))\n\n    if response.success?\n      A2A::Models::PushNotificationConfig.from_hash(response.result)\n    else\n      raise A2A::PushNotificationNotSupportedError.new if response.error['code'] == -32003\n      raise \"Failed to get push notification config: #{response.error}\"\n    end\n  end\nend\n</code></pre> <p>Usage:</p> <pre><code>begin\n  config = client.get_push_notification(task_id: 'task-123')\n  puts \"Notification URL: #{config.url}\"\n  puts \"Token configured: #{!config.token.nil?}\"\nrescue A2A::PushNotificationNotSupportedError\n  puts \"Push notifications not supported\"\nend\n</code></pre>"},{"location":"api/client/#implementation-guide","title":"Implementation Guide","text":""},{"location":"api/client/#creating-a-custom-client","title":"Creating a Custom Client","text":"<p>To create a working A2A client, you must:</p> <ol> <li>Subclass <code>A2A::Client::Base</code></li> <li>Implement all abstract methods</li> <li>Handle HTTP/network communication</li> <li>Parse JSON-RPC requests and responses</li> <li>Handle errors appropriately</li> </ol>"},{"location":"api/client/#minimal-implementation","title":"Minimal Implementation","text":"<pre><code>require 'a2a'\nrequire 'net/http'\nrequire 'json'\n\nclass SimpleA2AClient &lt; A2A::Client::Base\n  def discover\n    uri = URI.join(@agent_url, '/.well-known/agent.json')\n    response = Net::HTTP.get_response(uri)\n    @agent_card = A2A::Models::AgentCard.from_hash(JSON.parse(response.body))\n  end\n\n  def send_task(task_id:, message:, session_id: nil)\n    response = make_request('tasks/send', {\n      taskId: task_id,\n      sessionId: session_id,\n      message: message.to_h\n    }.compact)\n\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def send_task_streaming(task_id:, message:, session_id: nil, &amp;block)\n    raise A2A::UnsupportedOperationError.new\n  end\n\n  def get_task(task_id:)\n    response = make_request('tasks/get', { taskId: task_id })\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def cancel_task(task_id:)\n    response = make_request('tasks/cancel', { taskId: task_id })\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def set_push_notification(task_id:, config:)\n    make_request('tasks/pushNotification/set', {\n      taskId: task_id,\n      config: config.to_h\n    })\n    true\n  end\n\n  def get_push_notification(task_id:)\n    response = make_request('tasks/pushNotification/get', { taskId: task_id })\n    A2A::Models::PushNotificationConfig.from_hash(response.result)\n  end\n\n  private\n\n  def make_request(method, params)\n    request = A2A::Protocol::Request.new(\n      method: method,\n      params: params,\n      id: next_id\n    )\n\n    uri = URI(@agent_url)\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = (uri.scheme == 'https')\n\n    http_request = Net::HTTP::Post.new('/', 'Content-Type' =&gt; 'application/json')\n    http_request.body = request.to_json\n\n    http_response = http.request(http_request)\n    response = A2A::Protocol::Response.from_hash(JSON.parse(http_response.body))\n\n    raise_error(response.error) unless response.success?\n\n    response\n  end\n\n  def next_id\n    @counter ||= 0\n    @counter += 1\n  end\n\n  def raise_error(error)\n    case error['code']\n    when -32001 then raise A2A::TaskNotFoundError.new\n    when -32002 then raise A2A::TaskNotCancelableError.new\n    when -32003 then raise A2A::PushNotificationNotSupportedError.new\n    when -32004 then raise A2A::UnsupportedOperationError.new\n    else raise A2A::Error, error['message']\n    end\n  end\nend\n</code></pre>"},{"location":"api/client/#usage-examples","title":"Usage Examples","text":""},{"location":"api/client/#complete-workflow","title":"Complete Workflow","text":"<pre><code># Initialize client\nclient = SimpleA2AClient.new('https://agent.example.com')\n\n# Discover agent capabilities\nagent_card = client.discover\nputs \"Connected to: #{agent_card.name} v#{agent_card.version}\"\nputs \"Supports streaming: #{agent_card.capabilities.streaming?}\"\n\n# Check agent skills\nskill = agent_card.skills.first\nputs \"First skill: #{skill.name}\"\n\n# Send a task\nmessage = A2A::Models::Message.text(\n  role: 'user',\n  text: 'Analyze the attached sales data'\n)\n\ntask_id = SecureRandom.uuid\ntask = client.send_task(task_id: task_id, message: message)\n\n# Poll for completion\nloop do\n  sleep 2\n  task = client.get_task(task_id: task_id)\n\n  puts \"Task state: #{task.state}\"\n\n  break if task.state.terminal?\nend\n\n# Get results\nif task.state.completed?\n  puts \"Task completed successfully!\"\n  task.artifacts.each do |artifact|\n    puts \"Artifact: #{artifact.name}\"\n    artifact.parts.each do |part|\n      puts part.text if part.is_a?(A2A::Models::TextPart)\n    end\n  end\nelse\n  puts \"Task failed: #{task.status.message}\"\nend\n</code></pre>"},{"location":"api/client/#multi-turn-conversation","title":"Multi-turn Conversation","text":"<pre><code>session_id = SecureRandom.uuid\n\n# First turn\nmessage1 = A2A::Models::Message.text(\n  role: 'user',\n  text: 'What were our top 5 products last quarter?'\n)\n\ntask1 = client.send_task(\n  task_id: SecureRandom.uuid,\n  message: message1,\n  session_id: session_id\n)\n\n# Wait for completion...\n\n# Second turn (follow-up question)\nmessage2 = A2A::Models::Message.text(\n  role: 'user',\n  text: 'Can you break down the sales by region for those products?'\n)\n\ntask2 = client.send_task(\n  task_id: SecureRandom.uuid,\n  message: message2,\n  session_id: session_id  # Same session\n)\n</code></pre>"},{"location":"api/client/#see-also","title":"See Also","text":"<ul> <li>API Overview</li> <li>Models Reference</li> <li>Protocol Reference</li> <li>Server Reference</li> <li>Quick Start Guide</li> <li>Client Examples</li> </ul> <p>Back to API Reference | Back to Documentation Home</p>"},{"location":"api/models/","title":"Models API Reference","text":"<p>Complete reference for all model classes in the A2A gem (<code>A2A::Models</code> namespace).</p>"},{"location":"api/models/#overview","title":"Overview","text":"<p>The Models layer provides data structures representing all entities in the A2A protocol. All models support JSON serialization and deserialization for protocol communication.</p>"},{"location":"api/models/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Task Management</li> <li>Task</li> <li>TaskStatus</li> <li>TaskState</li> <li>Communication</li> <li>Message</li> <li>Artifact</li> <li>Parts</li> <li>Part</li> <li>TextPart</li> <li>FilePart</li> <li>DataPart</li> <li>FileContent</li> <li>Agent Metadata</li> <li>AgentCard</li> <li>AgentCapabilities</li> <li>AgentSkill</li> <li>AgentProvider</li> <li>AgentAuthentication</li> <li>Configuration</li> <li>PushNotificationConfig</li> </ul>"},{"location":"api/models/#task-management","title":"Task Management","text":""},{"location":"api/models/#task","title":"Task","text":"<p>Represents a task in the A2A protocol - the central unit of work with a unique ID that progresses through various states.</p> <p>Source: <code>lib/a2a/models/task.rb</code></p>"},{"location":"api/models/#constructor","title":"Constructor","text":"<pre><code>A2A::Models::Task.new(\n  id:,\n  status:,\n  session_id: nil,\n  artifacts: nil,\n  metadata: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> (String, required) - Unique task identifier</li> <li><code>status</code> (TaskStatus or Hash, required) - Task status object or hash</li> <li><code>session_id</code> (String, optional) - Session identifier for multi-turn conversations</li> <li><code>artifacts</code> (Array, optional) - Array of artifacts produced by the task <li><code>metadata</code> (Hash, optional) - Additional metadata</li> <p>Returns: <code>Task</code> instance</p> <p>Example:</p> <pre><code>task = A2A::Models::Task.new(\n  id: SecureRandom.uuid,\n  status: A2A::Models::TaskStatus.new(state: 'submitted'),\n  session_id: 'session-abc-123',\n  artifacts: [],\n  metadata: { priority: 'high' }\n)\n</code></pre>"},{"location":"api/models/#instance-methods","title":"Instance Methods","text":""},{"location":"api/models/#id","title":"<code>#id</code>","text":"<p>Returns the unique task identifier.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#session_id","title":"<code>#session_id</code>","text":"<p>Returns the session identifier.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#status","title":"<code>#status</code>","text":"<p>Returns the task status.</p> <p>Returns: <code>TaskStatus</code></p>"},{"location":"api/models/#state","title":"<code>#state</code>","text":"<p>Returns the current state of the task (convenience method).</p> <p>Returns: <code>TaskState</code></p> <pre><code>task.state  # =&gt; #&lt;A2A::Models::TaskState:... @value=\"submitted\"&gt;\n</code></pre>"},{"location":"api/models/#artifacts","title":"<code>#artifacts</code>","text":"<p>Returns the array of artifacts.</p> <p>Returns: <code>Array&lt;Artifact&gt;</code> or <code>nil</code></p>"},{"location":"api/models/#metadata","title":"<code>#metadata</code>","text":"<p>Returns additional metadata.</p> <p>Returns: <code>Hash</code> or <code>nil</code></p>"},{"location":"api/models/#to_h","title":"<code>#to_h</code>","text":"<p>Converts the task to a hash representation.</p> <p>Returns: <code>Hash</code></p> <pre><code>task.to_h\n# =&gt; {\n#   id: \"task-123\",\n#   sessionId: \"session-abc\",\n#   status: { state: \"submitted\", timestamp: \"2025-01-15T10:30:00Z\" },\n#   artifacts: [...],\n#   metadata: { ... }\n# }\n</code></pre>"},{"location":"api/models/#to_jsonargs","title":"<code>#to_json(*args)</code>","text":"<p>Converts the task to a JSON string.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a Task instance from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash) - Hash representation (supports both symbol and string keys)</li> </ul> <p>Returns: <code>Task</code></p> <p>Example:</p> <pre><code>task = A2A::Models::Task.from_hash({\n  'id' =&gt; 'task-456',\n  'status' =&gt; { 'state' =&gt; 'working' }\n})\n</code></pre>"},{"location":"api/models/#taskstatus","title":"TaskStatus","text":"<p>Represents the status of a task, including its state, optional message, and timestamp.</p> <p>Source: <code>lib/a2a/models/task_status.rb</code></p>"},{"location":"api/models/#constructor_1","title":"Constructor","text":"<pre><code>A2A::Models::TaskStatus.new(\n  state:,\n  message: nil,\n  timestamp: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>state</code> (TaskState, String, required) - Task state (will be converted to TaskState if string)</li> <li><code>message</code> (Message, Hash, optional) - Optional message providing context</li> <li><code>timestamp</code> (String, optional) - ISO8601 timestamp (defaults to current UTC time)</li> </ul> <p>Returns: <code>TaskStatus</code> instance</p> <p>Example:</p> <pre><code>status = A2A::Models::TaskStatus.new(\n  state: 'working',\n  message: A2A::Models::Message.text(role: 'agent', text: 'Processing your request...'),\n  timestamp: Time.now.utc.iso8601\n)\n</code></pre>"},{"location":"api/models/#instance-methods_1","title":"Instance Methods","text":""},{"location":"api/models/#state_1","title":"<code>#state</code>","text":"<p>Returns the task state.</p> <p>Returns: <code>TaskState</code></p>"},{"location":"api/models/#message","title":"<code>#message</code>","text":"<p>Returns the optional status message.</p> <p>Returns: <code>Message</code> or <code>nil</code></p>"},{"location":"api/models/#timestamp","title":"<code>#timestamp</code>","text":"<p>Returns the ISO8601 timestamp.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#to_h_1","title":"<code>#to_h</code>","text":"<p>Converts the status to a hash.</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_1","title":"<code>#to_json(*args)</code>","text":"<p>Converts the status to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_1","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_1","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a TaskStatus from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>TaskStatus</code></p>"},{"location":"api/models/#taskstate","title":"TaskState","text":"<p>Represents the state of a task with validation and convenience methods.</p> <p>Source: <code>lib/a2a/models/task_state.rb</code></p>"},{"location":"api/models/#valid-states","title":"Valid States","text":"<ul> <li><code>submitted</code> - Task has been submitted</li> <li><code>working</code> - Task is being processed</li> <li><code>input-required</code> - Task requires additional input</li> <li><code>completed</code> - Task has completed successfully</li> <li><code>canceled</code> - Task was canceled</li> <li><code>failed</code> - Task failed</li> <li><code>unknown</code> - State is unknown</li> </ul>"},{"location":"api/models/#constructor_2","title":"Constructor","text":"<pre><code>A2A::Models::TaskState.new(value)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code> (String, required) - State value (must be one of the valid states)</li> </ul> <p>Raises: <code>ArgumentError</code> if value is not a valid state</p> <p>Returns: <code>TaskState</code> instance</p> <p>Example:</p> <pre><code>state = A2A::Models::TaskState.new('working')\n</code></pre>"},{"location":"api/models/#instance-methods_2","title":"Instance Methods","text":""},{"location":"api/models/#value","title":"<code>#value</code>","text":"<p>Returns the state value.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#to_s","title":"<code>#to_s</code>","text":"<p>Returns the state as a string.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#to_jsonargs_2","title":"<code>#to_json(*args)</code>","text":"<p>Returns the state as JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#other","title":"<code>#==(other)</code>","text":"<p>Compares two TaskState objects.</p> <p>Returns: <code>Boolean</code></p>"},{"location":"api/models/#state-check-methods","title":"State Check Methods","text":"<p>All return <code>Boolean</code>:</p> <ul> <li><code>#submitted?</code> - Returns true if state is 'submitted'</li> <li><code>#working?</code> - Returns true if state is 'working'</li> <li><code>#input_required?</code> - Returns true if state is 'input-required'</li> <li><code>#completed?</code> - Returns true if state is 'completed'</li> <li><code>#canceled?</code> - Returns true if state is 'canceled'</li> <li><code>#failed?</code> - Returns true if state is 'failed'</li> <li><code>#unknown?</code> - Returns true if state is 'unknown'</li> <li><code>#terminal?</code> - Returns true if state is completed, canceled, or failed</li> </ul> <p>Example:</p> <pre><code>state = A2A::Models::TaskState.new('completed')\nstate.completed?  # =&gt; true\nstate.terminal?   # =&gt; true\nstate.working?    # =&gt; false\n</code></pre>"},{"location":"api/models/#communication","title":"Communication","text":""},{"location":"api/models/#message_1","title":"Message","text":"<p>Represents communication turns between the client (role: \"user\") and the agent (role: \"agent\"). Messages contain Parts.</p> <p>Source: <code>lib/a2a/models/message.rb</code></p>"},{"location":"api/models/#valid-roles","title":"Valid Roles","text":"<ul> <li><code>user</code> - Message from the user/client</li> <li><code>agent</code> - Message from the agent</li> </ul>"},{"location":"api/models/#constructor_3","title":"Constructor","text":"<pre><code>A2A::Models::Message.new(\n  role:,\n  parts:,\n  metadata: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>role</code> (String, required) - Message role ('user' or 'agent')</li> <li><code>parts</code> (Array, required) - Array of message parts <li><code>metadata</code> (Hash, optional) - Additional metadata</li> <p>Raises: <code>ArgumentError</code> if role is invalid</p> <p>Returns: <code>Message</code> instance</p> <p>Example:</p> <pre><code>message = A2A::Models::Message.new(\n  role: 'user',\n  parts: [\n    A2A::Models::TextPart.new(text: 'Hello!'),\n    A2A::Models::TextPart.new(text: 'How are you?')\n  ]\n)\n</code></pre>"},{"location":"api/models/#instance-methods_3","title":"Instance Methods","text":""},{"location":"api/models/#role","title":"<code>#role</code>","text":"<p>Returns the message role.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#parts","title":"<code>#parts</code>","text":"<p>Returns the array of parts.</p> <p>Returns: <code>Array&lt;Part&gt;</code></p>"},{"location":"api/models/#metadata_1","title":"<code>#metadata</code>","text":"<p>Returns optional metadata.</p> <p>Returns: <code>Hash</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_2","title":"<code>#to_h</code>","text":"<p>Converts to hash.</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_3","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_2","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_2","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a Message from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>Message</code></p>"},{"location":"api/models/#textrole-text-metadata-nil","title":"<code>.text(role:, text:, metadata: nil)</code>","text":"<p>Convenience constructor for simple text messages.</p> <p>Parameters:</p> <ul> <li><code>role</code> (String, required) - Message role</li> <li><code>text</code> (String, required) - Text content</li> <li><code>metadata</code> (Hash, optional) - Additional metadata</li> </ul> <p>Returns: <code>Message</code></p> <p>Example:</p> <pre><code>message = A2A::Models::Message.text(\n  role: 'user',\n  text: 'Analyze this data for trends.'\n)\n</code></pre>"},{"location":"api/models/#artifact","title":"Artifact","text":"<p>Represents outputs generated by the agent during a task. Artifacts contain Parts (text, file, or data).</p> <p>Source: <code>lib/a2a/models/artifact.rb</code></p>"},{"location":"api/models/#constructor_4","title":"Constructor","text":"<pre><code>A2A::Models::Artifact.new(\n  parts:,\n  name: nil,\n  description: nil,\n  index: 0,\n  append: nil,\n  last_chunk: nil,\n  metadata: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>parts</code> (Array, required) - Array of artifact parts <li><code>name</code> (String, optional) - Artifact name</li> <li><code>description</code> (String, optional) - Artifact description</li> <li><code>index</code> (Integer, optional) - Artifact index (default: 0)</li> <li><code>append</code> (Boolean, optional) - Whether to append to existing artifact</li> <li><code>last_chunk</code> (Boolean, optional) - Indicates if this is the last chunk in streaming</li> <li><code>metadata</code> (Hash, optional) - Additional metadata</li> <p>Returns: <code>Artifact</code> instance</p> <p>Example:</p> <pre><code>artifact = A2A::Models::Artifact.new(\n  name: 'analysis-report',\n  description: 'Comprehensive data analysis',\n  parts: [\n    A2A::Models::TextPart.new(text: '## Summary\\n\\nAnalysis complete.'),\n    A2A::Models::DataPart.new(data: { total_records: 1000, errors: 5 })\n  ],\n  index: 0\n)\n</code></pre>"},{"location":"api/models/#instance-methods_4","title":"Instance Methods","text":""},{"location":"api/models/#name","title":"<code>#name</code>","text":"<p>Returns the artifact name.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#description","title":"<code>#description</code>","text":"<p>Returns the artifact description.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#parts_1","title":"<code>#parts</code>","text":"<p>Returns the array of parts.</p> <p>Returns: <code>Array&lt;Part&gt;</code></p>"},{"location":"api/models/#index","title":"<code>#index</code>","text":"<p>Returns the artifact index.</p> <p>Returns: <code>Integer</code></p>"},{"location":"api/models/#append","title":"<code>#append</code>","text":"<p>Returns the append flag.</p> <p>Returns: <code>Boolean</code> or <code>nil</code></p>"},{"location":"api/models/#last_chunk","title":"<code>#last_chunk</code>","text":"<p>Returns whether this is the last chunk.</p> <p>Returns: <code>Boolean</code> or <code>nil</code></p>"},{"location":"api/models/#metadata_2","title":"<code>#metadata</code>","text":"<p>Returns metadata.</p> <p>Returns: <code>Hash</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_3","title":"<code>#to_h</code>","text":"<p>Converts to hash (uses camelCase for JSON keys).</p> <p>Returns: <code>Hash</code></p> <pre><code>artifact.to_h\n# =&gt; {\n#   name: \"report\",\n#   description: \"...\",\n#   parts: [...],\n#   index: 0,\n#   lastChunk: true\n# }\n</code></pre>"},{"location":"api/models/#to_jsonargs_4","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_3","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_3","title":"<code>.from_hash(hash)</code>","text":"<p>Creates an Artifact from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>Artifact</code></p>"},{"location":"api/models/#parts_2","title":"Parts","text":""},{"location":"api/models/#part-base-class","title":"Part (Base Class)","text":"<p>Base class for message and artifact parts. Parts can be TextPart, FilePart, or DataPart.</p> <p>Source: <code>lib/a2a/models/part.rb</code></p>"},{"location":"api/models/#constructor_5","title":"Constructor","text":"<pre><code>A2A::Models::Part.new(metadata: nil)\n</code></pre> <p>Parameters:</p> <ul> <li><code>metadata</code> (Hash, optional) - Part metadata</li> </ul> <p>Note: This is an abstract base class. Use subclasses instead.</p>"},{"location":"api/models/#instance-methods_5","title":"Instance Methods","text":""},{"location":"api/models/#metadata_3","title":"<code>#metadata</code>","text":"<p>Returns part metadata.</p> <p>Returns: <code>Hash</code> or <code>nil</code></p>"},{"location":"api/models/#type","title":"<code>#type</code>","text":"<p>Returns the part type.</p> <p>Returns: <code>String</code></p> <p>Raises: <code>NotImplementedError</code> (must be implemented by subclasses)</p>"},{"location":"api/models/#to_h_4","title":"<code>#to_h</code>","text":"<p>Converts to hash.</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_5","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_4","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_4","title":"<code>.from_hash(hash)</code>","text":"<p>Factory method to create the appropriate Part subclass from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash) - Must include 'type' key ('text', 'file', or 'data')</li> </ul> <p>Returns: <code>TextPart</code>, <code>FilePart</code>, or <code>DataPart</code></p> <p>Raises: <code>ArgumentError</code> if type is unknown</p> <p>Example:</p> <pre><code>part = A2A::Models::Part.from_hash({ type: 'text', text: 'Hello!' })\n# =&gt; #&lt;A2A::Models::TextPart:...&gt;\n</code></pre>"},{"location":"api/models/#textpart","title":"TextPart","text":"<p>Represents a text part in a message or artifact.</p> <p>Source: <code>lib/a2a/models/text_part.rb</code></p>"},{"location":"api/models/#constructor_6","title":"Constructor","text":"<pre><code>A2A::Models::TextPart.new(text:, metadata: nil)\n</code></pre> <p>Parameters:</p> <ul> <li><code>text</code> (String, required) - Text content</li> <li><code>metadata</code> (Hash, optional) - Part metadata</li> </ul> <p>Returns: <code>TextPart</code> instance</p> <p>Example:</p> <pre><code>part = A2A::Models::TextPart.new(\n  text: 'This is the text content.',\n  metadata: { language: 'en' }\n)\n</code></pre>"},{"location":"api/models/#instance-methods_6","title":"Instance Methods","text":""},{"location":"api/models/#text","title":"<code>#text</code>","text":"<p>Returns the text content.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#type_1","title":"<code>#type</code>","text":"<p>Returns 'text'.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#metadata_4","title":"<code>#metadata</code>","text":"<p>Returns metadata (inherited from Part).</p> <p>Returns: <code>Hash</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_5","title":"<code>#to_h</code>","text":"<p>Converts to hash.</p> <p>Returns: <code>Hash</code></p> <pre><code>part.to_h\n# =&gt; { type: 'text', text: 'content', metadata: {...} }\n</code></pre>"},{"location":"api/models/#to_jsonargs_6","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_5","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_5","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a TextPart from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>TextPart</code></p>"},{"location":"api/models/#filepart","title":"FilePart","text":"<p>Represents a file part in a message or artifact.</p> <p>Source: <code>lib/a2a/models/file_part.rb</code></p>"},{"location":"api/models/#constructor_7","title":"Constructor","text":"<pre><code>A2A::Models::FilePart.new(file:, metadata: nil)\n</code></pre> <p>Parameters:</p> <ul> <li><code>file</code> (FileContent or Hash, required) - File content object or hash</li> <li><code>metadata</code> (Hash, optional) - Part metadata</li> </ul> <p>Returns: <code>FilePart</code> instance</p> <p>Example:</p> <pre><code>part = A2A::Models::FilePart.new(\n  file: {\n    name: 'report.pdf',\n    mime_type: 'application/pdf',\n    bytes: Base64.strict_encode64(file_data)\n  }\n)\n</code></pre>"},{"location":"api/models/#instance-methods_7","title":"Instance Methods","text":""},{"location":"api/models/#file","title":"<code>#file</code>","text":"<p>Returns the file content.</p> <p>Returns: <code>FileContent</code></p>"},{"location":"api/models/#type_2","title":"<code>#type</code>","text":"<p>Returns 'file'.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#metadata_5","title":"<code>#metadata</code>","text":"<p>Returns metadata.</p> <p>Returns: <code>Hash</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_6","title":"<code>#to_h</code>","text":"<p>Converts to hash.</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_7","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_6","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_6","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a FilePart from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>FilePart</code></p>"},{"location":"api/models/#datapart","title":"DataPart","text":"<p>Represents a structured data part in a message or artifact. Used for forms and other structured JSON data.</p> <p>Source: <code>lib/a2a/models/data_part.rb</code></p>"},{"location":"api/models/#constructor_8","title":"Constructor","text":"<pre><code>A2A::Models::DataPart.new(data:, metadata: nil)\n</code></pre> <p>Parameters:</p> <ul> <li><code>data</code> (Hash or Array, required) - Structured data</li> <li><code>metadata</code> (Hash, optional) - Part metadata</li> </ul> <p>Returns: <code>DataPart</code> instance</p> <p>Example:</p> <pre><code>part = A2A::Models::DataPart.new(\n  data: {\n    form: {\n      name: 'John Doe',\n      email: 'john@example.com',\n      preferences: ['email', 'sms']\n    }\n  }\n)\n</code></pre>"},{"location":"api/models/#instance-methods_8","title":"Instance Methods","text":""},{"location":"api/models/#data","title":"<code>#data</code>","text":"<p>Returns the structured data.</p> <p>Returns: <code>Hash</code> or <code>Array</code></p>"},{"location":"api/models/#type_3","title":"<code>#type</code>","text":"<p>Returns 'data'.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#metadata_6","title":"<code>#metadata</code>","text":"<p>Returns metadata.</p> <p>Returns: <code>Hash</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_7","title":"<code>#to_h</code>","text":"<p>Converts to hash.</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_8","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_7","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_7","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a DataPart from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>DataPart</code></p>"},{"location":"api/models/#filecontent","title":"FileContent","text":"<p>Represents the content of a file, either as base64 encoded bytes or a URI. Ensures that either 'bytes' or 'uri' is provided, but not both.</p> <p>Source: <code>lib/a2a/models/file_content.rb</code></p>"},{"location":"api/models/#constructor_9","title":"Constructor","text":"<pre><code>A2A::Models::FileContent.new(\n  name: nil,\n  mime_type: nil,\n  bytes: nil,\n  uri: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> (String, optional) - File name</li> <li><code>mime_type</code> (String, optional) - MIME type</li> <li><code>bytes</code> (String, optional) - Base64 encoded file content</li> <li><code>uri</code> (String, optional) - URI to the file</li> </ul> <p>Raises: <code>ArgumentError</code> if:   - Neither bytes nor uri is provided   - Both bytes and uri are provided</p> <p>Returns: <code>FileContent</code> instance</p> <p>Example:</p> <pre><code># Using bytes\nfile = A2A::Models::FileContent.new(\n  name: 'data.csv',\n  mime_type: 'text/csv',\n  bytes: Base64.strict_encode64(csv_data)\n)\n\n# Using URI\nfile = A2A::Models::FileContent.new(\n  name: 'image.png',\n  mime_type: 'image/png',\n  uri: 'https://example.com/image.png'\n)\n</code></pre>"},{"location":"api/models/#instance-methods_9","title":"Instance Methods","text":""},{"location":"api/models/#name_1","title":"<code>#name</code>","text":"<p>Returns the file name.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#mime_type","title":"<code>#mime_type</code>","text":"<p>Returns the MIME type.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#bytes","title":"<code>#bytes</code>","text":"<p>Returns the base64 encoded bytes.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#uri","title":"<code>#uri</code>","text":"<p>Returns the file URI.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_8","title":"<code>#to_h</code>","text":"<p>Converts to hash (uses camelCase for JSON).</p> <p>Returns: <code>Hash</code></p> <pre><code>file.to_h\n# =&gt; { name: 'file.txt', mimeType: 'text/plain', bytes: '...' }\n</code></pre>"},{"location":"api/models/#to_jsonargs_9","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_8","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_8","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a FileContent from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>FileContent</code></p>"},{"location":"api/models/#agent-metadata","title":"Agent Metadata","text":""},{"location":"api/models/#agentcard","title":"AgentCard","text":"<p>Represents an agent's metadata and capabilities. Usually served at <code>/.well-known/agent.json</code>.</p> <p>Source: <code>lib/a2a/models/agent_card.rb</code></p>"},{"location":"api/models/#constructor_10","title":"Constructor","text":"<pre><code>A2A::Models::AgentCard.new(\n  name:,\n  url:,\n  version:,\n  capabilities:,\n  skills:,\n  description: nil,\n  provider: nil,\n  documentation_url: nil,\n  authentication: nil,\n  default_input_modes: ['text'],\n  default_output_modes: ['text']\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> (String, required) - Agent name</li> <li><code>url</code> (String, required) - Agent URL</li> <li><code>version</code> (String, required) - Agent version</li> <li><code>capabilities</code> (AgentCapabilities or Hash, required) - Agent capabilities</li> <li><code>skills</code> (Array or Array, required) - Agent skills <li><code>description</code> (String, optional) - Agent description</li> <li><code>provider</code> (AgentProvider or Hash, optional) - Provider information</li> <li><code>documentation_url</code> (String, optional) - Documentation URL</li> <li><code>authentication</code> (AgentAuthentication or Hash, optional) - Authentication config</li> <li><code>default_input_modes</code> (Array, optional) - Default input modes (default: ['text']) <li><code>default_output_modes</code> (Array, optional) - Default output modes (default: ['text']) <p>Returns: <code>AgentCard</code> instance</p> <p>Example:</p> <pre><code>card = A2A::Models::AgentCard.new(\n  name: 'DataAnalyzer',\n  description: 'AI-powered data analysis agent',\n  url: 'https://agents.example.com/analyzer',\n  version: '1.0.0',\n  provider: {\n    organization: 'Example Corp',\n    url: 'https://example.com'\n  },\n  documentation_url: 'https://docs.example.com/analyzer',\n  capabilities: {\n    streaming: true,\n    push_notifications: false,\n    state_transition_history: true\n  },\n  authentication: {\n    schemes: ['bearer'],\n    credentials: 'https://auth.example.com'\n  },\n  default_input_modes: ['text', 'file'],\n  default_output_modes: ['text', 'data'],\n  skills: [\n    {\n      id: 'data-analysis',\n      name: 'Data Analysis',\n      description: 'Analyze CSV and Excel files',\n      tags: ['analytics', 'data'],\n      input_modes: ['file'],\n      output_modes: ['text', 'data']\n    }\n  ]\n)\n</code></pre>"},{"location":"api/models/#instance-methods_10","title":"Instance Methods","text":""},{"location":"api/models/#name_2","title":"<code>#name</code>","text":"<p>Returns the agent name.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#description_1","title":"<code>#description</code>","text":"<p>Returns the agent description.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#url","title":"<code>#url</code>","text":"<p>Returns the agent URL.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#provider","title":"<code>#provider</code>","text":"<p>Returns the provider information.</p> <p>Returns: <code>AgentProvider</code> or <code>nil</code></p>"},{"location":"api/models/#version","title":"<code>#version</code>","text":"<p>Returns the agent version.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#documentation_url","title":"<code>#documentation_url</code>","text":"<p>Returns the documentation URL.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#capabilities","title":"<code>#capabilities</code>","text":"<p>Returns the agent capabilities.</p> <p>Returns: <code>AgentCapabilities</code></p>"},{"location":"api/models/#authentication","title":"<code>#authentication</code>","text":"<p>Returns the authentication configuration.</p> <p>Returns: <code>AgentAuthentication</code> or <code>nil</code></p>"},{"location":"api/models/#default_input_modes","title":"<code>#default_input_modes</code>","text":"<p>Returns the default input modes.</p> <p>Returns: <code>Array&lt;String&gt;</code></p>"},{"location":"api/models/#default_output_modes","title":"<code>#default_output_modes</code>","text":"<p>Returns the default output modes.</p> <p>Returns: <code>Array&lt;String&gt;</code></p>"},{"location":"api/models/#skills","title":"<code>#skills</code>","text":"<p>Returns the agent skills.</p> <p>Returns: <code>Array&lt;AgentSkill&gt;</code></p>"},{"location":"api/models/#to_h_9","title":"<code>#to_h</code>","text":"<p>Converts to hash (uses camelCase).</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_10","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_9","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_9","title":"<code>.from_hash(hash)</code>","text":"<p>Creates an AgentCard from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>AgentCard</code></p>"},{"location":"api/models/#agentcapabilities","title":"AgentCapabilities","text":"<p>Represents the capabilities supported by an agent.</p> <p>Source: <code>lib/a2a/models/agent_capabilities.rb</code></p>"},{"location":"api/models/#constructor_11","title":"Constructor","text":"<pre><code>A2A::Models::AgentCapabilities.new(\n  streaming: false,\n  push_notifications: false,\n  state_transition_history: false\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>streaming</code> (Boolean, optional) - Supports streaming (default: false)</li> <li><code>push_notifications</code> (Boolean, optional) - Supports push notifications (default: false)</li> <li><code>state_transition_history</code> (Boolean, optional) - Supports state history (default: false)</li> </ul> <p>Returns: <code>AgentCapabilities</code> instance</p> <p>Example:</p> <pre><code>caps = A2A::Models::AgentCapabilities.new(\n  streaming: true,\n  push_notifications: false,\n  state_transition_history: true\n)\n</code></pre>"},{"location":"api/models/#instance-methods_11","title":"Instance Methods","text":""},{"location":"api/models/#streaming","title":"<code>#streaming</code>","text":"<p>Returns the streaming capability.</p> <p>Returns: <code>Boolean</code></p>"},{"location":"api/models/#streaming_1","title":"<code>#streaming?</code>","text":"<p>Returns whether streaming is supported.</p> <p>Returns: <code>Boolean</code></p>"},{"location":"api/models/#push_notifications","title":"<code>#push_notifications</code>","text":"<p>Returns the push notifications capability.</p> <p>Returns: <code>Boolean</code></p>"},{"location":"api/models/#push_notifications_1","title":"<code>#push_notifications?</code>","text":"<p>Returns whether push notifications are supported.</p> <p>Returns: <code>Boolean</code></p>"},{"location":"api/models/#state_transition_history","title":"<code>#state_transition_history</code>","text":"<p>Returns the state transition history capability.</p> <p>Returns: <code>Boolean</code></p>"},{"location":"api/models/#state_transition_history_1","title":"<code>#state_transition_history?</code>","text":"<p>Returns whether state transition history is supported.</p> <p>Returns: <code>Boolean</code></p>"},{"location":"api/models/#to_h_10","title":"<code>#to_h</code>","text":"<p>Converts to hash (uses camelCase).</p> <p>Returns: <code>Hash</code></p> <pre><code>caps.to_h\n# =&gt; { streaming: true, pushNotifications: false, stateTransitionHistory: true }\n</code></pre>"},{"location":"api/models/#to_jsonargs_11","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_10","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_10","title":"<code>.from_hash(hash)</code>","text":"<p>Creates AgentCapabilities from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>AgentCapabilities</code></p>"},{"location":"api/models/#agentskill","title":"AgentSkill","text":"<p>Represents a skill that an agent can perform.</p> <p>Source: <code>lib/a2a/models/agent_skill.rb</code></p>"},{"location":"api/models/#constructor_12","title":"Constructor","text":"<pre><code>A2A::Models::AgentSkill.new(\n  id:,\n  name:,\n  description: nil,\n  tags: nil,\n  examples: nil,\n  input_modes: nil,\n  output_modes: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> (String, required) - Unique skill identifier</li> <li><code>name</code> (String, required) - Skill name</li> <li><code>description</code> (String, optional) - Skill description</li> <li><code>tags</code> (Array, optional) - Skill tags <li><code>examples</code> (Array, optional) - Example uses <li><code>input_modes</code> (Array, optional) - Supported input modes <li><code>output_modes</code> (Array, optional) - Supported output modes <p>Returns: <code>AgentSkill</code> instance</p> <p>Example:</p> <pre><code>skill = A2A::Models::AgentSkill.new(\n  id: 'code-review',\n  name: 'Code Review',\n  description: 'Review code for best practices and potential issues',\n  tags: ['development', 'quality'],\n  examples: ['Review my Python code', 'Check this JavaScript for bugs'],\n  input_modes: ['text', 'file'],\n  output_modes: ['text', 'data']\n)\n</code></pre>"},{"location":"api/models/#instance-methods_12","title":"Instance Methods","text":""},{"location":"api/models/#id_1","title":"<code>#id</code>","text":"<p>Returns the skill ID.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#name_3","title":"<code>#name</code>","text":"<p>Returns the skill name.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#description_2","title":"<code>#description</code>","text":"<p>Returns the skill description.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#tags","title":"<code>#tags</code>","text":"<p>Returns the skill tags.</p> <p>Returns: <code>Array&lt;String&gt;</code> or <code>nil</code></p>"},{"location":"api/models/#examples","title":"<code>#examples</code>","text":"<p>Returns example uses.</p> <p>Returns: <code>Array&lt;String&gt;</code> or <code>nil</code></p>"},{"location":"api/models/#input_modes","title":"<code>#input_modes</code>","text":"<p>Returns supported input modes.</p> <p>Returns: <code>Array&lt;String&gt;</code> or <code>nil</code></p>"},{"location":"api/models/#output_modes","title":"<code>#output_modes</code>","text":"<p>Returns supported output modes.</p> <p>Returns: <code>Array&lt;String&gt;</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_11","title":"<code>#to_h</code>","text":"<p>Converts to hash (uses camelCase).</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_12","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_11","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_11","title":"<code>.from_hash(hash)</code>","text":"<p>Creates an AgentSkill from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>AgentSkill</code></p>"},{"location":"api/models/#agentprovider","title":"AgentProvider","text":"<p>Represents the provider information for an agent.</p> <p>Source: <code>lib/a2a/models/agent_provider.rb</code></p>"},{"location":"api/models/#constructor_13","title":"Constructor","text":"<pre><code>A2A::Models::AgentProvider.new(\n  organization:,\n  url: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>organization</code> (String, required) - Provider organization name</li> <li><code>url</code> (String, optional) - Provider URL</li> </ul> <p>Returns: <code>AgentProvider</code> instance</p> <p>Example:</p> <pre><code>provider = A2A::Models::AgentProvider.new(\n  organization: 'Acme Corporation',\n  url: 'https://acme.com'\n)\n</code></pre>"},{"location":"api/models/#instance-methods_13","title":"Instance Methods","text":""},{"location":"api/models/#organization","title":"<code>#organization</code>","text":"<p>Returns the organization name.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#url_1","title":"<code>#url</code>","text":"<p>Returns the provider URL.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_12","title":"<code>#to_h</code>","text":"<p>Converts to hash.</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_13","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_12","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_12","title":"<code>.from_hash(hash)</code>","text":"<p>Creates an AgentProvider from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>AgentProvider</code></p>"},{"location":"api/models/#agentauthentication","title":"AgentAuthentication","text":"<p>Represents authentication configuration for an agent.</p> <p>Source: <code>lib/a2a/models/agent_authentication.rb</code></p>"},{"location":"api/models/#constructor_14","title":"Constructor","text":"<pre><code>A2A::Models::AgentAuthentication.new(\n  schemes:,\n  credentials: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>schemes</code> (Array, required) - Authentication schemes (e.g., ['bearer', 'basic']) <li><code>credentials</code> (String, optional) - Credentials endpoint URL</li> <p>Returns: <code>AgentAuthentication</code> instance</p> <p>Example:</p> <pre><code>auth = A2A::Models::AgentAuthentication.new(\n  schemes: ['bearer'],\n  credentials: 'https://auth.example.com/token'\n)\n</code></pre>"},{"location":"api/models/#instance-methods_14","title":"Instance Methods","text":""},{"location":"api/models/#schemes","title":"<code>#schemes</code>","text":"<p>Returns the authentication schemes.</p> <p>Returns: <code>Array&lt;String&gt;</code></p>"},{"location":"api/models/#credentials","title":"<code>#credentials</code>","text":"<p>Returns the credentials endpoint.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_13","title":"<code>#to_h</code>","text":"<p>Converts to hash.</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_14","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_13","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_13","title":"<code>.from_hash(hash)</code>","text":"<p>Creates an AgentAuthentication from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>AgentAuthentication</code></p>"},{"location":"api/models/#configuration","title":"Configuration","text":""},{"location":"api/models/#pushnotificationconfig","title":"PushNotificationConfig","text":"<p>Represents push notification configuration.</p> <p>Source: <code>lib/a2a/models/push_notification_config.rb</code></p>"},{"location":"api/models/#constructor_15","title":"Constructor","text":"<pre><code>A2A::Models::PushNotificationConfig.new(\n  url:,\n  token: nil,\n  authentication: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>url</code> (String, required) - Push notification endpoint URL</li> <li><code>token</code> (String, optional) - Authentication token</li> <li><code>authentication</code> (Hash, optional) - Authentication configuration</li> </ul> <p>Returns: <code>PushNotificationConfig</code> instance</p> <p>Example:</p> <pre><code>config = A2A::Models::PushNotificationConfig.new(\n  url: 'https://client.example.com/notifications',\n  token: 'secret-token-123',\n  authentication: { type: 'bearer' }\n)\n</code></pre>"},{"location":"api/models/#instance-methods_15","title":"Instance Methods","text":""},{"location":"api/models/#url_2","title":"<code>#url</code>","text":"<p>Returns the notification URL.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#token","title":"<code>#token</code>","text":"<p>Returns the authentication token.</p> <p>Returns: <code>String</code> or <code>nil</code></p>"},{"location":"api/models/#authentication_1","title":"<code>#authentication</code>","text":"<p>Returns the authentication config.</p> <p>Returns: <code>Hash</code> or <code>nil</code></p>"},{"location":"api/models/#to_h_14","title":"<code>#to_h</code>","text":"<p>Converts to hash.</p> <p>Returns: <code>Hash</code></p>"},{"location":"api/models/#to_jsonargs_15","title":"<code>#to_json(*args)</code>","text":"<p>Converts to JSON.</p> <p>Returns: <code>String</code></p>"},{"location":"api/models/#class-methods_14","title":"Class Methods","text":""},{"location":"api/models/#from_hashhash_14","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a PushNotificationConfig from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash)</li> </ul> <p>Returns: <code>PushNotificationConfig</code></p>"},{"location":"api/models/#common-patterns","title":"Common Patterns","text":""},{"location":"api/models/#serialization","title":"Serialization","text":"<p>All models support bidirectional JSON conversion:</p> <pre><code># Object to Hash\nhash = model.to_h\n\n# Object to JSON string\njson_string = model.to_json\n\n# Hash to Object\nmodel = ModelClass.from_hash(hash)\n\n# JSON string to Object\nrequire 'json'\nmodel = ModelClass.from_hash(JSON.parse(json_string))\n</code></pre>"},{"location":"api/models/#validation","title":"Validation","text":"<p>Models perform validation in their constructors:</p> <pre><code># This will raise ArgumentError\ninvalid_state = A2A::Models::TaskState.new('invalid')\n\n# This will raise ArgumentError\ninvalid_message = A2A::Models::Message.new(role: 'invalid', parts: [])\n\n# This will raise ArgumentError\ninvalid_file = A2A::Models::FileContent.new() # needs bytes or uri\n</code></pre>"},{"location":"api/models/#working-with-parts","title":"Working with Parts","text":"<p>Parts support polymorphic creation:</p> <pre><code># Create from type-specific class\ntext_part = A2A::Models::TextPart.new(text: 'Hello')\nfile_part = A2A::Models::FilePart.new(file: {...})\ndata_part = A2A::Models::DataPart.new(data: {...})\n\n# Create from hash using factory method\npart = A2A::Models::Part.from_hash({ type: 'text', text: 'Hello' })\n# =&gt; Returns TextPart instance\n\n# Parts in collections\nmessage = A2A::Models::Message.new(\n  role: 'user',\n  parts: [\n    { type: 'text', text: 'Analyze this:' },\n    { type: 'file', file: {...} }\n  ]\n)\n# Parts are automatically normalized to Part instances\n</code></pre>"},{"location":"api/models/#see-also","title":"See Also","text":"<ul> <li>API Overview</li> <li>Protocol Reference</li> <li>Client Reference</li> <li>Server Reference</li> <li>Quick Start Guide</li> </ul> <p>Back to API Reference | Back to Documentation Home</p>"},{"location":"api/protocol/","title":"Protocol API Reference","text":"<p>Complete reference for the A2A protocol classes (<code>A2A::Protocol</code> namespace).</p>"},{"location":"api/protocol/#overview","title":"Overview","text":"<p>The Protocol layer implements the JSON-RPC 2.0 protocol used for communication in the A2A system. This layer provides classes for creating requests, handling responses, and managing protocol-level errors.</p>"},{"location":"api/protocol/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Request</li> <li>Response</li> <li>Error</li> <li>Common Patterns</li> </ul>"},{"location":"api/protocol/#request","title":"Request","text":"<p>Represents a JSON-RPC 2.0 request in the A2A protocol.</p> <p>Source: <code>lib/a2a/protocol/request.rb</code></p>"},{"location":"api/protocol/#json-rpc-version","title":"JSON-RPC Version","text":"<p>All requests use JSON-RPC version <code>2.0</code>, defined by the constant <code>JSONRPC_VERSION</code>.</p>"},{"location":"api/protocol/#constructor","title":"Constructor","text":"<pre><code>A2A::Protocol::Request.new(\n  method:,\n  params: nil,\n  id: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>method</code> (String, required) - The RPC method name to invoke</li> <li><code>params</code> (Hash or Array, optional) - Method parameters</li> <li><code>id</code> (String or Integer, optional) - Request identifier (nil for notifications)</li> </ul> <p>Returns: <code>Request</code> instance</p> <p>Example:</p> <pre><code># Standard request\nrequest = A2A::Protocol::Request.new(\n  method: 'tasks/send',\n  params: {\n    taskId: 'task-123',\n    message: { role: 'user', parts: [...] }\n  },\n  id: 1\n)\n\n# Notification (no id, no response expected)\nnotification = A2A::Protocol::Request.new(\n  method: 'tasks/cancel',\n  params: { taskId: 'task-456' }\n)\n</code></pre>"},{"location":"api/protocol/#instance-methods","title":"Instance Methods","text":""},{"location":"api/protocol/#jsonrpc","title":"<code>#jsonrpc</code>","text":"<p>Returns the JSON-RPC version.</p> <p>Returns: <code>String</code> (always \"2.0\")</p> <pre><code>request.jsonrpc  # =&gt; \"2.0\"\n</code></pre>"},{"location":"api/protocol/#id","title":"<code>#id</code>","text":"<p>Returns the request identifier.</p> <p>Returns: <code>String</code>, <code>Integer</code>, or <code>nil</code></p> <pre><code>request.id  # =&gt; 1\n</code></pre>"},{"location":"api/protocol/#method","title":"<code>#method</code>","text":"<p>Returns the RPC method name.</p> <p>Returns: <code>String</code></p> <pre><code>request.method  # =&gt; \"tasks/send\"\n</code></pre>"},{"location":"api/protocol/#params","title":"<code>#params</code>","text":"<p>Returns the method parameters.</p> <p>Returns: <code>Hash</code>, <code>Array</code>, or <code>nil</code></p> <pre><code>request.params  # =&gt; { taskId: \"task-123\", ... }\n</code></pre>"},{"location":"api/protocol/#to_h","title":"<code>#to_h</code>","text":"<p>Converts the request to a hash representation.</p> <p>Returns: <code>Hash</code></p> <pre><code>request.to_h\n# =&gt; {\n#   jsonrpc: \"2.0\",\n#   id: 1,\n#   method: \"tasks/send\",\n#   params: { ... }\n# }\n</code></pre>"},{"location":"api/protocol/#to_jsonargs","title":"<code>#to_json(*args)</code>","text":"<p>Converts the request to a JSON string.</p> <p>Returns: <code>String</code></p> <p>Example:</p> <pre><code>json = request.to_json\n# =&gt; '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tasks/send\",\"params\":{...}}'\n</code></pre>"},{"location":"api/protocol/#class-methods","title":"Class Methods","text":""},{"location":"api/protocol/#from_hashhash","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a Request instance from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash) - Hash representation (supports both symbol and string keys)</li> </ul> <p>Returns: <code>Request</code></p> <p>Example:</p> <pre><code>request = A2A::Protocol::Request.from_hash({\n  'jsonrpc' =&gt; '2.0',\n  'id' =&gt; 1,\n  'method' =&gt; 'tasks/get',\n  'params' =&gt; { 'taskId' =&gt; 'task-789' }\n})\n</code></pre>"},{"location":"api/protocol/#a2a-protocol-methods","title":"A2A Protocol Methods","text":"<p>The following methods are defined in the A2A protocol specification:</p>"},{"location":"api/protocol/#task-management","title":"Task Management","text":"<ul> <li><code>tasks/send</code> - Submit a new task</li> <li><code>tasks/sendSubscribe</code> - Submit a task with streaming</li> <li><code>tasks/get</code> - Get task status</li> <li><code>tasks/cancel</code> - Cancel a task</li> <li><code>tasks/resubscribe</code> - Resubscribe to task updates</li> </ul>"},{"location":"api/protocol/#push-notifications","title":"Push Notifications","text":"<ul> <li><code>tasks/pushNotification/set</code> - Configure push notifications</li> <li><code>tasks/pushNotification/get</code> - Get push notification configuration</li> </ul> <p>Example:</p> <pre><code># Send a task\nrequest = A2A::Protocol::Request.new(\n  method: 'tasks/send',\n  params: {\n    taskId: SecureRandom.uuid,\n    message: {\n      role: 'user',\n      parts: [{ type: 'text', text: 'Hello!' }]\n    }\n  },\n  id: 1\n)\n\n# Get task status\nrequest = A2A::Protocol::Request.new(\n  method: 'tasks/get',\n  params: { taskId: 'task-123' },\n  id: 2\n)\n\n# Cancel a task\nrequest = A2A::Protocol::Request.new(\n  method: 'tasks/cancel',\n  params: { taskId: 'task-123' },\n  id: 3\n)\n</code></pre>"},{"location":"api/protocol/#response","title":"Response","text":"<p>Represents a JSON-RPC 2.0 response in the A2A protocol.</p> <p>Source: <code>lib/a2a/protocol/response.rb</code></p>"},{"location":"api/protocol/#json-rpc-version_1","title":"JSON-RPC Version","text":"<p>All responses use JSON-RPC version <code>2.0</code>, defined by the constant <code>JSONRPC_VERSION</code>.</p>"},{"location":"api/protocol/#constructor_1","title":"Constructor","text":"<pre><code>A2A::Protocol::Response.new(\n  id: nil,\n  result: nil,\n  error: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>id</code> (String or Integer, optional) - Request identifier (matches the request)</li> <li><code>result</code> (Object, optional) - Result data (for successful responses)</li> <li><code>error</code> (Hash, optional) - Error data (for error responses)</li> </ul> <p>Note: Either <code>result</code> or <code>error</code> should be present, but not both.</p> <p>Returns: <code>Response</code> instance</p> <p>Example:</p> <pre><code># Success response\nresponse = A2A::Protocol::Response.new(\n  id: 1,\n  result: {\n    id: 'task-123',\n    status: { state: 'submitted', timestamp: '...' }\n  }\n)\n\n# Error response\nresponse = A2A::Protocol::Response.new(\n  id: 1,\n  error: {\n    code: -32001,\n    message: 'Task not found',\n    data: { taskId: 'task-999' }\n  }\n)\n</code></pre>"},{"location":"api/protocol/#instance-methods_1","title":"Instance Methods","text":""},{"location":"api/protocol/#jsonrpc_1","title":"<code>#jsonrpc</code>","text":"<p>Returns the JSON-RPC version.</p> <p>Returns: <code>String</code> (always \"2.0\")</p> <pre><code>response.jsonrpc  # =&gt; \"2.0\"\n</code></pre>"},{"location":"api/protocol/#id_1","title":"<code>#id</code>","text":"<p>Returns the response identifier (matches the request ID).</p> <p>Returns: <code>String</code>, <code>Integer</code>, or <code>nil</code></p> <pre><code>response.id  # =&gt; 1\n</code></pre>"},{"location":"api/protocol/#result","title":"<code>#result</code>","text":"<p>Returns the result data.</p> <p>Returns: <code>Object</code> or <code>nil</code></p> <pre><code>response.result  # =&gt; { id: \"task-123\", ... }\n</code></pre>"},{"location":"api/protocol/#error","title":"<code>#error</code>","text":"<p>Returns the error data.</p> <p>Returns: <code>Hash</code> or <code>nil</code></p> <pre><code>response.error  # =&gt; { code: -32001, message: \"Task not found\" }\n</code></pre>"},{"location":"api/protocol/#success","title":"<code>#success?</code>","text":"<p>Returns whether the response indicates success (no error).</p> <p>Returns: <code>Boolean</code></p> <pre><code>response.success?  # =&gt; true if no error, false if error present\n</code></pre>"},{"location":"api/protocol/#to_h_1","title":"<code>#to_h</code>","text":"<p>Converts the response to a hash representation.</p> <p>Returns: <code>Hash</code></p> <pre><code>response.to_h\n# =&gt; {\n#   jsonrpc: \"2.0\",\n#   id: 1,\n#   result: { ... }\n# }\n</code></pre> <p>Note: If <code>result</code> responds to <code>to_h</code>, it will be called automatically.</p>"},{"location":"api/protocol/#to_jsonargs_1","title":"<code>#to_json(*args)</code>","text":"<p>Converts the response to a JSON string.</p> <p>Returns: <code>String</code></p> <p>Example:</p> <pre><code>json = response.to_json\n# =&gt; '{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{...}}'\n</code></pre>"},{"location":"api/protocol/#class-methods_1","title":"Class Methods","text":""},{"location":"api/protocol/#from_hashhash_1","title":"<code>.from_hash(hash)</code>","text":"<p>Creates a Response instance from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash) - Hash representation (supports both symbol and string keys)</li> </ul> <p>Returns: <code>Response</code></p> <p>Example:</p> <pre><code>response = A2A::Protocol::Response.from_hash({\n  'jsonrpc' =&gt; '2.0',\n  'id' =&gt; 1,\n  'result' =&gt; { 'id' =&gt; 'task-123', 'status' =&gt; { ... } }\n})\n</code></pre>"},{"location":"api/protocol/#successid-result","title":"<code>.success(id:, result:)</code>","text":"<p>Convenience method to create a success response.</p> <p>Parameters:</p> <ul> <li><code>id</code> (String or Integer, required) - Request identifier</li> <li><code>result</code> (Object, required) - Result data</li> </ul> <p>Returns: <code>Response</code></p> <p>Example:</p> <pre><code>response = A2A::Protocol::Response.success(\n  id: 1,\n  result: task.to_h\n)\n</code></pre>"},{"location":"api/protocol/#errorid-error","title":"<code>.error(id:, error:)</code>","text":"<p>Convenience method to create an error response.</p> <p>Parameters:</p> <ul> <li><code>id</code> (String or Integer, required) - Request identifier</li> <li><code>error</code> (Hash or Error, required) - Error data</li> </ul> <p>Returns: <code>Response</code></p> <p>Example:</p> <pre><code>response = A2A::Protocol::Response.error(\n  id: 1,\n  error: {\n    code: -32001,\n    message: 'Task not found'\n  }\n)\n\n# Or using an Error object\nerror_obj = A2A::Protocol::Error.new(\n  code: -32001,\n  message: 'Task not found'\n)\nresponse = A2A::Protocol::Response.error(id: 1, error: error_obj.to_h)\n</code></pre>"},{"location":"api/protocol/#error_1","title":"Error","text":"<p>Represents a JSON-RPC error in a protocol message.</p> <p>Source: <code>lib/a2a/protocol/error.rb</code></p>"},{"location":"api/protocol/#constructor_2","title":"Constructor","text":"<pre><code>A2A::Protocol::Error.new(\n  code:,\n  message:,\n  data: nil\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>code</code> (Integer, required) - Error code</li> <li><code>message</code> (String, required) - Error message</li> <li><code>data</code> (Object, optional) - Additional error data</li> </ul> <p>Returns: <code>Error</code> instance</p> <p>Example:</p> <pre><code>error = A2A::Protocol::Error.new(\n  code: -32001,\n  message: 'Task not found',\n  data: { taskId: 'task-999' }\n)\n</code></pre>"},{"location":"api/protocol/#instance-methods_2","title":"Instance Methods","text":""},{"location":"api/protocol/#code","title":"<code>#code</code>","text":"<p>Returns the error code.</p> <p>Returns: <code>Integer</code></p> <pre><code>error.code  # =&gt; -32001\n</code></pre>"},{"location":"api/protocol/#message","title":"<code>#message</code>","text":"<p>Returns the error message.</p> <p>Returns: <code>String</code></p> <pre><code>error.message  # =&gt; \"Task not found\"\n</code></pre>"},{"location":"api/protocol/#data","title":"<code>#data</code>","text":"<p>Returns additional error data.</p> <p>Returns: <code>Object</code> or <code>nil</code></p> <pre><code>error.data  # =&gt; { taskId: \"task-999\" }\n</code></pre>"},{"location":"api/protocol/#to_h_2","title":"<code>#to_h</code>","text":"<p>Converts the error to a hash representation.</p> <p>Returns: <code>Hash</code></p> <pre><code>error.to_h\n# =&gt; {\n#   code: -32001,\n#   message: \"Task not found\",\n#   data: { taskId: \"task-999\" }\n# }\n</code></pre>"},{"location":"api/protocol/#to_jsonargs_2","title":"<code>#to_json(*args)</code>","text":"<p>Converts the error to a JSON string.</p> <p>Returns: <code>String</code></p>"},{"location":"api/protocol/#class-methods_2","title":"Class Methods","text":""},{"location":"api/protocol/#from_hashhash_2","title":"<code>.from_hash(hash)</code>","text":"<p>Creates an Error instance from a hash.</p> <p>Parameters:</p> <ul> <li><code>hash</code> (Hash) - Hash representation (supports both symbol and string keys)</li> </ul> <p>Returns: <code>Error</code></p> <p>Example:</p> <pre><code>error = A2A::Protocol::Error.from_hash({\n  'code' =&gt; -32001,\n  'message' =&gt; 'Task not found',\n  'data' =&gt; { 'taskId' =&gt; 'task-999' }\n})\n</code></pre>"},{"location":"api/protocol/#from_exceptionexception","title":"<code>.from_exception(exception)</code>","text":"<p>Creates an Error from a Ruby exception.</p> <p>Parameters:</p> <ul> <li><code>exception</code> (Exception) - Ruby exception object</li> </ul> <p>Returns: <code>Error</code></p> <p>Behavior:</p> <ul> <li>If exception is an <code>A2A::JSONRPCError</code>, uses its code, message, and data</li> <li>Otherwise, creates an Internal Error (-32603) with the exception message</li> </ul> <p>Example:</p> <pre><code># From A2A error\nbegin\n  raise A2A::TaskNotFoundError.new\nrescue =&gt; e\n  error = A2A::Protocol::Error.from_exception(e)\n  # =&gt; Error with code: -32001, message: \"Task not found\"\nend\n\n# From standard exception\nbegin\n  raise StandardError, \"Something went wrong\"\nrescue =&gt; e\n  error = A2A::Protocol::Error.from_exception(e)\n  # =&gt; Error with code: -32603, message: \"Something went wrong\"\nend\n</code></pre>"},{"location":"api/protocol/#standard-error-codes","title":"Standard Error Codes","text":"<p>JSON-RPC 2.0 defines the following standard error codes:</p> Code Constant Description -32700 Parse Error Invalid JSON -32600 Invalid Request Request validation error -32601 Method Not Found Method doesn't exist -32602 Invalid Params Invalid method parameters -32603 Internal Error Internal server error"},{"location":"api/protocol/#a2a-specific-error-codes","title":"A2A-Specific Error Codes","text":"<p>The A2A protocol defines additional error codes:</p> Code Constant Description -32001 Task Not Found Task ID doesn't exist -32002 Task Not Cancelable Task cannot be canceled -32003 Push Notification Not Supported Push notifications unavailable -32004 Unsupported Operation Operation not supported <p>See the Error Handling section in the API overview for exception classes.</p>"},{"location":"api/protocol/#common-patterns","title":"Common Patterns","text":""},{"location":"api/protocol/#creating-a-request-response-pair","title":"Creating a Request-Response Pair","text":"<pre><code># Client creates a request\nrequest = A2A::Protocol::Request.new(\n  method: 'tasks/send',\n  params: {\n    taskId: 'task-123',\n    message: { role: 'user', parts: [...] }\n  },\n  id: 1\n)\n\n# Server processes and creates a response\nif success\n  response = A2A::Protocol::Response.success(\n    id: request.id,\n    result: task.to_h\n  )\nelse\n  response = A2A::Protocol::Response.error(\n    id: request.id,\n    error: {\n      code: -32001,\n      message: 'Task not found'\n    }\n  )\nend\n</code></pre>"},{"location":"api/protocol/#handling-errors","title":"Handling Errors","text":"<pre><code># Create an error from an exception\nbegin\n  # ... some operation ...\n  raise A2A::TaskNotFoundError.new\nrescue A2A::JSONRPCError =&gt; e\n  error = A2A::Protocol::Error.from_exception(e)\n  response = A2A::Protocol::Response.error(\n    id: request.id,\n    error: error.to_h\n  )\nend\n</code></pre>"},{"location":"api/protocol/#checking-response-success","title":"Checking Response Success","text":"<pre><code>response = client.send_request(request)\n\nif response.success?\n  # Handle result\n  task = A2A::Models::Task.from_hash(response.result)\n  puts \"Task state: #{task.state}\"\nelse\n  # Handle error\n  error = response.error\n  puts \"Error #{error['code']}: #{error['message']}\"\nend\n</code></pre>"},{"location":"api/protocol/#serialization","title":"Serialization","text":"<p>All protocol classes support JSON serialization:</p> <pre><code># Request to JSON\nrequest = A2A::Protocol::Request.new(method: 'tasks/get', params: {}, id: 1)\njson_string = request.to_json\n# =&gt; '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tasks/get\",\"params\":{}}'\n\n# JSON to Request\nrequire 'json'\nhash = JSON.parse(json_string)\nrequest = A2A::Protocol::Request.from_hash(hash)\n\n# Response to JSON\nresponse = A2A::Protocol::Response.success(id: 1, result: { status: 'ok' })\njson_string = response.to_json\n\n# JSON to Response\nhash = JSON.parse(json_string)\nresponse = A2A::Protocol::Response.from_hash(hash)\n</code></pre>"},{"location":"api/protocol/#notification-requests","title":"Notification Requests","text":"<p>Requests without an <code>id</code> are notifications (no response expected):</p> <pre><code># Notification (no response expected)\nnotification = A2A::Protocol::Request.new(\n  method: 'tasks/update',\n  params: { taskId: 'task-123', status: 'updated' }\n  # Note: no id parameter\n)\n\n# Server should not send a response for notifications\nif request.id.nil?\n  # This is a notification, process but don't respond\n  process_notification(request)\nelse\n  # This is a regular request, send a response\n  response = process_request(request)\n  send_response(response)\nend\n</code></pre>"},{"location":"api/protocol/#batch-requests","title":"Batch Requests","text":"<p>While the A2A gem doesn't provide special handling for batch requests, JSON-RPC 2.0 supports them:</p> <pre><code># Array of requests\nbatch = [\n  A2A::Protocol::Request.new(method: 'tasks/get', params: { taskId: '1' }, id: 1),\n  A2A::Protocol::Request.new(method: 'tasks/get', params: { taskId: '2' }, id: 2),\n  A2A::Protocol::Request.new(method: 'tasks/get', params: { taskId: '3' }, id: 3)\n]\n\n# Serialize as JSON array\njson = batch.map(&amp;:to_h).to_json\n# =&gt; '[{\"jsonrpc\":\"2.0\",\"id\":1,...},{\"jsonrpc\":\"2.0\",\"id\":2,...},...]'\n\n# Server responds with array of responses\nresponses = [\n  A2A::Protocol::Response.success(id: 1, result: task1),\n  A2A::Protocol::Response.success(id: 2, result: task2),\n  A2A::Protocol::Response.error(id: 3, error: { code: -32001, message: '...' })\n]\n</code></pre>"},{"location":"api/protocol/#model-integration","title":"Model Integration","text":"<p>Protocol classes work seamlessly with model classes:</p> <pre><code># Create a task\ntask = A2A::Models::Task.new(\n  id: 'task-123',\n  status: { state: 'submitted' }\n)\n\n# Create a response with the task\nresponse = A2A::Protocol::Response.success(\n  id: 1,\n  result: task.to_h  # Task automatically converts to hash\n)\n\n# Parse response and recreate task\nif response.success?\n  task = A2A::Models::Task.from_hash(response.result)\nend\n</code></pre>"},{"location":"api/protocol/#wire-format","title":"Wire Format","text":"<p>The JSON-RPC 2.0 wire format for A2A protocol:</p>"},{"location":"api/protocol/#request-format","title":"Request Format","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"taskId\": \"task-123\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"Hello, agent!\"\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"api/protocol/#success-response-format","title":"Success Response Format","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"id\": \"task-123\",\n    \"sessionId\": \"session-abc\",\n    \"status\": {\n      \"state\": \"submitted\",\n      \"timestamp\": \"2025-01-15T10:30:00Z\"\n    }\n  }\n}\n</code></pre>"},{"location":"api/protocol/#error-response-format","title":"Error Response Format","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"error\": {\n    \"code\": -32001,\n    \"message\": \"Task not found\",\n    \"data\": {\n      \"taskId\": \"task-999\"\n    }\n  }\n}\n</code></pre>"},{"location":"api/protocol/#notification-format","title":"Notification Format","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/update\",\n  \"params\": {\n    \"taskId\": \"task-123\",\n    \"status\": \"completed\"\n  }\n}\n</code></pre>"},{"location":"api/protocol/#see-also","title":"See Also","text":"<ul> <li>API Overview</li> <li>Models Reference</li> <li>Client Reference</li> <li>Server Reference</li> <li>Error Handling</li> <li>JSON-RPC 2.0 Specification</li> </ul> <p>Back to API Reference | Back to Documentation Home</p>"},{"location":"api/server/","title":"Server API Reference","text":"<p>Complete reference for the A2A server base class (<code>A2A::Server::Base</code>).</p>"},{"location":"api/server/#overview","title":"Overview","text":"<p>The Server layer provides a base class for implementing A2A servers that expose A2A protocol endpoints. Servers handle incoming JSON-RPC requests, manage task lifecycle, support streaming, and provide push notifications.</p> <p>Source: <code>lib/a2a/server/base.rb</code></p>"},{"location":"api/server/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Class: A2A::Server::Base</li> <li>Constructor</li> <li>Instance Attributes</li> <li>Instance Methods<ul> <li>Request Handling</li> <li>Task Management</li> <li>Push Notifications</li> <li>Streaming</li> </ul> </li> <li>Implementation Guide</li> <li>Usage Examples</li> </ul>"},{"location":"api/server/#class-a2aserverbase","title":"Class: A2A::Server::Base","text":"<p>Base class for A2A servers. An A2A server exposes an HTTP endpoint that implements the A2A protocol methods.</p> <p>This is an abstract base class that defines the interface for A2A servers. Subclasses must implement the abstract methods to provide concrete agent implementations.</p>"},{"location":"api/server/#constructor","title":"Constructor","text":"<pre><code>A2A::Server::Base.new(agent_card)\n</code></pre> <p>Parameters:</p> <ul> <li><code>agent_card</code> (A2A::Models::AgentCard, required) - The agent's metadata and capabilities</li> </ul> <p>Returns: <code>Server::Base</code> instance</p> <p>Example:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  # Implementation here\nend\n\nagent_card = A2A::Models::AgentCard.new(\n  name: 'DataAnalyzer',\n  url: 'https://myagent.example.com',\n  version: '1.0.0',\n  capabilities: { streaming: true },\n  skills: [...]\n)\n\nserver = MyA2AServer.new(agent_card)\n</code></pre>"},{"location":"api/server/#instance-attributes","title":"Instance Attributes","text":""},{"location":"api/server/#agent_card","title":"<code>#agent_card</code>","text":"<p>Returns the agent's metadata and capabilities.</p> <p>Returns: <code>A2A::Models::AgentCard</code></p> <p>Example:</p> <pre><code>server.agent_card.name  # =&gt; \"DataAnalyzer\"\nserver.agent_card.version  # =&gt; \"1.0.0\"\nserver.agent_card.capabilities.streaming?  # =&gt; true\n</code></pre>"},{"location":"api/server/#instance-methods","title":"Instance Methods","text":""},{"location":"api/server/#request-handling","title":"Request Handling","text":""},{"location":"api/server/#handle_requestrequest","title":"<code>#handle_request(request)</code>","text":"<p>Handle an incoming A2A request. This is the main entry point for processing JSON-RPC requests.</p> <p>Parameters:</p> <ul> <li><code>request</code> (Hash) - The JSON-RPC request hash</li> </ul> <p>Returns: <code>Hash</code> - The JSON-RPC response hash</p> <p>Raises: <code>NotImplementedError</code> - Subclasses must implement this method</p> <p>Example Implementation:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_request(request)\n    req = A2A::Protocol::Request.from_hash(request)\n\n    begin\n      result = case req.method\n               when 'tasks/send'\n                 handle_send_task(req.params).to_h\n               when 'tasks/sendSubscribe'\n                 # Streaming handled separately\n                 raise A2A::UnsupportedOperationError.new\n               when 'tasks/get'\n                 handle_get_task(req.params).to_h\n               when 'tasks/cancel'\n                 handle_cancel_task(req.params).to_h\n               when 'tasks/pushNotification/set'\n                 handle_set_push_notification(req.params)\n                 {}\n               when 'tasks/pushNotification/get'\n                 handle_get_push_notification(req.params).to_h\n               else\n                 raise A2A::MethodNotFoundError.new\n               end\n\n      A2A::Protocol::Response.success(id: req.id, result: result).to_h\n\n    rescue A2A::JSONRPCError =&gt; e\n      error = A2A::Protocol::Error.from_exception(e)\n      A2A::Protocol::Response.error(id: req.id, error: error.to_h).to_h\n    end\n  end\nend\n</code></pre> <p>Usage in Web Framework:</p> <pre><code># Sinatra example\npost '/' do\n  content_type :json\n\n  request_data = JSON.parse(request.body.read)\n  response_data = server.handle_request(request_data)\n\n  response_data.to_json\nend\n\n# Rails example\nclass A2AController &lt; ApplicationController\n  def handle\n    response_data = @server.handle_request(params.to_unsafe_h)\n    render json: response_data\n  end\nend\n</code></pre>"},{"location":"api/server/#task-management","title":"Task Management","text":""},{"location":"api/server/#handle_send_taskparams","title":"<code>#handle_send_task(params)</code>","text":"<p>Handle a <code>tasks/send</code> request - submit a new task.</p> <p>Parameters:</p> <ul> <li><code>params</code> (Hash) - Request parameters containing:</li> <li><code>taskId</code> (String) - Unique task identifier</li> <li><code>message</code> (Hash) - Message data</li> <li><code>sessionId</code> (String, optional) - Session identifier</li> </ul> <p>Returns: <code>A2A::Models::Task</code> - The created task</p> <p>Raises: <code>NotImplementedError</code> - Subclasses must implement this method</p> <p>Example Implementation:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_send_task(params)\n    task_id = params['taskId'] || params[:taskId]\n    session_id = params['sessionId'] || params[:sessionId]\n    message_data = params['message'] || params[:message]\n\n    message = A2A::Models::Message.from_hash(message_data)\n\n    # Process the task\n    task = process_task(task_id, message, session_id)\n\n    task\n  end\n\n  private\n\n  def process_task(task_id, message, session_id)\n    # Store the task\n    @tasks ||= {}\n    @tasks[task_id] = A2A::Models::Task.new(\n      id: task_id,\n      session_id: session_id,\n      status: { state: 'submitted' }\n    )\n\n    # Start processing asynchronously\n    Thread.new do\n      perform_task_work(task_id, message)\n    end\n\n    @tasks[task_id]\n  end\n\n  def perform_task_work(task_id, message)\n    # Update to working\n    @tasks[task_id] = A2A::Models::Task.new(\n      id: task_id,\n      session_id: @tasks[task_id].session_id,\n      status: { state: 'working' }\n    )\n\n    # Do the actual work\n    result = your_agent_logic(message)\n\n    # Create artifacts\n    artifacts = [\n      A2A::Models::Artifact.new(\n        name: 'result',\n        parts: [A2A::Models::TextPart.new(text: result)]\n      )\n    ]\n\n    # Update to completed\n    @tasks[task_id] = A2A::Models::Task.new(\n      id: task_id,\n      session_id: @tasks[task_id].session_id,\n      status: { state: 'completed' },\n      artifacts: artifacts\n    )\n  rescue =&gt; e\n    # Update to failed\n    @tasks[task_id] = A2A::Models::Task.new(\n      id: task_id,\n      session_id: @tasks[task_id].session_id,\n      status: {\n        state: 'failed',\n        message: A2A::Models::Message.text(role: 'agent', text: e.message)\n      }\n    )\n  end\nend\n</code></pre>"},{"location":"api/server/#handle_send_task_streamingparams-block","title":"<code>#handle_send_task_streaming(params, &amp;block)</code>","text":"<p>Handle a <code>tasks/sendSubscribe</code> request - submit a task with streaming updates.</p> <p>Parameters:</p> <ul> <li><code>params</code> (Hash) - Request parameters</li> <li><code>block</code> (Block, required) - Block that yields streaming events</li> </ul> <p>Yields: Event hashes (task status and artifact updates)</p> <p>Returns: Implementation-defined</p> <p>Raises: <code>NotImplementedError</code> - Subclasses must implement this method</p> <p>Example Implementation:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_send_task_streaming(params, &amp;block)\n    task_id = params['taskId'] || params[:taskId]\n    session_id = params['sessionId'] || params[:sessionId]\n    message_data = params['message'] || params[:message]\n\n    message = A2A::Models::Message.from_hash(message_data)\n\n    # Send initial status\n    status = A2A::Models::TaskStatus.new(state: 'submitted')\n    yield({\n      type: 'taskStatus',\n      taskStatus: status.to_h\n    })\n\n    # Process with streaming\n    process_task_streaming(task_id, message, session_id, &amp;block)\n  end\n\n  private\n\n  def process_task_streaming(task_id, message, session_id)\n    # Update to working\n    status = A2A::Models::TaskStatus.new(state: 'working')\n    yield({\n      type: 'taskStatus',\n      taskStatus: status.to_h\n    })\n\n    # Stream results as they're generated\n    your_agent_logic_streaming(message) do |chunk|\n      artifact = A2A::Models::Artifact.new(\n        name: 'result',\n        parts: [A2A::Models::TextPart.new(text: chunk)],\n        append: true\n      )\n\n      yield({\n        type: 'artifactUpdate',\n        artifact: artifact.to_h\n      })\n    end\n\n    # Send final status\n    status = A2A::Models::TaskStatus.new(state: 'completed')\n    yield({\n      type: 'taskStatus',\n      taskStatus: status.to_h\n    })\n  rescue =&gt; e\n    status = A2A::Models::TaskStatus.new(\n      state: 'failed',\n      message: A2A::Models::Message.text(role: 'agent', text: e.message)\n    )\n    yield({\n      type: 'taskStatus',\n      taskStatus: status.to_h\n    })\n  end\nend\n</code></pre> <p>Usage in Web Framework:</p> <pre><code># Sinatra with Server-Sent Events\nget '/stream/:task_id' do\n  content_type 'text/event-stream'\n\n  stream :keep_open do |out|\n    server.handle_send_task_streaming(params) do |event|\n      out &lt;&lt; \"data: #{event.to_json}\\n\\n\"\n    end\n    out.close\n  end\nend\n</code></pre>"},{"location":"api/server/#handle_get_taskparams","title":"<code>#handle_get_task(params)</code>","text":"<p>Handle a <code>tasks/get</code> request - get task status.</p> <p>Parameters:</p> <ul> <li><code>params</code> (Hash) - Request parameters containing:</li> <li><code>taskId</code> (String) - Task identifier</li> </ul> <p>Returns: <code>A2A::Models::Task</code> - The task</p> <p>Raises:   - <code>NotImplementedError</code> - Subclasses must implement this method   - <code>A2A::TaskNotFoundError</code> - If task doesn't exist</p> <p>Example Implementation:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_get_task(params)\n    task_id = params['taskId'] || params[:taskId]\n\n    @tasks ||= {}\n    task = @tasks[task_id]\n\n    raise A2A::TaskNotFoundError.new unless task\n\n    task\n  end\nend\n</code></pre>"},{"location":"api/server/#handle_cancel_taskparams","title":"<code>#handle_cancel_task(params)</code>","text":"<p>Handle a <code>tasks/cancel</code> request - cancel a task.</p> <p>Parameters:</p> <ul> <li><code>params</code> (Hash) - Request parameters containing:</li> <li><code>taskId</code> (String) - Task identifier</li> </ul> <p>Returns: <code>A2A::Models::Task</code> - The canceled task</p> <p>Raises:   - <code>NotImplementedError</code> - Subclasses must implement this method   - <code>A2A::TaskNotFoundError</code> - If task doesn't exist   - <code>A2A::TaskNotCancelableError</code> - If task cannot be canceled</p> <p>Example Implementation:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_cancel_task(params)\n    task_id = params['taskId'] || params[:taskId]\n\n    @tasks ||= {}\n    task = @tasks[task_id]\n\n    raise A2A::TaskNotFoundError.new unless task\n\n    # Check if cancelable\n    if task.state.terminal?\n      raise A2A::TaskNotCancelableError.new\n    end\n\n    # Cancel the task\n    @task_threads ||= {}\n    @task_threads[task_id]&amp;.kill\n\n    # Update task state\n    @tasks[task_id] = A2A::Models::Task.new(\n      id: task_id,\n      session_id: task.session_id,\n      status: { state: 'canceled' },\n      artifacts: task.artifacts\n    )\n\n    @tasks[task_id]\n  end\nend\n</code></pre>"},{"location":"api/server/#push-notifications","title":"Push Notifications","text":""},{"location":"api/server/#handle_set_push_notificationparams","title":"<code>#handle_set_push_notification(params)</code>","text":"<p>Handle a <code>tasks/pushNotification/set</code> request.</p> <p>Parameters:</p> <ul> <li><code>params</code> (Hash) - Request parameters containing:</li> <li><code>taskId</code> (String) - Task identifier</li> <li><code>config</code> (Hash) - Push notification configuration</li> </ul> <p>Returns: Implementation-defined (typically nil or empty hash)</p> <p>Raises:   - <code>NotImplementedError</code> - Subclasses must implement this method   - <code>A2A::PushNotificationNotSupportedError</code> - If not supported</p> <p>Example Implementation:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_set_push_notification(params)\n    # Check if push notifications are supported\n    unless @agent_card.capabilities.push_notifications?\n      raise A2A::PushNotificationNotSupportedError.new\n    end\n\n    task_id = params['taskId'] || params[:taskId]\n    config_data = params['config'] || params[:config]\n\n    config = A2A::Models::PushNotificationConfig.from_hash(config_data)\n\n    # Store the configuration\n    @push_configs ||= {}\n    @push_configs[task_id] = config\n\n    nil\n  end\nend\n</code></pre>"},{"location":"api/server/#handle_get_push_notificationparams","title":"<code>#handle_get_push_notification(params)</code>","text":"<p>Handle a <code>tasks/pushNotification/get</code> request.</p> <p>Parameters:</p> <ul> <li><code>params</code> (Hash) - Request parameters containing:</li> <li><code>taskId</code> (String) - Task identifier</li> </ul> <p>Returns: <code>A2A::Models::PushNotificationConfig</code> - The configuration</p> <p>Raises:   - <code>NotImplementedError</code> - Subclasses must implement this method   - <code>A2A::PushNotificationNotSupportedError</code> - If not supported</p> <p>Example Implementation:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_get_push_notification(params)\n    unless @agent_card.capabilities.push_notifications?\n      raise A2A::PushNotificationNotSupportedError.new\n    end\n\n    task_id = params['taskId'] || params[:taskId]\n\n    @push_configs ||= {}\n    config = @push_configs[task_id]\n\n    config || A2A::Models::PushNotificationConfig.new(url: '')\n  end\nend\n</code></pre>"},{"location":"api/server/#streaming","title":"Streaming","text":""},{"location":"api/server/#handle_resubscribeparams-block","title":"<code>#handle_resubscribe(params, &amp;block)</code>","text":"<p>Handle a <code>tasks/resubscribe</code> request - resubscribe to task updates.</p> <p>Parameters:</p> <ul> <li><code>params</code> (Hash) - Request parameters containing:</li> <li><code>taskId</code> (String) - Task identifier</li> <li><code>block</code> (Block, required) - Block that yields streaming events</li> </ul> <p>Yields: Event hashes (task status and artifact updates)</p> <p>Returns: Implementation-defined</p> <p>Raises: <code>NotImplementedError</code> - Subclasses must implement this method</p> <p>Example Implementation:</p> <pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_resubscribe(params, &amp;block)\n    task_id = params['taskId'] || params[:taskId]\n\n    @tasks ||= {}\n    task = @tasks[task_id]\n\n    raise A2A::TaskNotFoundError.new unless task\n\n    # Send current status\n    yield({\n      type: 'taskStatus',\n      taskStatus: task.status.to_h\n    })\n\n    # Send current artifacts\n    task.artifacts&amp;.each do |artifact|\n      yield({\n        type: 'artifactUpdate',\n        artifact: artifact.to_h\n      })\n    end\n\n    # Subscribe to future updates if task is not terminal\n    unless task.state.terminal?\n      subscribe_to_updates(task_id, &amp;block)\n    end\n  end\n\n  private\n\n  def subscribe_to_updates(task_id)\n    # Implementation depends on your architecture\n    # Could use pub/sub, polling, etc.\n  end\nend\n</code></pre>"},{"location":"api/server/#implementation-guide","title":"Implementation Guide","text":""},{"location":"api/server/#creating-a-custom-server","title":"Creating a Custom Server","text":"<p>To create a working A2A server, you must:</p> <ol> <li>Define your agent's capabilities in an AgentCard</li> <li>Subclass <code>A2A::Server::Base</code></li> <li>Implement all abstract methods</li> <li>Handle task storage and lifecycle</li> <li>Integrate with a web framework (Sinatra, Rails, etc.)</li> <li>Serve the AgentCard at <code>/.well-known/agent.json</code></li> </ol>"},{"location":"api/server/#minimal-implementation","title":"Minimal Implementation","text":"<pre><code>require 'a2a'\nrequire 'sinatra'\nrequire 'json'\n\nclass SimpleA2AServer &lt; A2A::Server::Base\n  def initialize(agent_card)\n    super(agent_card)\n    @tasks = {}\n  end\n\n  def handle_request(request)\n    req = A2A::Protocol::Request.from_hash(request)\n\n    begin\n      result = case req.method\n               when 'tasks/send' then handle_send_task(req.params).to_h\n               when 'tasks/get' then handle_get_task(req.params).to_h\n               when 'tasks/cancel' then handle_cancel_task(req.params).to_h\n               else raise A2A::MethodNotFoundError.new\n               end\n\n      A2A::Protocol::Response.success(id: req.id, result: result).to_h\n    rescue A2A::JSONRPCError =&gt; e\n      error = A2A::Protocol::Error.from_exception(e)\n      A2A::Protocol::Response.error(id: req.id, error: error.to_h).to_h\n    end\n  end\n\n  def handle_send_task(params)\n    task_id = params['taskId']\n    message = A2A::Models::Message.from_hash(params['message'])\n\n    @tasks[task_id] = A2A::Models::Task.new(\n      id: task_id,\n      status: { state: 'submitted' }\n    )\n\n    Thread.new { process_task(task_id, message) }\n\n    @tasks[task_id]\n  end\n\n  def handle_send_task_streaming(params, &amp;block)\n    raise A2A::UnsupportedOperationError.new\n  end\n\n  def handle_get_task(params)\n    task = @tasks[params['taskId']]\n    raise A2A::TaskNotFoundError.new unless task\n    task\n  end\n\n  def handle_cancel_task(params)\n    task = @tasks[params['taskId']]\n    raise A2A::TaskNotFoundError.new unless task\n    raise A2A::TaskNotCancelableError.new if task.state.terminal?\n\n    @tasks[params['taskId']] = A2A::Models::Task.new(\n      id: task.id,\n      status: { state: 'canceled' }\n    )\n  end\n\n  def handle_set_push_notification(params)\n    raise A2A::PushNotificationNotSupportedError.new\n  end\n\n  def handle_get_push_notification(params)\n    raise A2A::PushNotificationNotSupportedError.new\n  end\n\n  def handle_resubscribe(params, &amp;block)\n    raise A2A::UnsupportedOperationError.new\n  end\n\n  private\n\n  def process_task(task_id, message)\n    sleep 2  # Simulate work\n\n    result_text = \"Processed: #{message.parts.first.text}\"\n    artifact = A2A::Models::Artifact.new(\n      name: 'result',\n      parts: [A2A::Models::TextPart.new(text: result_text)]\n    )\n\n    @tasks[task_id] = A2A::Models::Task.new(\n      id: task_id,\n      status: { state: 'completed' },\n      artifacts: [artifact]\n    )\n  end\nend\n\n# Create agent card\nagent_card = A2A::Models::AgentCard.new(\n  name: 'SimpleAgent',\n  url: 'http://localhost:4567',\n  version: '1.0.0',\n  capabilities: { streaming: false },\n  skills: [\n    {\n      id: 'echo',\n      name: 'Echo',\n      description: 'Echoes back your message'\n    }\n  ]\n)\n\n# Create server\nserver = SimpleA2AServer.new(agent_card)\n\n# Serve agent card\nget '/.well-known/agent.json' do\n  content_type :json\n  server.agent_card.to_json\nend\n\n# Handle A2A requests\npost '/' do\n  content_type :json\n  request_data = JSON.parse(request.body.read)\n  response_data = server.handle_request(request_data)\n  response_data.to_json\nend\n</code></pre>"},{"location":"api/server/#usage-examples","title":"Usage Examples","text":""},{"location":"api/server/#complete-server-with-rails","title":"Complete Server with Rails","text":"<pre><code># app/controllers/a2a_controller.rb\nclass A2aController &lt; ApplicationController\n  skip_before_action :verify_authenticity_token\n\n  def agent_card\n    render json: a2a_server.agent_card.to_h\n  end\n\n  def handle_request\n    response_data = a2a_server.handle_request(request_params)\n    render json: response_data\n  end\n\n  private\n\n  def a2a_server\n    @a2a_server ||= MyA2AServer.new(build_agent_card)\n  end\n\n  def build_agent_card\n    A2A::Models::AgentCard.new(\n      name: 'MyAgent',\n      url: request.base_url,\n      version: '1.0.0',\n      capabilities: {\n        streaming: true,\n        push_notifications: false\n      },\n      skills: AgentSkill.all.map(&amp;:to_a2a_skill)\n    )\n  end\n\n  def request_params\n    params.permit!.to_h\n  end\nend\n\n# config/routes.rb\nRails.application.routes.draw do\n  get '/.well-known/agent.json', to: 'a2a#agent_card'\n  post '/a2a', to: 'a2a#handle_request'\nend\n</code></pre>"},{"location":"api/server/#server-with-background-jobs","title":"Server with Background Jobs","text":"<pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_send_task(params)\n    task_id = params['taskId']\n    message = A2A::Models::Message.from_hash(params['message'])\n\n    # Store initial task\n    task = Task.create!(\n      task_id: task_id,\n      state: 'submitted',\n      message_data: message.to_h\n    )\n\n    # Enqueue background job\n    ProcessTaskJob.perform_later(task_id)\n\n    # Return task\n    task.to_a2a_task\n  end\n\n  def handle_get_task(params)\n    task = Task.find_by(task_id: params['taskId'])\n    raise A2A::TaskNotFoundError.new unless task\n\n    task.to_a2a_task\n  end\nend\n\n# app/jobs/process_task_job.rb\nclass ProcessTaskJob &lt; ApplicationJob\n  def perform(task_id)\n    task = Task.find_by(task_id: task_id)\n    return unless task\n\n    # Update to working\n    task.update!(state: 'working')\n\n    # Do the work\n    result = YourAgentService.process(task.message_data)\n\n    # Create artifacts\n    artifact_data = {\n      name: 'result',\n      parts: [{ type: 'text', text: result }]\n    }\n\n    # Update to completed\n    task.update!(\n      state: 'completed',\n      artifacts_data: [artifact_data]\n    )\n\n    # Send push notification if configured\n    send_push_notification(task) if task.push_config.present?\n  rescue =&gt; e\n    task.update!(\n      state: 'failed',\n      error_message: e.message\n    )\n  end\n\n  private\n\n  def send_push_notification(task)\n    # Send HTTP POST to client's push notification URL\n    config = task.push_notification_config\n    # ... implementation ...\n  end\nend\n</code></pre>"},{"location":"api/server/#streaming-implementation","title":"Streaming Implementation","text":"<pre><code>class StreamingA2AServer &lt; A2A::Server::Base\n  def handle_send_task_streaming(params, &amp;block)\n    task_id = params['taskId']\n    message = A2A::Models::Message.from_hash(params['message'])\n\n    # Send initial status\n    yield({\n      type: 'taskStatus',\n      taskStatus: { state: 'working', timestamp: Time.now.utc.iso8601 }\n    })\n\n    # Stream results\n    YourAgentService.stream_process(message) do |chunk|\n      artifact = A2A::Models::Artifact.new(\n        name: 'response',\n        parts: [A2A::Models::TextPart.new(text: chunk)],\n        append: true\n      )\n\n      yield({\n        type: 'artifactUpdate',\n        artifact: artifact.to_h\n      })\n    end\n\n    # Send completion\n    yield({\n      type: 'taskStatus',\n      taskStatus: { state: 'completed', timestamp: Time.now.utc.iso8601 }\n    })\n  end\nend\n\n# Sinatra route for streaming\npost '/stream' do\n  content_type 'text/event-stream'\n\n  stream :keep_open do |out|\n    request_data = JSON.parse(request.body.read)\n    params = request_data['params']\n\n    server.handle_send_task_streaming(params) do |event|\n      out &lt;&lt; \"data: #{event.to_json}\\n\\n\"\n    end\n\n    out.close\n  end\nend\n</code></pre>"},{"location":"api/server/#see-also","title":"See Also","text":"<ul> <li>API Overview</li> <li>Models Reference</li> <li>Protocol Reference</li> <li>Client Reference</li> <li>Quick Start Guide</li> <li>Server Examples</li> </ul> <p>Back to API Reference | Back to Documentation Home</p>"},{"location":"architecture/","title":"A2A Ruby Gem - Architecture Overview","text":"<p>This document provides a comprehensive overview of the A2A Ruby gem's architecture, explaining how the codebase is structured and why these architectural decisions were made.</p>"},{"location":"architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>High-Level Architecture</li> <li>Layered Architecture</li> <li>Component Structure</li> <li>Directory Organization</li> <li>Key Architectural Patterns</li> <li>Data Flow</li> <li>Related Documentation</li> </ul>"},{"location":"architecture/#introduction","title":"Introduction","text":"<p>The A2A Ruby gem implements the Agent2Agent (A2A) protocol, an open protocol created by Google that enables communication and interoperability between agentic applications. The gem follows a clean, layered architecture that separates concerns and makes the codebase maintainable, testable, and extensible.</p> <p>The architecture is designed around these core principles: - Protocol Compliance: Strictly adheres to the A2A JSON schema specification and JSON-RPC 2.0 - Separation of Concerns: Clear boundaries between models, protocol, client, and server - Extensibility: Easy to add new capabilities without modifying existing code - Type Safety: Designed to work with RBS type definitions for enhanced reliability</p>"},{"location":"architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>The gem is structured as a layered architecture with four primary layers:</p> <pre><code>graph TB\n    subgraph \"Application Layer\"\n        Client[Client Applications]\n        Server[Server Applications]\n    end\n\n    subgraph \"Interface Layer\"\n        ClientBase[A2A::Client::Base]\n        ServerBase[A2A::Server::Base]\n    end\n\n    subgraph \"Protocol Layer\"\n        Request[JSON-RPC Request]\n        Response[JSON-RPC Response]\n        ProtocolError[Protocol Error]\n    end\n\n    subgraph \"Models Layer\"\n        AgentCard[Agent Card]\n        Task[Task]\n        Message[Message]\n        Parts[Parts: Text/File/Data]\n        Artifact[Artifact]\n    end\n\n    Client --&gt; ClientBase\n    Server --&gt; ServerBase\n\n    ClientBase --&gt; Request\n    ClientBase --&gt; Response\n    ServerBase --&gt; Request\n    ServerBase --&gt; Response\n\n    Request --&gt; Task\n    Response --&gt; Task\n    Task --&gt; Message\n    Task --&gt; Artifact\n    Message --&gt; Parts\n    Artifact --&gt; Parts\n\n    style ClientBase fill:#e1f5ff\n    style ServerBase fill:#e1f5ff\n    style Request fill:#ffe1e1\n    style Response fill:#ffe1e1\n    style Task fill:#e1ffe1\n    style Message fill:#e1ffe1</code></pre>"},{"location":"architecture/#layered-architecture","title":"Layered Architecture","text":""},{"location":"architecture/#layer-1-models-layer-liba2amodels","title":"Layer 1: Models Layer (<code>lib/a2a/models/</code>)","text":"<p>The foundation layer containing all data models that represent the A2A protocol's domain concepts. These models are pure data structures with validation and serialization logic.</p> <p>Key Components: - AgentCard: Agent metadata and discovery information - Task: Central unit of work with unique ID and state progression - Message: Communication turns between user and agent - Parts: Polymorphic content types (Text, File, Data) - Artifact: Agent-generated outputs - Supporting Models: TaskState, TaskStatus, Capabilities, Skills, etc.</p>"},{"location":"architecture/#layer-2-protocol-layer-liba2aprotocol","title":"Layer 2: Protocol Layer (<code>lib/a2a/protocol/</code>)","text":"<p>Implements the JSON-RPC 2.0 transport protocol used by A2A. This layer is responsible for request/response formatting and error handling.</p> <p>Key Components: - Request: JSON-RPC 2.0 request wrapper - Response: JSON-RPC 2.0 response wrapper - Error: Protocol-level error representation</p>"},{"location":"architecture/#layer-3-interface-layer-liba2aclient-liba2aserver","title":"Layer 3: Interface Layer (<code>lib/a2a/client/</code> &amp; <code>lib/a2a/server/</code>)","text":"<p>Provides base classes that define the interface for building A2A clients and servers. These are abstract classes meant to be extended by concrete implementations.</p> <p>Key Components: - Client::Base: Defines client operations (discover, send_task, get_task, etc.) - Server::Base: Defines server request handlers (handle_send_task, handle_get_task, etc.)</p>"},{"location":"architecture/#layer-4-application-layer","title":"Layer 4: Application Layer","text":"<p>User implementations that extend the base client and server classes to create concrete A2A applications.</p>"},{"location":"architecture/#component-structure","title":"Component Structure","text":""},{"location":"architecture/#models-component-architecture","title":"Models Component Architecture","text":"<pre><code>graph TD\n    subgraph \"Discovery &amp; Identity\"\n        AgentCard[AgentCard]\n        AgentCapabilities[Agent Capabilities]\n        AgentSkill[Agent Skill]\n        AgentProvider[Agent Provider]\n        AgentAuth[Agent Authentication]\n    end\n\n    subgraph \"Task Lifecycle\"\n        Task[Task]\n        TaskStatus[Task Status]\n        TaskState[Task State]\n    end\n\n    subgraph \"Communication\"\n        Message[Message]\n        Part[Part - Abstract Base]\n        TextPart[Text Part]\n        FilePart[File Part]\n        DataPart[Data Part]\n        FileContent[File Content]\n    end\n\n    subgraph \"Outputs\"\n        Artifact[Artifact]\n    end\n\n    subgraph \"Configuration\"\n        PushNotifConfig[Push Notification Config]\n    end\n\n    AgentCard --&gt; AgentCapabilities\n    AgentCard --&gt; AgentSkill\n    AgentCard --&gt; AgentProvider\n    AgentCard --&gt; AgentAuth\n\n    Task --&gt; TaskStatus\n    TaskStatus --&gt; TaskState\n    Task --&gt; Artifact\n\n    Message --&gt; Part\n    Artifact --&gt; Part\n    Part --&gt; TextPart\n    Part --&gt; FilePart\n    Part --&gt; DataPart\n    FilePart --&gt; FileContent\n\n    style Part fill:#fff3cd\n    style Task fill:#d4edda\n    style AgentCard fill:#d1ecf1</code></pre>"},{"location":"architecture/#protocol-component-architecture","title":"Protocol Component Architecture","text":"<pre><code>graph LR\n    subgraph \"JSON-RPC 2.0 Protocol\"\n        Request[Request&lt;br/&gt;jsonrpc: 2.0&lt;br/&gt;id: string&lt;br/&gt;method: string&lt;br/&gt;params: object]\n        Response[Response&lt;br/&gt;jsonrpc: 2.0&lt;br/&gt;id: string&lt;br/&gt;result: object&lt;br/&gt;error: object]\n        Error[Error&lt;br/&gt;code: number&lt;br/&gt;message: string&lt;br/&gt;data: object]\n    end\n\n    Request --&gt;|Success| Response\n    Request --&gt;|Failure| Error\n\n    style Request fill:#cfe2ff\n    style Response fill:#d1e7dd\n    style Error fill:#f8d7da</code></pre>"},{"location":"architecture/#clientserver-architecture","title":"Client/Server Architecture","text":"<pre><code>graph TB\n    subgraph \"Client Layer\"\n        ClientBase[Client::Base&lt;br/&gt;Abstract Interface]\n        ClientImpl[Concrete Client&lt;br/&gt;Implementation]\n    end\n\n    subgraph \"Server Layer\"\n        ServerBase[Server::Base&lt;br/&gt;Abstract Interface]\n        ServerImpl[Concrete Server&lt;br/&gt;Implementation]\n    end\n\n    subgraph \"Protocol Methods\"\n        Discovery[/.well-known/agent.json]\n        SendTask[tasks/send]\n        SendStream[tasks/sendSubscribe]\n        GetTask[tasks/get]\n        CancelTask[tasks/cancel]\n        SetPushNotif[tasks/pushNotification/set]\n        GetPushNotif[tasks/pushNotification/get]\n        Resubscribe[tasks/resubscribe]\n    end\n\n    ClientImpl -.extends.-&gt; ClientBase\n    ServerImpl -.extends.-&gt; ServerBase\n\n    ClientBase --&gt; Discovery\n    ClientBase --&gt; SendTask\n    ClientBase --&gt; SendStream\n    ClientBase --&gt; GetTask\n    ClientBase --&gt; CancelTask\n    ClientBase --&gt; SetPushNotif\n    ClientBase --&gt; GetPushNotif\n\n    ServerBase --&gt; Discovery\n    ServerBase --&gt; SendTask\n    ServerBase --&gt; SendStream\n    ServerBase --&gt; GetTask\n    ServerBase --&gt; CancelTask\n    ServerBase --&gt; SetPushNotif\n    ServerBase --&gt; GetPushNotif\n    ServerBase --&gt; Resubscribe\n\n    style ClientBase fill:#e1f5ff\n    style ServerBase fill:#e1f5ff\n    style ClientImpl fill:#cfe2ff\n    style ServerImpl fill:#cfe2ff</code></pre>"},{"location":"architecture/#directory-organization","title":"Directory Organization","text":"<p>The gem follows a clear directory structure that mirrors the architectural layers:</p> <pre><code>lib/a2a/\n\u251c\u2500\u2500 version.rb                    # Gem version constant\n\u251c\u2500\u2500 error.rb                      # Error class hierarchy\n\u2502\n\u251c\u2500\u2500 models/                       # Layer 1: Data Models\n\u2502   \u251c\u2500\u2500 agent_card.rb            # Agent metadata\n\u2502   \u251c\u2500\u2500 agent_capabilities.rb    # Agent capabilities\n\u2502   \u251c\u2500\u2500 agent_skill.rb           # Agent skill definition\n\u2502   \u251c\u2500\u2500 agent_provider.rb        # Provider information\n\u2502   \u251c\u2500\u2500 agent_authentication.rb  # Authentication config\n\u2502   \u251c\u2500\u2500 task.rb                  # Task (central unit of work)\n\u2502   \u251c\u2500\u2500 task_status.rb           # Task status with state\n\u2502   \u251c\u2500\u2500 task_state.rb            # Task state enum\n\u2502   \u251c\u2500\u2500 message.rb               # Communication turns\n\u2502   \u251c\u2500\u2500 part.rb                  # Base class for parts\n\u2502   \u251c\u2500\u2500 text_part.rb             # Text content\n\u2502   \u251c\u2500\u2500 file_part.rb             # File content\n\u2502   \u251c\u2500\u2500 file_content.rb          # File representation\n\u2502   \u251c\u2500\u2500 data_part.rb             # Structured data\n\u2502   \u251c\u2500\u2500 artifact.rb              # Agent outputs\n\u2502   \u2514\u2500\u2500 push_notification_config.rb\n\u2502\n\u251c\u2500\u2500 protocol/                     # Layer 2: JSON-RPC Protocol\n\u2502   \u251c\u2500\u2500 request.rb               # JSON-RPC request\n\u2502   \u251c\u2500\u2500 response.rb              # JSON-RPC response\n\u2502   \u251c\u2500\u2500 error.rb                 # Protocol error\n\u2502   \u251c\u2500\u2500 requests/                # Specific request types (future)\n\u2502   \u251c\u2500\u2500 responses/               # Specific response types (future)\n\u2502   \u2514\u2500\u2500 events/                  # SSE events (future)\n\u2502\n\u251c\u2500\u2500 client/                       # Layer 3a: Client Interface\n\u2502   \u2514\u2500\u2500 base.rb                  # Abstract client class\n\u2502\n\u251c\u2500\u2500 server/                       # Layer 3b: Server Interface\n\u2502   \u2514\u2500\u2500 base.rb                  # Abstract server class\n\u2502\n\u2514\u2500\u2500 utils/                        # Utilities (future)\n    \u251c\u2500\u2500 json_schema_validator.rb\n    \u2514\u2500\u2500 serializer.rb\n</code></pre> <p>This structure provides: - Clear Separation: Each layer has its own directory - Easy Navigation: Related files are grouped together - Scalability: New components can be added without restructuring - Discoverability: Developers can quickly find what they need</p>"},{"location":"architecture/#key-architectural-patterns","title":"Key Architectural Patterns","text":""},{"location":"architecture/#1-factory-pattern","title":"1. Factory Pattern","text":"<p>The <code>Part</code> class uses the Factory pattern to create appropriate part types:</p> <pre><code># Part.from_hash determines which subclass to instantiate\ndef self.from_hash(hash)\n  case hash[:type]\n  when 'text' then TextPart.from_hash(hash)\n  when 'file' then FilePart.from_hash(hash)\n  when 'data' then DataPart.from_hash(hash)\n  end\nend\n</code></pre> <p>Why: Enables polymorphic handling of different content types while maintaining type safety.</p>"},{"location":"architecture/#2-value-object-pattern","title":"2. Value Object Pattern","text":"<p>Models like <code>TaskState</code> and <code>FileContent</code> are immutable value objects:</p> <pre><code>class TaskState\n  attr_reader :value\n\n  def initialize(value)\n    @value = validate_state(value)\n  end\n\n  # Immutable - no setters\nend\n</code></pre> <p>Why: Ensures data integrity and makes state transitions explicit and trackable.</p>"},{"location":"architecture/#3-builderconvenience-methods","title":"3. Builder/Convenience Methods","text":"<p>Models provide convenience constructors for common use cases:</p> <pre><code># Message.text() provides a shorthand for text messages\ndef self.text(role:, text:, metadata: nil)\n  new(\n    role: role,\n    parts: [TextPart.new(text: text)],\n    metadata: metadata\n  )\nend\n</code></pre> <p>Why: Improves developer experience and reduces boilerplate code.</p>"},{"location":"architecture/#4-template-method-pattern","title":"4. Template Method Pattern","text":"<p>Base client and server classes define the interface that subclasses must implement:</p> <pre><code>class Base\n  def send_task(task_id:, message:, session_id: nil)\n    raise NotImplementedError, \"Subclasses must implement #send_task\"\n  end\nend\n</code></pre> <p>Why: Enforces consistent API across different implementations while allowing customization.</p>"},{"location":"architecture/#5-data-mapper-pattern","title":"5. Data Mapper Pattern","text":"<p>All models implement <code>to_h</code>, <code>to_json</code>, and <code>from_hash</code> for serialization:</p> <pre><code>class Task\n  def to_h\n    { id: id, status: status.to_h, artifacts: artifacts&amp;.map(&amp;:to_h) }.compact\n  end\n\n  def self.from_hash(hash)\n    new(id: hash[:id], status: TaskStatus.from_hash(hash[:status]))\n  end\nend\n</code></pre> <p>Why: Enables seamless conversion between Ruby objects and JSON protocol messages.</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#client-request-flow","title":"Client Request Flow","text":"<pre><code>sequenceDiagram\n    participant App as Application Code\n    participant Client as A2A Client\n    participant Protocol as Protocol Layer\n    participant Models as Models Layer\n    participant Network as Network/HTTP\n\n    App-&gt;&gt;Models: Create Message\n    Models--&gt;&gt;App: Message object\n\n    App-&gt;&gt;Client: send_task(message)\n    Client-&gt;&gt;Models: Create Task\n    Client-&gt;&gt;Protocol: Create Request\n    Protocol--&gt;&gt;Client: JSON-RPC Request\n\n    Client-&gt;&gt;Network: HTTP POST\n    Network--&gt;&gt;Client: HTTP Response\n\n    Client-&gt;&gt;Protocol: Parse Response\n    Protocol-&gt;&gt;Models: from_hash()\n    Models--&gt;&gt;Protocol: Task object\n    Protocol--&gt;&gt;Client: Task\n    Client--&gt;&gt;App: Task</code></pre>"},{"location":"architecture/#server-request-handling-flow","title":"Server Request Handling Flow","text":"<pre><code>sequenceDiagram\n    participant Network as Network/HTTP\n    participant Server as A2A Server\n    participant Protocol as Protocol Layer\n    participant Handler as Request Handler\n    participant Models as Models Layer\n    participant Logic as Business Logic\n\n    Network-&gt;&gt;Server: HTTP Request\n    Server-&gt;&gt;Protocol: Parse JSON-RPC\n    Protocol--&gt;&gt;Server: Request object\n\n    Server-&gt;&gt;Handler: Route to handler\n    Handler-&gt;&gt;Models: from_hash(params)\n    Models--&gt;&gt;Handler: Domain objects\n\n    Handler-&gt;&gt;Logic: Process task\n    Logic--&gt;&gt;Handler: Results\n\n    Handler-&gt;&gt;Models: Create Task\n    Models--&gt;&gt;Handler: Task object\n\n    Handler-&gt;&gt;Protocol: Create Response\n    Protocol--&gt;&gt;Server: JSON-RPC Response\n    Server-&gt;&gt;Network: HTTP Response</code></pre>"},{"location":"architecture/#model-composition-flow","title":"Model Composition Flow","text":"<pre><code>graph LR\n    subgraph \"Task Composition\"\n        T[Task] --&gt; TS[Task Status]\n        T --&gt; A[Artifact Array]\n        TS --&gt; TSt[Task State]\n    end\n\n    subgraph \"Message Composition\"\n        M[Message] --&gt; P[Part Array]\n        P --&gt; TP[Text Part]\n        P --&gt; FP[File Part]\n        P --&gt; DP[Data Part]\n        FP --&gt; FC[File Content]\n    end\n\n    subgraph \"Agent Card Composition\"\n        AC[Agent Card] --&gt; ACap[Capabilities]\n        AC --&gt; AS[Skill Array]\n        AC --&gt; AP[Provider]\n        AC --&gt; AA[Authentication]\n    end\n\n    T --&gt; M\n    A --&gt; P\n\n    style T fill:#d4edda\n    style M fill:#d4edda\n    style AC fill:#d1ecf1</code></pre>"},{"location":"architecture/#related-documentation","title":"Related Documentation","text":"<p>For more detailed information, see:</p> <ul> <li>Design Principles and Decisions - Deep dive into design choices</li> <li>Protocol Flow and Sequence Diagrams - Detailed protocol interactions</li> <li>Gem Architecture - Gem architecture document</li> <li>Getting Started Guide - How to use the gem</li> <li>A2A Protocol Specification - Official protocol docs</li> </ul> <p>Back to Documentation Home</p>"},{"location":"architecture/design/","title":"A2A Ruby Gem - Design Principles and Decisions","text":"<p>This document provides an in-depth exploration of the design principles, patterns, and architectural decisions that shape the A2A Ruby gem.</p>"},{"location":"architecture/design/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Core Design Principles</li> <li>Architectural Decisions</li> <li>Design Patterns</li> <li>Error Handling Strategy</li> <li>Type System and Validation</li> <li>Serialization and Deserialization</li> <li>Extensibility Points</li> <li>Performance Considerations</li> <li>Testing Strategy</li> <li>Future Design Considerations</li> </ul>"},{"location":"architecture/design/#core-design-principles","title":"Core Design Principles","text":""},{"location":"architecture/design/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<p>Principle: Each component should have a single, well-defined responsibility.</p> <p>Implementation: - Models handle data representation and validation - Protocol layer manages JSON-RPC formatting - Client/Server layers define interfaces - Business logic lives in user implementations</p> <p>Rationale: This separation makes the codebase easier to understand, test, and modify. Changes to one layer don't cascade to others.</p> <pre><code>graph TD\n    subgraph \"Concerns Separated by Layer\"\n        M[Models&lt;br/&gt;Data &amp; Validation]\n        P[Protocol&lt;br/&gt;Message Formatting]\n        I[Interfaces&lt;br/&gt;API Definition]\n        A[Application&lt;br/&gt;Business Logic]\n    end\n\n    M -.-&gt;|Used by| P\n    P -.-&gt;|Used by| I\n    I -.-&gt;|Implemented by| A\n\n    style M fill:#e1ffe1\n    style P fill:#ffe1e1\n    style I fill:#e1f5ff\n    style A fill:#fff3cd</code></pre>"},{"location":"architecture/design/#2-protocol-compliance","title":"2. Protocol Compliance","text":"<p>Principle: Strictly adhere to the A2A protocol specification and JSON-RPC 2.0 standard.</p> <p>Implementation: - All JSON serialization uses camelCase as per protocol spec - Error codes match JSON-RPC and A2A specifications exactly - Request/Response structures follow JSON-RPC 2.0 format - Models map directly to protocol JSON schemas</p> <p>Rationale: Ensures interoperability with any A2A-compliant implementation, regardless of language or framework.</p>"},{"location":"architecture/design/#3-testability","title":"3. Testability","text":"<p>Principle: Every component should be independently testable in isolation.</p> <p>Implementation: - Pure data models with no side effects - Dependency injection for collaborators - Clear interfaces defined by base classes - Factory methods that can be mocked</p> <p>Rationale: Isolated testing leads to faster test suites, better coverage, and easier debugging.</p>"},{"location":"architecture/design/#4-extensibility","title":"4. Extensibility","text":"<p>Principle: The gem should be easy to extend without modifying existing code.</p> <p>Implementation: - Abstract base classes for Client and Server - Factory pattern for polymorphic types - Open/Closed principle: open for extension, closed for modification - Hook methods for customization</p> <p>Rationale: Allows users to build on the gem without forking or monkey-patching.</p>"},{"location":"architecture/design/#5-type-safety","title":"5. Type Safety","text":"<p>Principle: Leverage Ruby's type system and RBS for reliability.</p> <p>Implementation: - Value objects for domain concepts (TaskState, FileContent) - Immutable models where appropriate - RBS type signatures for all public APIs - Validation at object construction time</p> <p>Rationale: Catches errors early and provides better IDE support and documentation.</p>"},{"location":"architecture/design/#architectural-decisions","title":"Architectural Decisions","text":""},{"location":"architecture/design/#adr-001-layered-architecture-over-flat-structure","title":"ADR-001: Layered Architecture Over Flat Structure","text":"<p>Context: Need to organize code for a protocol implementation with multiple concerns.</p> <p>Decision: Use a four-layer architecture (Models, Protocol, Interface, Application).</p> <p>Consequences: - Positive: Clear separation of concerns, easier navigation, better testability - Negative: More files and directories, steeper learning curve for simple use cases - Mitigation: Comprehensive documentation and examples</p>"},{"location":"architecture/design/#adr-002-immutable-value-objects-for-states","title":"ADR-002: Immutable Value Objects for States","text":"<p>Context: Task states need to be tracked and compared throughout the lifecycle.</p> <p>Decision: Implement TaskState as an immutable value object.</p> <pre><code>class TaskState\n  STATES = %w[submitted working input-required completed canceled failed unknown].freeze\n\n  attr_reader :value\n\n  def initialize(value)\n    @value = validate_state(value)\n  end\n\n  # Predicate methods for each state\n  def submitted?\n    @value == 'submitted'\n  end\n\n  def terminal?\n    completed? || canceled? || failed?\n  end\nend\n</code></pre> <p>Consequences: - Positive: Thread-safe, easier to reason about, explicit state transitions - Negative: Must create new objects for state changes - Mitigation: State objects are lightweight and creation is fast</p>"},{"location":"architecture/design/#adr-003-factory-pattern-for-polymorphic-parts","title":"ADR-003: Factory Pattern for Polymorphic Parts","text":"<p>Context: Messages and Artifacts contain Parts that can be Text, File, or Data types.</p> <p>Decision: Use Factory pattern in Part.from_hash() to instantiate correct subclass.</p> <pre><code>class Part\n  def self.from_hash(hash)\n    case hash[:type]\n    when 'text' then TextPart.from_hash(hash)\n    when 'file' then FilePart.from_hash(hash)\n    when 'data' then DataPart.from_hash(hash)\n    else raise ArgumentError, \"Unknown part type: #{hash[:type]}\"\n    end\n  end\nend\n</code></pre> <p>Consequences: - Positive: Type-safe polymorphism, single deserialization entry point - Negative: Must update factory when adding new part types - Mitigation: Comprehensive tests ensure all types are handled</p>"},{"location":"architecture/design/#adr-004-abstract-base-classes-for-clientserver","title":"ADR-004: Abstract Base Classes for Client/Server","text":"<p>Context: Users need to implement A2A clients and servers with custom transport.</p> <p>Decision: Provide abstract base classes that raise NotImplementedError.</p> <pre><code>class Client::Base\n  def send_task(task_id:, message:, session_id: nil)\n    raise NotImplementedError, \"Subclasses must implement #send_task\"\n  end\nend\n</code></pre> <p>Consequences: - Positive: Clear contract, documentation through code, enforces implementation - Negative: Requires subclassing, more verbose than modules - Mitigation: Provide comprehensive examples and documentation</p>"},{"location":"architecture/design/#adr-005-dual-serialization-format-support","title":"ADR-005: Dual Serialization Format Support","text":"<p>Context: Need to support both Ruby hash and JSON string formats.</p> <p>Decision: Implement both to_h/from_hash and to_json methods.</p> <pre><code>class Task\n  def to_h\n    { id: id, status: status.to_h }.compact\n  end\n\n  def to_json(*args)\n    to_h.to_json(*args)\n  end\n\n  def self.from_hash(hash)\n    # Support both symbol and string keys\n    new(id: hash[:id] || hash['id'])\n  end\nend\n</code></pre> <p>Consequences: - Positive: Flexible for different use cases, works with JSON libraries - Negative: More code to maintain - Mitigation: Consistent pattern across all models</p>"},{"location":"architecture/design/#adr-006-comprehensive-error-hierarchy","title":"ADR-006: Comprehensive Error Hierarchy","text":"<p>Context: Need to handle both protocol-level and application-level errors.</p> <p>Decision: Create error hierarchy matching JSON-RPC and A2A specifications.</p> <pre><code>graph TD\n    Error[A2A::Error&lt;br/&gt;Base Class]\n    JSONRPC[A2A::JSONRPCError&lt;br/&gt;code, data]\n\n    Error --&gt; JSONRPC\n\n    JSONRPC --&gt; ParseError[-32700: JSON Parse Error]\n    JSONRPC --&gt; InvalidRequest[-32600: Invalid Request]\n    JSONRPC --&gt; MethodNotFound[-32601: Method Not Found]\n    JSONRPC --&gt; InvalidParams[-32602: Invalid Params]\n    JSONRPC --&gt; InternalError[-32603: Internal Error]\n\n    JSONRPC --&gt; TaskNotFound[-32001: Task Not Found]\n    JSONRPC --&gt; TaskNotCancelable[-32002: Not Cancelable]\n    JSONRPC --&gt; PushNotSupported[-32003: Push Not Supported]\n    JSONRPC --&gt; UnsupportedOp[-32004: Unsupported Operation]\n\n    style JSONRPC fill:#f8d7da\n    style Error fill:#fff3cd</code></pre> <p>Consequences: - Positive: Specific error handling, matches protocol exactly - Negative: Many error classes to maintain - Mitigation: Code generation or metaprogramming could reduce duplication</p>"},{"location":"architecture/design/#design-patterns","title":"Design Patterns","text":""},{"location":"architecture/design/#1-factory-pattern","title":"1. Factory Pattern","text":"<p>Usage: Creating polymorphic Part objects from JSON.</p> <p>Benefits: - Single entry point for deserialization - Type-safe object creation - Easy to extend with new types</p> <p>Example: <pre><code># Automatically creates the right Part subclass\npart = Part.from_hash({ type: 'text', text: 'Hello' })\n# =&gt; #&lt;A2A::Models::TextPart&gt;\n</code></pre></p>"},{"location":"architecture/design/#2-builder-pattern-convenience-methods","title":"2. Builder Pattern (Convenience Methods)","text":"<p>Usage: Simplifying common object creation scenarios.</p> <p>Benefits: - Reduces boilerplate - Makes common cases easy - Still allows full customization</p> <p>Example: <pre><code># Simple text message\nmsg = Message.text(role: 'user', text: 'Hello')\n\n# Equivalent to:\nmsg = Message.new(\n  role: 'user',\n  parts: [TextPart.new(text: 'Hello')]\n)\n</code></pre></p>"},{"location":"architecture/design/#3-template-method-pattern","title":"3. Template Method Pattern","text":"<p>Usage: Defining algorithm structure in base classes.</p> <p>Benefits: - Enforces interface contract - Allows customization at specific points - Documents expected behavior</p> <p>Example: <pre><code>class Server::Base\n  def handle_request(request)\n    # Template method defines the flow\n    parse_request(request)\n    route_to_handler(request)\n    create_response(result)\n  rescue =&gt; e\n    create_error_response(e)\n  end\n\n  # Subclasses implement specific handlers\n  def handle_send_task(params)\n    raise NotImplementedError\n  end\nend\n</code></pre></p>"},{"location":"architecture/design/#4-value-object-pattern","title":"4. Value Object Pattern","text":"<p>Usage: Representing domain concepts as immutable values.</p> <p>Benefits: - Thread-safe - Easier to reason about - Can be used as hash keys</p> <p>Example: <pre><code>state1 = TaskState.new('completed')\nstate2 = TaskState.new('completed')\n\nstate1 == state2  # =&gt; true\nstate1.completed? # =&gt; true\nstate1.terminal?  # =&gt; true\n</code></pre></p>"},{"location":"architecture/design/#5-data-mapper-pattern","title":"5. Data Mapper Pattern","text":"<p>Usage: Converting between domain objects and persistence format (JSON).</p> <p>Benefits: - Separates domain logic from serialization - Supports different formats (hash, JSON) - Easy to test</p> <p>Example: <pre><code># Domain object -&gt; Hash\ntask.to_h\n# =&gt; { id: '123', status: { state: 'completed' } }\n\n# Hash -&gt; Domain object\nTask.from_hash({ id: '123', status: { state: 'completed' } })\n# =&gt; #&lt;A2A::Models::Task&gt;\n</code></pre></p>"},{"location":"architecture/design/#error-handling-strategy","title":"Error Handling Strategy","text":""},{"location":"architecture/design/#error-categories","title":"Error Categories","text":"<pre><code>graph TD\n    subgraph \"Protocol Errors (JSON-RPC)\"\n        PE1[Parse Error -32700]\n        PE2[Invalid Request -32600]\n        PE3[Method Not Found -32601]\n        PE4[Invalid Params -32602]\n        PE5[Internal Error -32603]\n    end\n\n    subgraph \"Application Errors (A2A Specific)\"\n        AE1[Task Not Found -32001]\n        AE2[Task Not Cancelable -32002]\n        AE3[Push Notification Not Supported -32003]\n        AE4[Unsupported Operation -32004]\n    end\n\n    subgraph \"Validation Errors (Ruby)\"\n        VE1[ArgumentError]\n        VE2[TypeError]\n        VE3[KeyError]\n    end\n\n    style PE1 fill:#ffe1e1\n    style AE1 fill:#fff3cd\n    style VE1 fill:#e1f5ff</code></pre>"},{"location":"architecture/design/#error-handling-guidelines","title":"Error Handling Guidelines","text":"<ol> <li>Validation Errors: Raise immediately at construction time</li> <li>Protocol Errors: Return as JSON-RPC error responses</li> <li>Application Errors: Use specific A2A error classes</li> <li>Unknown Errors: Wrap in InternalError with original message</li> </ol>"},{"location":"architecture/design/#type-system-and-validation","title":"Type System and Validation","text":""},{"location":"architecture/design/#validation-strategy","title":"Validation Strategy","text":"<p>When to Validate: - At object construction (fail fast) - Before serialization (ensure valid output) - After deserialization (ensure valid input)</p> <p>What to Validate: - Required fields are present - Enums match allowed values - Data types are correct - Business rules are satisfied</p> <p>Example: <pre><code>class Message\n  ROLES = %w[user agent].freeze\n\n  def initialize(role:, parts:, metadata: nil)\n    validate_role(role)\n    validate_parts(parts)\n\n    @role = role\n    @parts = normalize_parts(parts)\n    @metadata = metadata\n  end\n\n  private\n\n  def validate_role(role)\n    unless ROLES.include?(role)\n      raise ArgumentError, \"Invalid role: #{role}\"\n    end\n  end\n\n  def validate_parts(parts)\n    raise ArgumentError, \"Parts cannot be empty\" if parts.empty?\n  end\nend\n</code></pre></p>"},{"location":"architecture/design/#rbs-type-signatures","title":"RBS Type Signatures","text":"<p>The gem uses RBS for type definitions:</p> <pre><code># sig/a2a/models/task.rbs\nmodule A2A\n  module Models\n    class Task\n      attr_reader id: String\n      attr_reader session_id: String?\n      attr_reader status: TaskStatus\n      attr_reader artifacts: Array[Artifact]?\n\n      def initialize: (\n        id: String,\n        status: TaskStatus | Hash[Symbol, untyped],\n        ?session_id: String?,\n        ?artifacts: Array[Artifact]?,\n        ?metadata: Hash[Symbol, untyped]?\n      ) -&gt; void\n\n      def state: () -&gt; TaskState\n      def to_h: () -&gt; Hash[Symbol, untyped]\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/design/#serialization-and-deserialization","title":"Serialization and Deserialization","text":""},{"location":"architecture/design/#serialization-strategy","title":"Serialization Strategy","text":"<pre><code>graph LR\n    RubyObject[Ruby Object] --&gt;|to_h| Hash[Ruby Hash]\n    Hash --&gt;|to_json| JSON[JSON String]\n\n    JSON --&gt;|parse| Hash2[Ruby Hash]\n    Hash2 --&gt;|from_hash| RubyObject2[Ruby Object]\n\n    style RubyObject fill:#d4edda\n    style JSON fill:#f8d7da\n    style Hash fill:#fff3cd</code></pre>"},{"location":"architecture/design/#key-naming-convention","title":"Key Naming Convention","text":"<p>Ruby: Use snake_case for internal representation JSON: Use camelCase for protocol compliance</p> <pre><code>def to_h\n  {\n    sessionId: session_id,        # snake_case -&gt; camelCase\n    taskId: task_id,\n    documentationUrl: documentation_url\n  }.compact\nend\n\ndef self.from_hash(hash)\n  new(\n    session_id: hash[:sessionId] || hash['sessionId'] || hash[:session_id],\n    task_id: hash[:taskId] || hash['taskId'] || hash[:task_id]\n  )\nend\n</code></pre>"},{"location":"architecture/design/#compact-hash-strategy","title":"Compact Hash Strategy","text":"<p>Use <code>.compact</code> to remove nil values, making JSON cleaner:</p> <pre><code>def to_h\n  {\n    id: id,\n    sessionId: session_id,    # nil values removed\n    metadata: metadata         # nil values removed\n  }.compact\nend\n</code></pre>"},{"location":"architecture/design/#extensibility-points","title":"Extensibility Points","text":""},{"location":"architecture/design/#1-adding-new-part-types","title":"1. Adding New Part Types","text":"<p>To add a new part type (e.g., VideoPart):</p> <pre><code># 1. Create the part class\nclass VideoPart &lt; Part\n  attr_reader :video_url, :duration\n\n  def initialize(video_url:, duration: nil, metadata: nil)\n    super(metadata: metadata)\n    @video_url = video_url\n    @duration = duration\n  end\n\n  def type\n    'video'\n  end\n\n  def to_h\n    super.merge(videoUrl: video_url, duration: duration)\n  end\n\n  def self.from_hash(hash)\n    new(\n      video_url: hash[:videoUrl] || hash['videoUrl'],\n      duration: hash[:duration] || hash['duration'],\n      metadata: hash[:metadata] || hash['metadata']\n    )\n  end\nend\n\n# 2. Update the factory\nclass Part\n  def self.from_hash(hash)\n    case hash[:type]\n    when 'text' then TextPart.from_hash(hash)\n    when 'file' then FilePart.from_hash(hash)\n    when 'data' then DataPart.from_hash(hash)\n    when 'video' then VideoPart.from_hash(hash)  # Add new type\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/design/#2-implementing-custom-clients","title":"2. Implementing Custom Clients","text":"<pre><code>class HttpClient &lt; A2A::Client::Base\n  def initialize(agent_url)\n    super(agent_url)\n    @http_client = Net::HTTP\n  end\n\n  def discover\n    response = @http_client.get(\"#{agent_url}/.well-known/agent.json\")\n    @agent_card = AgentCard.from_hash(JSON.parse(response.body))\n  end\n\n  def send_task(task_id:, message:, session_id: nil)\n    request = Protocol::Request.new(\n      method: 'tasks/send',\n      params: { taskId: task_id, message: message.to_h },\n      id: SecureRandom.uuid\n    )\n\n    response = @http_client.post(agent_url, request.to_json)\n    # Parse and return Task\n  end\nend\n</code></pre>"},{"location":"architecture/design/#3-implementing-custom-servers","title":"3. Implementing Custom Servers","text":"<pre><code>class RackServer &lt; A2A::Server::Base\n  def call(env)\n    request_body = env['rack.input'].read\n    request = JSON.parse(request_body)\n\n    response = handle_request(request)\n\n    [200, { 'Content-Type' =&gt; 'application/json' }, [response.to_json]]\n  end\n\n  def handle_request(request)\n    case request['method']\n    when 'tasks/send'\n      result = handle_send_task(request['params'])\n      Protocol::Response.success(id: request['id'], result: result)\n    else\n      Protocol::Response.error(\n        id: request['id'],\n        error: { code: -32601, message: 'Method not found' }\n      )\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/design/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/design/#object-allocation","title":"Object Allocation","text":"<p>Strategy: Minimize object creation in hot paths.</p> <p>Implementation: - Reuse frozen constants for enums - Use compact for conditional hash keys - Lazy load dependencies</p> <pre><code># Good: Reuse frozen constant\nSTATES = %w[submitted working completed].freeze\n\n# Good: Compact removes nils without extra allocations\n{ id: id, sessionId: session_id }.compact\n\n# Avoid: Creating new arrays unnecessarily\n# Bad: parts.map { |p| p.to_h }.select { |h| h.present? }\n# Good: parts.map(&amp;:to_h).compact\n</code></pre>"},{"location":"architecture/design/#json-serialization","title":"JSON Serialization","text":"<p>Strategy: Let the JSON library handle serialization efficiently.</p> <p>Implementation: - Provide to_h that returns primitive types - Let JSON.generate handle the serialization - Avoid custom JSON encoding unless necessary</p>"},{"location":"architecture/design/#memory-efficiency","title":"Memory Efficiency","text":"<p>Strategy: Use value objects and immutability to enable sharing.</p> <p>Implementation: - Immutable TaskState instances can be shared - Frozen string literals reduce duplication - Compact hashes avoid storing nil values</p>"},{"location":"architecture/design/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/design/#unit-tests","title":"Unit Tests","text":"<p>Test each component in isolation:</p> <pre><code>RSpec.describe A2A::Models::Task do\n  describe '#state' do\n    it 'returns the task state from status' do\n      task = described_class.new(\n        id: 'task-1',\n        status: { state: 'completed' }\n      )\n\n      expect(task.state).to be_completed\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/design/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between components:</p> <pre><code>RSpec.describe 'Task serialization' do\n  it 'round-trips through JSON' do\n    original = A2A::Models::Task.new(\n      id: 'task-1',\n      status: { state: 'working' }\n    )\n\n    json = original.to_json\n    restored = A2A::Models::Task.from_hash(JSON.parse(json))\n\n    expect(restored.id).to eq(original.id)\n    expect(restored.state).to eq(original.state)\n  end\nend\n</code></pre>"},{"location":"architecture/design/#contract-tests","title":"Contract Tests","text":"<p>Verify protocol compliance:</p> <pre><code>RSpec.describe 'A2A Protocol Compliance' do\n  it 'matches JSON schema for Task' do\n    task = create_task\n    schema = load_schema('task.json')\n\n    expect(task.to_h).to match_json_schema(schema)\n  end\nend\n</code></pre>"},{"location":"architecture/design/#future-design-considerations","title":"Future Design Considerations","text":""},{"location":"architecture/design/#1-json-schema-validation","title":"1. JSON Schema Validation","text":"<p>Goal: Validate all protocol messages against official schemas.</p> <p>Approach: - Load schemas from protocol_specification/json/ - Validate on serialization and deserialization - Provide helpful error messages on validation failure</p>"},{"location":"architecture/design/#2-streaming-support","title":"2. Streaming Support","text":"<p>Goal: Implement Server-Sent Events (SSE) for real-time updates.</p> <p>Approach: - Add SSE event classes to protocol/events/ - Implement streaming in client and server base classes - Handle connection lifecycle and reconnection</p>"},{"location":"architecture/design/#3-webhook-support","title":"3. Webhook Support","text":"<p>Goal: Enable push notifications for task updates.</p> <p>Approach: - Add webhook configuration to server - Implement retry logic for failed deliveries - Support webhook authentication</p>"},{"location":"architecture/design/#4-logging-and-observability","title":"4. Logging and Observability","text":"<p>Goal: Comprehensive logging for debugging and monitoring.</p> <p>Approach: - Add structured logging throughout - Support custom loggers - Include request/response IDs for tracing</p>"},{"location":"architecture/design/#5-connection-pooling","title":"5. Connection Pooling","text":"<p>Goal: Efficient HTTP client connection management.</p> <p>Approach: - Support connection pooling in HTTP client - Configure timeouts and retry policies - Handle connection failures gracefully</p>"},{"location":"architecture/design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview - High-level architecture and components</li> <li>Protocol Flow and Sequences - Detailed interaction diagrams</li> <li>Gem Architecture - Gem architecture document</li> </ul> <p>Back to Documentation Home</p>"},{"location":"architecture/flow/","title":"A2A Ruby Gem - Protocol Flow and Sequence Diagrams","text":"<p>This document provides detailed sequence diagrams and flow charts illustrating how the A2A protocol operates in various scenarios.</p>"},{"location":"architecture/flow/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Protocol Overview</li> <li>Discovery Flow</li> <li>Task Lifecycle</li> <li>Synchronous Task Flow</li> <li>Streaming Task Flow</li> <li>Multi-Turn Conversation Flow</li> <li>Error Handling Flows</li> <li>Push Notification Flow</li> <li>Task Cancellation Flow</li> <li>State Transitions</li> <li>Component Interactions</li> </ul>"},{"location":"architecture/flow/#protocol-overview","title":"Protocol Overview","text":"<p>The A2A protocol is built on JSON-RPC 2.0 and uses HTTP as the transport layer. The protocol defines several methods for task management and communication between clients and agents.</p>"},{"location":"architecture/flow/#core-protocol-methods","title":"Core Protocol Methods","text":"<pre><code>graph TD\n    subgraph \"Discovery\"\n        D[GET /.well-known/agent.json]\n    end\n\n    subgraph \"Task Management\"\n        TS[tasks/send]\n        TSS[tasks/sendSubscribe]\n        TG[tasks/get]\n        TC[tasks/cancel]\n        TR[tasks/resubscribe]\n    end\n\n    subgraph \"Push Notifications\"\n        PNS[tasks/pushNotification/set]\n        PNG[tasks/pushNotification/get]\n    end\n\n    style D fill:#d1ecf1\n    style TS fill:#d4edda\n    style TSS fill:#fff3cd\n    style TC fill:#f8d7da</code></pre>"},{"location":"architecture/flow/#discovery-flow","title":"Discovery Flow","text":"<p>Before a client can interact with an agent, it must discover the agent's capabilities through the AgentCard.</p>"},{"location":"architecture/flow/#agent-discovery-sequence","title":"Agent Discovery Sequence","text":"<pre><code>sequenceDiagram\n    participant Client as A2A Client\n    participant HTTP as HTTP Transport\n    participant Server as A2A Server\n    participant FS as File System\n\n    Note over Client: Discovery Phase\n    Client-&gt;&gt;HTTP: GET /.well-known/agent.json\n    HTTP-&gt;&gt;Server: HTTP GET Request\n\n    Server-&gt;&gt;FS: Read agent.json\n    FS--&gt;&gt;Server: AgentCard data\n\n    Server--&gt;&gt;HTTP: 200 OK + AgentCard JSON\n    HTTP--&gt;&gt;Client: AgentCard Response\n\n    Note over Client: Parse AgentCard\n    Client-&gt;&gt;Client: AgentCard.from_hash(json)\n    Client-&gt;&gt;Client: Validate capabilities\n    Client-&gt;&gt;Client: Store agent metadata\n\n    Note over Client: Ready to send tasks</code></pre>"},{"location":"architecture/flow/#discovery-implementation-flow","title":"Discovery Implementation Flow","text":"<pre><code>graph TD\n    Start[Client.discover] --&gt; BuildURL[Build well-known URL]\n    BuildURL --&gt; HTTPGet[HTTP GET Request]\n    HTTPGet --&gt; ParseJSON[Parse JSON Response]\n    ParseJSON --&gt; CreateCard[AgentCard.from_hash]\n    CreateCard --&gt; ValidateCap[Validate Capabilities]\n    ValidateCap --&gt; StoreCard[Store agent_card]\n    StoreCard --&gt; End[Return AgentCard]\n\n    style Start fill:#e1f5ff\n    style CreateCard fill:#d1ecf1\n    style End fill:#d4edda</code></pre>"},{"location":"architecture/flow/#task-lifecycle","title":"Task Lifecycle","text":"<p>Tasks progress through a series of states from submission to completion.</p>"},{"location":"architecture/flow/#task-state-machine","title":"Task State Machine","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; submitted: Client sends task\n\n    submitted --&gt; working: Agent starts processing\n    submitted --&gt; failed: Validation error\n    submitted --&gt; canceled: Client cancels\n\n    working --&gt; input-required: Agent needs more info\n    working --&gt; completed: Processing successful\n    working --&gt; failed: Processing error\n    working --&gt; canceled: Client cancels\n\n    input-required --&gt; working: Client provides input\n    input-required --&gt; canceled: Client cancels\n    input-required --&gt; failed: Timeout/error\n\n    completed --&gt; [*]: Terminal state\n    failed --&gt; [*]: Terminal state\n    canceled --&gt; [*]: Terminal state\n    unknown --&gt; [*]: Terminal state\n\n    note right of completed\n        Terminal States:\n        - completed\n        - failed\n        - canceled\n    end note</code></pre>"},{"location":"architecture/flow/#task-lifecycle-sequence","title":"Task Lifecycle Sequence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant TaskStore\n    participant Logic\n\n    Client-&gt;&gt;Server: tasks/send\n    Note over Server: Create Task (submitted)\n    Server-&gt;&gt;TaskStore: Store task\n\n    Server-&gt;&gt;Logic: Process task\n    Note over Logic: Update state to working\n    Server-&gt;&gt;TaskStore: Update task state\n\n    alt Success\n        Logic--&gt;&gt;Server: Results\n        Note over Server: Update state to completed\n        Server-&gt;&gt;TaskStore: Update with artifacts\n        Server--&gt;&gt;Client: Task (completed)\n    else Needs Input\n        Logic--&gt;&gt;Server: Request input\n        Note over Server: Update state to input-required\n        Server--&gt;&gt;Client: Task (input-required)\n        Client-&gt;&gt;Server: tasks/send (same task ID)\n        Server-&gt;&gt;Logic: Continue processing\n    else Error\n        Logic--&gt;&gt;Server: Error\n        Note over Server: Update state to failed\n        Server--&gt;&gt;Client: Task (failed)\n    end</code></pre>"},{"location":"architecture/flow/#synchronous-task-flow","title":"Synchronous Task Flow","text":"<p>The simplest interaction pattern where the client sends a task and waits for completion.</p>"},{"location":"architecture/flow/#synchronous-taskssend-sequence","title":"Synchronous tasks/send Sequence","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant Client as A2A Client\n    participant Models as Models Layer\n    participant Protocol as Protocol Layer\n    participant Network as HTTP/Network\n    participant Server as A2A Server\n\n    Note over App,Server: Synchronous Task Execution\n\n    App-&gt;&gt;Models: Create Message\n    activate Models\n    Models--&gt;&gt;App: Message object\n    deactivate Models\n\n    App-&gt;&gt;Client: send_task(task_id, message)\n    activate Client\n\n    Client-&gt;&gt;Models: Create Task (submitted)\n    Client-&gt;&gt;Protocol: Create JSON-RPC Request\n    activate Protocol\n    Protocol--&gt;&gt;Client: Request object\n    deactivate Protocol\n\n    Client-&gt;&gt;Network: POST /a2a endpoint\n    activate Network\n    Network-&gt;&gt;Server: HTTP Request\n    activate Server\n\n    Server-&gt;&gt;Protocol: Parse JSON-RPC\n    Protocol--&gt;&gt;Server: Request object\n\n    Server-&gt;&gt;Server: Route to handle_send_task\n    Server-&gt;&gt;Server: Process task\n    Note over Server: Task state: working\n\n    Server-&gt;&gt;Server: Execute business logic\n    Note over Server: Task state: completed\n\n    Server-&gt;&gt;Models: Create Task result\n    Server-&gt;&gt;Protocol: Create JSON-RPC Response\n    Protocol--&gt;&gt;Server: Response object\n\n    Server--&gt;&gt;Network: HTTP 200 + Task JSON\n    deactivate Server\n    Network--&gt;&gt;Client: HTTP Response\n    deactivate Network\n\n    Client-&gt;&gt;Protocol: Parse response\n    Protocol-&gt;&gt;Models: Task.from_hash\n    activate Models\n    Models--&gt;&gt;Protocol: Task object\n    deactivate Models\n    Protocol--&gt;&gt;Client: Task\n\n    Client--&gt;&gt;App: Task (completed)\n    deactivate Client</code></pre>"},{"location":"architecture/flow/#synchronous-flow-with-error","title":"Synchronous Flow with Error","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant Logic\n\n    Client-&gt;&gt;Server: tasks/send\n    activate Server\n    Server-&gt;&gt;Logic: Process task\n    activate Logic\n\n    Logic--&gt;&gt;Logic: Processing fails\n    Logic--&gt;&gt;Server: Raise error\n    deactivate Logic\n\n    Server-&gt;&gt;Server: Create error response\n    Server--&gt;&gt;Client: JSON-RPC Error\n    deactivate Server\n\n    Note over Client: Handle error\n    Client-&gt;&gt;Client: Raise A2A::Error</code></pre>"},{"location":"architecture/flow/#streaming-task-flow","title":"Streaming Task Flow","text":"<p>For long-running tasks, streaming provides real-time updates via Server-Sent Events (SSE).</p>"},{"location":"architecture/flow/#streaming-taskssendsubscribe-sequence","title":"Streaming tasks/sendSubscribe Sequence","text":"<pre><code>sequenceDiagram\n    participant Client as A2A Client\n    participant HTTP as HTTP/SSE\n    participant Server as A2A Server\n    participant Logic as Business Logic\n\n    Note over Client,Server: Streaming Task Execution\n\n    Client-&gt;&gt;HTTP: POST tasks/sendSubscribe\n    activate HTTP\n    HTTP-&gt;&gt;Server: HTTP Request\n    activate Server\n\n    Note over Server: Accept streaming request\n    Server--&gt;&gt;HTTP: HTTP 200 + SSE stream\n    HTTP--&gt;&gt;Client: SSE Connection established\n\n    Server-&gt;&gt;Logic: Start async processing\n    activate Logic\n\n    Note over Server: Task state: submitted\n    Server-&gt;&gt;HTTP: SSE: TaskStatusUpdateEvent\n    HTTP-&gt;&gt;Client: Event: status=submitted\n\n    Note over Logic: Begin processing\n    Logic--&gt;&gt;Server: Update: working\n    Note over Server: Task state: working\n    Server-&gt;&gt;HTTP: SSE: TaskStatusUpdateEvent\n    HTTP-&gt;&gt;Client: Event: status=working\n\n    Logic--&gt;&gt;Logic: Generate partial results\n    Logic--&gt;&gt;Server: Artifact update\n    Server-&gt;&gt;HTTP: SSE: TaskArtifactUpdateEvent\n    HTTP-&gt;&gt;Client: Event: artifact data\n\n    Logic--&gt;&gt;Logic: More processing\n    Logic--&gt;&gt;Server: More artifact updates\n    Server-&gt;&gt;HTTP: SSE: TaskArtifactUpdateEvent\n    HTTP-&gt;&gt;Client: Event: more artifacts\n\n    Logic--&gt;&gt;Server: Processing complete\n    deactivate Logic\n    Note over Server: Task state: completed\n    Server-&gt;&gt;HTTP: SSE: TaskStatusUpdateEvent\n    HTTP-&gt;&gt;Client: Event: status=completed\n\n    Server-&gt;&gt;HTTP: Close SSE stream\n    deactivate Server\n    HTTP-&gt;&gt;Client: Connection closed\n    deactivate HTTP</code></pre>"},{"location":"architecture/flow/#sse-event-structure","title":"SSE Event Structure","text":"<pre><code>graph TD\n    subgraph \"SSE Event Types\"\n        TSU[TaskStatusUpdateEvent]\n        TAU[TaskArtifactUpdateEvent]\n    end\n\n    subgraph \"TaskStatusUpdateEvent\"\n        TSU_Type[type: taskStatusUpdate]\n        TSU_Task[task: Task object]\n    end\n\n    subgraph \"TaskArtifactUpdateEvent\"\n        TAU_Type[type: taskArtifactUpdate]\n        TAU_TID[taskId: string]\n        TAU_Artifacts[artifacts: Artifact array]\n    end\n\n    TSU --&gt; TSU_Type\n    TSU --&gt; TSU_Task\n\n    TAU --&gt; TAU_Type\n    TAU --&gt; TAU_TID\n    TAU --&gt; TAU_Artifacts\n\n    style TSU fill:#d4edda\n    style TAU fill:#fff3cd</code></pre>"},{"location":"architecture/flow/#multi-turn-conversation-flow","title":"Multi-Turn Conversation Flow","text":"<p>Sessions enable multi-turn conversations where context is maintained across multiple messages.</p>"},{"location":"architecture/flow/#multi-turn-conversation-sequence","title":"Multi-Turn Conversation Sequence","text":"<pre><code>sequenceDiagram\n    participant User as User/Client\n    participant Agent as A2A Agent\n    participant Session as Session Store\n\n    Note over User,Session: Turn 1: Initial Question\n\n    User-&gt;&gt;Agent: tasks/send&lt;br/&gt;taskId: task-1&lt;br/&gt;sessionId: session-123&lt;br/&gt;message: \"What's 2+2?\"\n\n    Agent-&gt;&gt;Session: Create session-123\n    Agent-&gt;&gt;Agent: Process message\n    Agent-&gt;&gt;Session: Store context\n\n    Agent--&gt;&gt;User: Task (completed)&lt;br/&gt;message: \"2+2 equals 4\"\n\n    Note over User,Session: Turn 2: Follow-up Question\n\n    User-&gt;&gt;Agent: tasks/send&lt;br/&gt;taskId: task-2&lt;br/&gt;sessionId: session-123&lt;br/&gt;message: \"What about 3+3?\"\n\n    Agent-&gt;&gt;Session: Retrieve context\n    Agent-&gt;&gt;Agent: Process with context\n    Agent-&gt;&gt;Session: Update context\n\n    Agent--&gt;&gt;User: Task (completed)&lt;br/&gt;message: \"3+3 equals 6\"\n\n    Note over User,Session: Turn 3: Contextual Question\n\n    User-&gt;&gt;Agent: tasks/send&lt;br/&gt;taskId: task-3&lt;br/&gt;sessionId: session-123&lt;br/&gt;message: \"Add them together\"\n\n    Agent-&gt;&gt;Session: Retrieve context\n    Note over Agent: Context: 4 and 6\n    Agent-&gt;&gt;Agent: Process: 4+6=10\n\n    Agent--&gt;&gt;User: Task (completed)&lt;br/&gt;message: \"4 + 6 = 10\"</code></pre>"},{"location":"architecture/flow/#session-context-management","title":"Session Context Management","text":"<pre><code>graph LR\n    subgraph \"Session Context\"\n        T1[Task 1&lt;br/&gt;2+2=4]\n        T2[Task 2&lt;br/&gt;3+3=6]\n        T3[Task 3&lt;br/&gt;4+6=10]\n\n        T1 --&gt;|context| T2\n        T2 --&gt;|context| T3\n    end\n\n    subgraph \"Session Data\"\n        Conv[Conversation History]\n        State[State Variables]\n        Meta[Metadata]\n    end\n\n    T1 --&gt; Conv\n    T2 --&gt; Conv\n    T3 --&gt; Conv\n\n    style Conv fill:#d4edda\n    style State fill:#fff3cd</code></pre>"},{"location":"architecture/flow/#error-handling-flows","title":"Error Handling Flows","text":""},{"location":"architecture/flow/#protocol-error-flow","title":"Protocol Error Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant ErrorHandler\n\n    Client-&gt;&gt;Server: Invalid JSON-RPC Request\n    activate Server\n\n    Server-&gt;&gt;ErrorHandler: Validate request\n    activate ErrorHandler\n    ErrorHandler--&gt;&gt;Server: ValidationError\n    deactivate ErrorHandler\n\n    Server-&gt;&gt;Server: Create error response\n    Note over Server: Error code: -32600\n\n    Server--&gt;&gt;Client: JSON-RPC Error Response\n    deactivate Server\n\n    Note over Client: Parse error\n    Client-&gt;&gt;Client: Raise InvalidRequestError</code></pre>"},{"location":"architecture/flow/#application-error-flow","title":"Application Error Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant TaskStore\n\n    Client-&gt;&gt;Server: tasks/get (non-existent task)\n    activate Server\n\n    Server-&gt;&gt;TaskStore: Find task\n    TaskStore--&gt;&gt;Server: nil (not found)\n\n    Server-&gt;&gt;Server: Create error response\n    Note over Server: Error code: -32001&lt;br/&gt;Task not found\n\n    Server--&gt;&gt;Client: JSON-RPC Error\n    deactivate Server\n\n    Client-&gt;&gt;Client: Raise TaskNotFoundError</code></pre>"},{"location":"architecture/flow/#error-response-structure","title":"Error Response Structure","text":"<pre><code>graph TD\n    Error[JSON-RPC Error Response]\n\n    Error --&gt; JSONRPC[jsonrpc: 2.0]\n    Error --&gt; ID[id: request id]\n    Error --&gt; ErrorObj[error object]\n\n    ErrorObj --&gt; Code[code: number]\n    ErrorObj --&gt; Message[message: string]\n    ErrorObj --&gt; Data[data: optional object]\n\n    Code --&gt; StdCodes[Standard Codes&lt;br/&gt;-32700 to -32603]\n    Code --&gt; AppCodes[A2A Codes&lt;br/&gt;-32001 to -32004]\n\n    style Error fill:#f8d7da\n    style ErrorObj fill:#ffe1e1</code></pre>"},{"location":"architecture/flow/#push-notification-flow","title":"Push Notification Flow","text":"<p>Servers supporting push notifications can proactively send updates to clients via webhooks.</p>"},{"location":"architecture/flow/#push-notification-setup-and-delivery","title":"Push Notification Setup and Delivery","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant Webhook as Client Webhook\n    participant Queue as Task Queue\n\n    Note over Client,Queue: Setup Phase\n    Client-&gt;&gt;Server: tasks/pushNotification/set\n    Note over Client: Provide webhook URL\n    Server-&gt;&gt;Server: Store webhook config\n    Server--&gt;&gt;Client: Success\n\n    Note over Client,Queue: Task Execution Phase\n    Client-&gt;&gt;Server: tasks/send\n    Server--&gt;&gt;Client: Task (submitted)\n    Note over Server: Process asynchronously\n\n    Server-&gt;&gt;Queue: Queue task\n    Queue-&gt;&gt;Queue: Process task\n\n    Note over Queue: State: working\n    Queue-&gt;&gt;Webhook: POST webhook URL\n    Note over Webhook: TaskStatusUpdateEvent\n    Webhook--&gt;&gt;Queue: 200 OK\n\n    Queue-&gt;&gt;Queue: Continue processing\n\n    Note over Queue: State: completed\n    Queue-&gt;&gt;Webhook: POST webhook URL\n    Note over Webhook: TaskStatusUpdateEvent\n    Webhook--&gt;&gt;Queue: 200 OK\n\n    Note over Client: Receives async updates</code></pre>"},{"location":"architecture/flow/#webhook-retry-flow","title":"Webhook Retry Flow","text":"<pre><code>graph TD\n    Send[Send Webhook] --&gt; HTTP[HTTP POST]\n    HTTP --&gt; Success{Success?}\n\n    Success --&gt;|200-299| Done[Done]\n    Success --&gt;|Error| Retry{Retries&lt;br/&gt;Remaining?}\n\n    Retry --&gt;|Yes| Wait[Wait with backoff]\n    Wait --&gt; HTTP\n\n    Retry --&gt;|No| Log[Log failure]\n    Log --&gt; Done\n\n    style Send fill:#d4edda\n    style Done fill:#d4edda\n    style Log fill:#f8d7da</code></pre>"},{"location":"architecture/flow/#task-cancellation-flow","title":"Task Cancellation Flow","text":"<p>Clients can request task cancellation for non-terminal tasks.</p>"},{"location":"architecture/flow/#cancellation-sequence","title":"Cancellation Sequence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant Worker as Task Worker\n    participant Store as Task Store\n\n    Note over Client,Store: Task is running\n\n    Client-&gt;&gt;Server: tasks/cancel (task-id)\n    activate Server\n\n    Server-&gt;&gt;Store: Get task\n    Store--&gt;&gt;Server: Task (state: working)\n\n    Server-&gt;&gt;Server: Validate cancelable\n    Note over Server: Check state is not terminal\n\n    Server-&gt;&gt;Worker: Send cancel signal\n    activate Worker\n    Worker-&gt;&gt;Worker: Stop processing\n    Worker-&gt;&gt;Store: Update state: canceled\n    Worker--&gt;&gt;Server: Canceled\n    deactivate Worker\n\n    Server-&gt;&gt;Store: Get updated task\n    Store--&gt;&gt;Server: Task (state: canceled)\n\n    Server--&gt;&gt;Client: Task (canceled)\n    deactivate Server</code></pre>"},{"location":"architecture/flow/#cancellation-edge-cases","title":"Cancellation Edge Cases","text":"<pre><code>graph TD\n    Cancel[Cancel Request] --&gt; GetTask[Get Task]\n    GetTask --&gt; CheckState{Task State?}\n\n    CheckState --&gt;|submitted| CanCancel[Can Cancel]\n    CheckState --&gt;|working| CanCancel\n    CheckState --&gt;|input-required| CanCancel\n\n    CheckState --&gt;|completed| AlreadyDone[Already Complete]\n    CheckState --&gt;|failed| AlreadyDone\n    CheckState --&gt;|canceled| AlreadyDone\n\n    CanCancel --&gt; Signal[Send Cancel Signal]\n    Signal --&gt; Update[Update State]\n    Update --&gt; Return[Return Task]\n\n    AlreadyDone --&gt; Error[TaskNotCancelableError]\n\n    style CanCancel fill:#d4edda\n    style Error fill:#f8d7da</code></pre>"},{"location":"architecture/flow/#state-transitions","title":"State Transitions","text":""},{"location":"architecture/flow/#valid-state-transition-diagram","title":"Valid State Transition Diagram","text":"<pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; submitted\n\n    submitted --&gt; working: Agent starts\n    submitted --&gt; failed: Immediate error\n    submitted --&gt; canceled: Client cancels\n\n    working --&gt; input-required: Needs input\n    working --&gt; completed: Success\n    working --&gt; failed: Error\n    working --&gt; canceled: Client cancels\n\n    input-required --&gt; working: Input provided\n    input-required --&gt; failed: Timeout\n    input-required --&gt; canceled: Client cancels\n\n    completed --&gt; [*]\n    failed --&gt; [*]\n    canceled --&gt; [*]\n\n    note right of submitted\n        Initial state when\n        task is created\n    end note\n\n    note right of working\n        Agent is actively\n        processing the task\n    end note\n\n    note right of input-required\n        Agent needs more\n        information from client\n    end note\n\n    note left of completed\n        Terminal: Task\n        completed successfully\n    end note\n\n    note left of failed\n        Terminal: Task\n        failed with error\n    end note\n\n    note left of canceled\n        Terminal: Task\n        was canceled\n    end note</code></pre>"},{"location":"architecture/flow/#state-transition-rules","title":"State Transition Rules","text":"<pre><code>graph TD\n    subgraph \"Active States (Can Transition)\"\n        S[submitted]\n        W[working]\n        IR[input-required]\n    end\n\n    subgraph \"Terminal States (No Transitions)\"\n        C[completed]\n        F[failed]\n        X[canceled]\n        U[unknown]\n    end\n\n    S --&gt; W\n    S --&gt; F\n    S --&gt; X\n\n    W --&gt; IR\n    W --&gt; C\n    W --&gt; F\n    W --&gt; X\n\n    IR --&gt; W\n    IR --&gt; F\n    IR --&gt; X\n\n    style S fill:#fff3cd\n    style W fill:#fff3cd\n    style IR fill:#fff3cd\n    style C fill:#d4edda\n    style F fill:#f8d7da\n    style X fill:#e1f5ff</code></pre>"},{"location":"architecture/flow/#component-interactions","title":"Component Interactions","text":""},{"location":"architecture/flow/#complete-requestresponse-flow","title":"Complete Request/Response Flow","text":"<pre><code>graph TB\n    subgraph \"Client Side\"\n        App[Application Code]\n        ClientAPI[Client API]\n        ReqBuilder[Request Builder]\n        HTTPClient[HTTP Client]\n    end\n\n    subgraph \"Network\"\n        Transport[HTTP/HTTPS]\n    end\n\n    subgraph \"Server Side\"\n        HTTPServer[HTTP Server]\n        Router[Request Router]\n        Handler[Request Handler]\n        Logic[Business Logic]\n    end\n\n    subgraph \"Data Layer\"\n        Models[Domain Models]\n        Protocol[JSON-RPC Protocol]\n        TaskStore[Task Storage]\n    end\n\n    App --&gt; ClientAPI\n    ClientAPI --&gt; ReqBuilder\n    ReqBuilder --&gt; Models\n    ReqBuilder --&gt; Protocol\n    ReqBuilder --&gt; HTTPClient\n\n    HTTPClient --&gt; Transport\n    Transport --&gt; HTTPServer\n\n    HTTPServer --&gt; Router\n    Router --&gt; Handler\n    Handler --&gt; Logic\n\n    Logic --&gt; Models\n    Handler --&gt; Models\n    Handler --&gt; Protocol\n    Logic --&gt; TaskStore\n\n    Models -.response.-&gt; Handler\n    Protocol -.response.-&gt; Handler\n    Handler -.response.-&gt; HTTPServer\n    HTTPServer -.response.-&gt; Transport\n    Transport -.response.-&gt; HTTPClient\n    HTTPClient -.response.-&gt; App\n\n    style App fill:#e1f5ff\n    style Logic fill:#fff3cd\n    style Models fill:#d4edda\n    style Protocol fill:#ffe1e1</code></pre>"},{"location":"architecture/flow/#model-interaction-flow","title":"Model Interaction Flow","text":"<pre><code>graph TD\n    subgraph \"Task Creation Flow\"\n        CreateTask[Create Task] --&gt; CreateStatus[Create TaskStatus]\n        CreateStatus --&gt; CreateState[Create TaskState]\n        CreateTask --&gt; CreateMessage[Create Message]\n        CreateMessage --&gt; CreateParts[Create Parts]\n        CreateParts --&gt; TextPart[TextPart]\n        CreateParts --&gt; FilePart[FilePart]\n        CreateParts --&gt; DataPart[DataPart]\n    end\n\n    subgraph \"Serialization Flow\"\n        ToHash[to_h] --&gt; HashTask[Hash: Task]\n        HashTask --&gt; HashStatus[Hash: TaskStatus]\n        HashStatus --&gt; HashState[String: state]\n        HashTask --&gt; HashMessage[Hash: Message]\n        HashMessage --&gt; HashParts[Array: Parts]\n    end\n\n    subgraph \"Deserialization Flow\"\n        FromHash[from_hash] --&gt; ParseTask[Parse Task]\n        ParseTask --&gt; ParseStatus[TaskStatus.from_hash]\n        ParseStatus --&gt; ParseState[TaskState.new]\n        ParseTask --&gt; ParseMessage[Message.from_hash]\n        ParseMessage --&gt; ParseParts[Part.from_hash]\n        ParseParts --&gt; Factory[Factory Pattern]\n        Factory --&gt; CreateText[TextPart.from_hash]\n        Factory --&gt; CreateFile[FilePart.from_hash]\n        Factory --&gt; CreateData[DataPart.from_hash]\n    end\n\n    CreateTask -.serialize.-&gt; ToHash\n    FromHash -.deserialize.-&gt; CreateTask\n\n    style CreateTask fill:#d4edda\n    style ToHash fill:#fff3cd\n    style FromHash fill:#e1f5ff</code></pre>"},{"location":"architecture/flow/#protocol-method-summary","title":"Protocol Method Summary","text":""},{"location":"architecture/flow/#all-protocol-methods","title":"All Protocol Methods","text":"<pre><code>graph TB\n    subgraph \"Discovery\"\n        D1[GET /.well-known/agent.json&lt;br/&gt;Returns: AgentCard]\n    end\n\n    subgraph \"Task Operations\"\n        T1[tasks/send&lt;br/&gt;Synchronous task execution]\n        T2[tasks/sendSubscribe&lt;br/&gt;Streaming task execution]\n        T3[tasks/get&lt;br/&gt;Get task status]\n        T4[tasks/cancel&lt;br/&gt;Cancel running task]\n        T5[tasks/resubscribe&lt;br/&gt;Resubscribe to streaming]\n    end\n\n    subgraph \"Push Notifications\"\n        P1[tasks/pushNotification/set&lt;br/&gt;Configure webhook]\n        P2[tasks/pushNotification/get&lt;br/&gt;Get webhook config]\n    end\n\n    style D1 fill:#d1ecf1\n    style T1 fill:#d4edda\n    style T2 fill:#fff3cd\n    style T3 fill:#e1f5ff\n    style T4 fill:#f8d7da\n    style P1 fill:#ffe1e1</code></pre>"},{"location":"architecture/flow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview - High-level architecture and components</li> <li>Design Principles - Design patterns and decisions</li> <li>Gem Architecture - Gem architecture document</li> <li>Tasks Guide - Working with tasks</li> <li>Messages Guide - Working with messages</li> </ul> <p>Back to Documentation Home</p>"},{"location":"architecture/gem-architecture/","title":"A2A Ruby Gem Architecture","text":""},{"location":"architecture/gem-architecture/#overview","title":"Overview","text":"<p>This Ruby gem implements the A2A (Agent2Agent) protocol, an open protocol enabling communication and interoperability between agentic applications. The protocol uses JSON-RPC 2.0 for message exchange.</p>"},{"location":"architecture/gem-architecture/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        A2A Gem                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502  \u2502   Client     \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   Server     \u2502                 \u2502\n\u2502  \u2502    Base      \u2502         \u2502    Base      \u2502                 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n\u2502         \u2502                         \u2502                         \u2502\n\u2502         \u2502                         \u2502                         \u2502\n\u2502         \u25bc                         \u25bc                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502  \u2502           Protocol Layer                 \u2502               \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502               \u2502\n\u2502  \u2502  \u2502 Request \u2502  \u2502 Response \u2502  \u2502 Error  \u2502 \u2502               \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502               \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502         \u2502                         \u2502                         \u2502\n\u2502         \u2502                         \u2502                         \u2502\n\u2502         \u25bc                         \u25bc                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502  \u2502            Models Layer                  \u2502               \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502               \u2502\n\u2502  \u2502  \u2502  AgentCard   \u2502  \u2502    Task      \u2502    \u2502               \u2502\n\u2502  \u2502  \u2502 Capabilities \u2502  \u2502   Status     \u2502    \u2502               \u2502\n\u2502  \u2502  \u2502    Skills    \u2502  \u2502   Message    \u2502    \u2502               \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502               \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502               \u2502\n\u2502  \u2502  \u2502    Parts     \u2502  \u2502  Artifacts   \u2502    \u2502               \u2502\n\u2502  \u2502  \u2502 Text/File/   \u2502  \u2502              \u2502    \u2502               \u2502\n\u2502  \u2502  \u2502    Data      \u2502  \u2502              \u2502    \u2502               \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502               \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/gem-architecture/#directory-structure","title":"Directory Structure","text":"<pre><code>lib/a2a/\n\u251c\u2500\u2500 version.rb                  # Gem version\n\u251c\u2500\u2500 error.rb                    # Error classes (JSON-RPC and A2A specific)\n\u2502\n\u251c\u2500\u2500 models/                     # Data models from A2A protocol specification\n\u2502   \u251c\u2500\u2500 agent_card.rb          # Agent metadata and discovery\n\u2502   \u251c\u2500\u2500 agent_capabilities.rb  # Agent capabilities (streaming, push notifications)\n\u2502   \u251c\u2500\u2500 agent_skill.rb         # Agent skill definition\n\u2502   \u251c\u2500\u2500 agent_provider.rb      # Agent provider information\n\u2502   \u251c\u2500\u2500 agent_authentication.rb # Authentication configuration\n\u2502   \u251c\u2500\u2500 task.rb                # Task (central unit of work)\n\u2502   \u251c\u2500\u2500 task_status.rb         # Task status with state and timestamp\n\u2502   \u251c\u2500\u2500 task_state.rb          # Task state enum (submitted, working, etc.)\n\u2502   \u251c\u2500\u2500 message.rb             # Communication turns (user/agent)\n\u2502   \u251c\u2500\u2500 part.rb                # Base class for message parts\n\u2502   \u251c\u2500\u2500 text_part.rb           # Text content part\n\u2502   \u251c\u2500\u2500 file_part.rb           # File content part\n\u2502   \u251c\u2500\u2500 file_content.rb        # File representation (bytes or URI)\n\u2502   \u251c\u2500\u2500 data_part.rb           # Structured data part (JSON)\n\u2502   \u251c\u2500\u2500 artifact.rb            # Agent-generated outputs\n\u2502   \u2514\u2500\u2500 push_notification_config.rb # Push notification configuration\n\u2502\n\u251c\u2500\u2500 protocol/                   # JSON-RPC protocol implementation\n\u2502   \u251c\u2500\u2500 request.rb             # Base JSON-RPC request\n\u2502   \u251c\u2500\u2500 response.rb            # Base JSON-RPC response\n\u2502   \u251c\u2500\u2500 error.rb               # Protocol error representation\n\u2502   \u251c\u2500\u2500 requests/              # Specific request types (future)\n\u2502   \u251c\u2500\u2500 responses/             # Specific response types (future)\n\u2502   \u251c\u2500\u2500 events/                # SSE events (future)\n\u2502   \u2514\u2500\u2500 errors/                # Specific error types (future)\n\u2502\n\u251c\u2500\u2500 client/                     # A2A Client implementation\n\u2502   \u2514\u2500\u2500 base.rb                # Base client class\n\u2502\n\u251c\u2500\u2500 server/                     # A2A Server implementation\n\u2502   \u2514\u2500\u2500 base.rb                # Base server class\n\u2502\n\u2514\u2500\u2500 utils/                      # Utilities (future)\n    \u251c\u2500\u2500 json_schema_validator.rb\n    \u2514\u2500\u2500 serializer.rb\n</code></pre>"},{"location":"architecture/gem-architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/gem-architecture/#1-models-layer","title":"1. Models Layer","text":""},{"location":"architecture/gem-architecture/#agentcard","title":"AgentCard","text":"<ul> <li>Represents an agent's metadata and capabilities</li> <li>Usually served at <code>/.well-known/agent.json</code></li> <li>Contains: name, URL, version, capabilities, skills, authentication</li> </ul>"},{"location":"architecture/gem-architecture/#task","title":"Task","text":"<ul> <li>Central unit of work in A2A protocol</li> <li>Has unique ID and progresses through states</li> <li>States: submitted, working, input-required, completed, failed, canceled</li> </ul>"},{"location":"architecture/gem-architecture/#message","title":"Message","text":"<ul> <li>Represents communication turns between client (user) and agent</li> <li>Contains an array of Parts (text, file, or data)</li> </ul>"},{"location":"architecture/gem-architecture/#parts-polymorphic","title":"Parts (Polymorphic)","text":"<ul> <li>TextPart: Plain text content</li> <li>FilePart: File content (bytes or URI reference)</li> <li>DataPart: Structured JSON data (e.g., forms)</li> </ul>"},{"location":"architecture/gem-architecture/#artifact","title":"Artifact","text":"<ul> <li>Represents outputs generated by the agent</li> <li>Contains Parts similar to Messages</li> </ul>"},{"location":"architecture/gem-architecture/#2-protocol-layer","title":"2. Protocol Layer","text":"<p>Implements JSON-RPC 2.0 specification:</p>"},{"location":"architecture/gem-architecture/#request","title":"Request","text":"<ul> <li>Standard JSON-RPC request format</li> <li>Contains: jsonrpc, id, method, params</li> </ul>"},{"location":"architecture/gem-architecture/#response","title":"Response","text":"<ul> <li>Standard JSON-RPC response format</li> <li>Contains: jsonrpc, id, result or error</li> </ul>"},{"location":"architecture/gem-architecture/#error","title":"Error","text":"<ul> <li>JSON-RPC error representation</li> <li>Includes standard and A2A-specific error codes</li> </ul>"},{"location":"architecture/gem-architecture/#3-client-layer","title":"3. Client Layer","text":"<p>Base Client provides interface for: - <code>discover()</code> - Fetch agent card from well-known URL - <code>send_task()</code> - Send a task to agent (synchronous) - <code>send_task_streaming()</code> - Send task with streaming (SSE) - <code>get_task()</code> - Get task status - <code>cancel_task()</code> - Cancel a running task - <code>set_push_notification()</code> - Configure push notifications - <code>get_push_notification()</code> - Get push notification config</p>"},{"location":"architecture/gem-architecture/#4-server-layer","title":"4. Server Layer","text":"<p>Base Server provides interface for handling: - <code>handle_send_task()</code> - Process tasks/send - <code>handle_send_task_streaming()</code> - Process tasks/sendSubscribe (SSE) - <code>handle_get_task()</code> - Process tasks/get - <code>handle_cancel_task()</code> - Process tasks/cancel - <code>handle_set_push_notification()</code> - Process tasks/pushNotification/set - <code>handle_get_push_notification()</code> - Process tasks/pushNotification/get - <code>handle_resubscribe()</code> - Process tasks/resubscribe</p>"},{"location":"architecture/gem-architecture/#protocol-methods","title":"Protocol Methods","text":""},{"location":"architecture/gem-architecture/#core-methods","title":"Core Methods","text":"<ul> <li><code>tasks/send</code> - Send a task to agent (synchronous)</li> <li><code>tasks/sendSubscribe</code> - Send task with streaming support</li> <li><code>tasks/get</code> - Get current task status</li> <li><code>tasks/cancel</code> - Cancel a task</li> <li><code>tasks/pushNotification/set</code> - Set push notification config</li> <li><code>tasks/pushNotification/get</code> - Get push notification config</li> <li><code>tasks/resubscribe</code> - Resubscribe to streaming updates</li> </ul>"},{"location":"architecture/gem-architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Separation of Concerns: Models, protocol, client, and server are cleanly separated</li> <li>Testability: Each component is isolated and independently testable</li> <li>Extensibility: Easy to add new part types, methods, or capabilities</li> <li>Type Safety: Designed to work with RBS type definitions</li> <li>Protocol Compliance: Strictly follows A2A JSON schema specification</li> </ol>"},{"location":"architecture/gem-architecture/#future-enhancements","title":"Future Enhancements","text":"<ol> <li>HTTP Client Implementation: Concrete client using net/http or faraday</li> <li>Rack Server Implementation: Rack-based server for easy integration</li> <li>SSE Support: Server-Sent Events for streaming</li> <li>JSON Schema Validation: Validate all messages against protocol schema</li> <li>Webhook Support: Push notification delivery</li> <li>Authentication Handlers: Support for various auth schemes</li> <li>Logging and Debugging: Comprehensive logging support</li> </ol>"},{"location":"architecture/gem-architecture/#usage-examples","title":"Usage Examples","text":""},{"location":"architecture/gem-architecture/#creating-an-agent-card","title":"Creating an Agent Card","text":"<pre><code>agent_card = A2A::Models::AgentCard.new(\n  name: \"My Agent\",\n  url: \"https://example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: true,\n    push_notifications: false\n  },\n  skills: [\n    {\n      id: \"skill-1\",\n      name: \"Text Processing\",\n      description: \"Process and analyze text\"\n    }\n  ]\n)\n</code></pre>"},{"location":"architecture/gem-architecture/#creating-a-task","title":"Creating a Task","text":"<pre><code>message = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Hello, agent!\"\n)\n\ntask = A2A::Models::Task.new(\n  id: \"task-123\",\n  status: {\n    state: \"submitted\"\n  }\n)\n</code></pre>"},{"location":"architecture/gem-architecture/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  # Some A2A operation\nrescue A2A::TaskNotFoundError =&gt; e\n  puts \"Task not found: #{e.message}\"\n  puts \"Error code: #{e.code}\"\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Protocol error: #{e.message}\"\nend\n</code></pre>"},{"location":"architecture/gem-architecture/#contributing","title":"Contributing","text":"<p>When adding new features: 1. Add models to <code>lib/a2a/models/</code> 2. Add protocol messages to <code>lib/a2a/protocol/</code> 3. Update main <code>lib/a2a.rb</code> to require new files 4. Add tests in <code>spec/</code> 5. Update this architecture document</p>"},{"location":"architecture/gem-architecture/#references","title":"References","text":"<ul> <li>A2A Protocol Specification</li> <li>JSON-RPC 2.0 Specification</li> <li>A2A JSON Schema</li> </ul>"},{"location":"examples/","title":"A2A Examples","text":"<p>This section provides comprehensive, practical examples for building Agent2Agent (A2A) protocol implementations using the A2A Ruby gem. Each example is designed to be copy-paste-ready and production-quality.</p>"},{"location":"examples/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Prerequisites</li> <li>Example Categories</li> <li>Getting Started</li> <li>Common Patterns</li> <li>Best Practices</li> <li>Troubleshooting</li> <li>Additional Resources</li> </ul>"},{"location":"examples/#overview","title":"Overview","text":"<p>The A2A protocol enables communication and interoperability between opaque agentic applications. This gem provides a complete Ruby implementation of the A2A protocol specification, including:</p> <ul> <li>Core Data Models: Tasks, Messages, Artifacts, AgentCards</li> <li>JSON-RPC 2.0 Protocol: Standards-compliant request/response messaging</li> <li>Client Base Classes: For consuming A2A services</li> <li>Server Base Classes: For providing A2A services</li> <li>Streaming Support: Server-Sent Events (SSE) for real-time updates</li> <li>Push Notifications: Webhook-based task status updates</li> </ul>"},{"location":"examples/#what-is-a2a","title":"What is A2A?","text":"<p>A2A (Agent2Agent) is an open protocol that enables:</p> <ol> <li>Agent Discovery: Through AgentCard metadata files</li> <li>Task Management: Submit, monitor, and cancel agent tasks</li> <li>Multi-turn Conversations: Session-based interactions</li> <li>Real-time Streaming: Server-sent events for live updates</li> <li>Push Notifications: Webhook callbacks for status changes</li> <li>Rich Content: Text, files, and structured data in messages</li> </ol>"},{"location":"examples/#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   A2A       \u2502   HTTP/JSON-RPC 2.0      \u2502   A2A       \u2502\n\u2502   Client    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502   Server    \u2502\n\u2502             \u2502                           \u2502             \u2502\n\u2502 - Discover  \u2502                           \u2502 - AgentCard \u2502\n\u2502 - SendTask  \u2502                           \u2502 - Process   \u2502\n\u2502 - GetTask   \u2502                           \u2502 - Stream    \u2502\n\u2502 - Cancel    \u2502                           \u2502 - Notify    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<p>Before starting with these examples, ensure you have:</p>"},{"location":"examples/#system-requirements","title":"System Requirements","text":"<ul> <li>Ruby 3.0 or higher</li> <li>Bundler 2.0 or higher</li> <li>Basic understanding of HTTP and JSON-RPC</li> </ul>"},{"location":"examples/#installation","title":"Installation","text":"<p>Install the A2A gem:</p> <pre><code>gem install a2a\n</code></pre> <p>Or add to your Gemfile:</p> <pre><code>gem 'a2a'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre>"},{"location":"examples/#required-dependencies","title":"Required Dependencies","text":"<p>For the examples in this guide, you may also need:</p> <pre><code># For HTTP clients\ngem 'faraday'\ngem 'net-http'\n\n# For servers\ngem 'sinatra'\ngem 'puma'\ngem 'rack'\n\n# For SSE streaming (optional)\ngem 'sinatra-sse'\n\n# For JSON handling\ngem 'json'\n\n# For debugging (as per your requirements)\ngem 'debug_me', git: 'https://github.com/madbomber/debug_me'\n</code></pre>"},{"location":"examples/#example-categories","title":"Example Categories","text":"<p>This documentation is organized into the following categories:</p>"},{"location":"examples/#1-basic-examples","title":"1. Basic Examples","text":"<p>Learn the fundamentals of the A2A gem:</p> <ul> <li>Creating AgentCards</li> <li>Working with Messages and Parts</li> <li>Managing Tasks and States</li> <li>Handling Artifacts</li> <li>Error handling patterns</li> <li>JSON serialization/deserialization</li> <li>Testing models in isolation</li> </ul> <p>Who should read this: Everyone starting with A2A</p> <p>Key concepts covered: - Data model fundamentals - Object creation and manipulation - State management - Error handling</p>"},{"location":"examples/#2-client-examples","title":"2. Client Examples","text":"<p>Build production-ready A2A HTTP clients:</p> <ul> <li>Subclassing <code>A2A::Client::Base</code></li> <li>Implementing agent discovery</li> <li>Sending tasks (synchronous)</li> <li>Streaming task updates (SSE)</li> <li>Polling for task status</li> <li>Canceling tasks</li> <li>Configuring push notifications</li> <li>Error handling and retries</li> <li>Complete working examples with Faraday and Net::HTTP</li> </ul> <p>Who should read this: Developers building applications that consume A2A services</p> <p>Key concepts covered: - HTTP client implementation - JSON-RPC request/response handling - SSE streaming - Connection management - Authentication</p>"},{"location":"examples/#3-server-examples","title":"3. Server Examples","text":"<p>Build production-ready A2A HTTP servers:</p> <ul> <li>Subclassing <code>A2A::Server::Base</code></li> <li>Serving AgentCards</li> <li>Processing tasks</li> <li>Implementing streaming responses</li> <li>Push notification callbacks</li> <li>Request routing and validation</li> <li>Complete working Sinatra/Rack server examples</li> <li>Production deployment patterns</li> </ul> <p>Who should read this: Developers building A2A-compatible agent services</p> <p>Key concepts covered: - HTTP server implementation - JSON-RPC method routing - SSE streaming - Background job processing - Production deployment</p>"},{"location":"examples/#getting-started","title":"Getting Started","text":""},{"location":"examples/#quick-start-30-seconds-to-a2a","title":"Quick Start: 30 Seconds to A2A","text":"<p>Here's the fastest way to get started with A2A:</p> <pre><code>require 'a2a'\n\n# Create an agent card\nagent = A2A::Models::AgentCard.new(\n  name: \"Quick Agent\",\n  url: \"https://example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: { streaming: true },\n  skills: [{ id: \"help\", name: \"Help\", description: \"Get help\" }]\n)\n\n# Create a message\nmessage = A2A::Models::Message.text(role: \"user\", text: \"Hello!\")\n\n# Create a task\ntask = A2A::Models::Task.new(\n  id: \"task-123\",\n  status: { state: \"submitted\" }\n)\n\nputs \"Agent: #{agent.name}\"\nputs \"Message: #{message.parts.first.text}\"\nputs \"Task state: #{task.state}\"\n</code></pre>"},{"location":"examples/#recommended-learning-path","title":"Recommended Learning Path","text":"<ol> <li>Start with Basic Examples (basic.md)</li> <li>Understand the data models</li> <li>Learn object creation patterns</li> <li> <p>Practice JSON serialization</p> </li> <li> <p>Build a Simple Client (client.md)</p> </li> <li>Implement agent discovery</li> <li>Send synchronous tasks</li> <li> <p>Handle responses</p> </li> <li> <p>Add Streaming Support</p> </li> <li>Implement SSE streaming in client</li> <li> <p>Handle real-time updates</p> </li> <li> <p>Build a Simple Server (server.md)</p> </li> <li>Serve AgentCard</li> <li>Process basic tasks</li> <li> <p>Return results</p> </li> <li> <p>Add Advanced Features</p> </li> <li>Streaming responses</li> <li>Push notifications</li> <li>Multi-turn conversations</li> </ol>"},{"location":"examples/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/#pattern-1-creating-structured-messages","title":"Pattern 1: Creating Structured Messages","text":"<p>Messages in A2A can contain multiple parts with different content types:</p> <pre><code># Simple text message\ntext_msg = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Analyze this document\"\n)\n\n# Multi-part message with text and data\nmixed_msg = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Analysis complete:\"),\n    A2A::Models::DataPart.new(\n      data: {\n        sentiment: \"positive\",\n        entities: [\"Person\", \"Location\"],\n        confidence: 0.95\n      }\n    )\n  ]\n)\n\n# Message with file attachment\nfile_msg = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"report.pdf\",\n        mime_type: \"application/pdf\",\n        uri: \"https://example.com/files/report.pdf\"\n      }\n    )\n  ]\n)\n</code></pre>"},{"location":"examples/#pattern-2-task-lifecycle-management","title":"Pattern 2: Task Lifecycle Management","text":"<p>Understanding and managing task states:</p> <pre><code># Create a new task\ntask = A2A::Models::Task.new(\n  id: SecureRandom.uuid,\n  session_id: session_id,\n  status: {\n    state: \"submitted\",\n    timestamp: Time.now.utc.iso8601\n  }\n)\n\n# Update to working state\ntask = A2A::Models::Task.new(\n  id: task.id,\n  status: {\n    state: \"working\",\n    message: A2A::Models::Message.text(\n      role: \"agent\",\n      text: \"Processing your request...\"\n    )\n  }\n)\n\n# Check if task is in terminal state\nunless task.state.terminal?\n  # Task is still active\nend\n\n# Complete task with results\ntask = A2A::Models::Task.new(\n  id: task.id,\n  status: { state: \"completed\" },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Results\",\n      parts: [A2A::Models::TextPart.new(text: \"Done!\")]\n    )\n  ]\n)\n</code></pre>"},{"location":"examples/#pattern-3-error-handling","title":"Pattern 3: Error Handling","text":"<p>Proper error handling in A2A applications:</p> <pre><code>begin\n  # Attempt to process a task\n  result = process_task(params)\n\nrescue A2A::TaskNotFoundError =&gt; e\n  # Handle missing task\n  response = A2A::Protocol::Response.error(\n    id: request_id,\n    error: { code: e.code, message: e.message }\n  )\n\nrescue A2A::InvalidParamsError =&gt; e\n  # Handle invalid parameters\n  response = A2A::Protocol::Response.error(\n    id: request_id,\n    error: { code: e.code, message: e.message, data: e.data }\n  )\n\nrescue A2A::InternalError =&gt; e\n  # Handle internal errors\n  debug_me \"Internal error occurred: #{e.message}\"\n  response = A2A::Protocol::Response.error(\n    id: request_id,\n    error: { code: e.code, message: \"Internal server error\" }\n  )\n\nrescue StandardError =&gt; e\n  # Catch-all for unexpected errors\n  debug_me \"Unexpected error: #{e.class} - #{e.message}\"\n  error_response = A2A::Protocol::Response.error(\n    id: request_id,\n    error: {\n      code: -32603,\n      message: \"Internal error\",\n      data: { type: e.class.name }\n    }\n  )\nend\n</code></pre>"},{"location":"examples/#pattern-4-json-rpc-requestresponse","title":"Pattern 4: JSON-RPC Request/Response","text":"<p>Creating and handling JSON-RPC messages:</p> <pre><code># Create a request\nrequest = A2A::Protocol::Request.new(\n  method: \"tasks/send\",\n  params: {\n    taskId: \"task-123\",\n    message: message.to_h\n  },\n  id: SecureRandom.uuid\n)\n\n# Serialize to JSON\njson_payload = request.to_json\n\n# Parse response\nresponse_data = JSON.parse(response_body, symbolize_names: true)\nresponse = A2A::Protocol::Response.from_hash(response_data)\n\nif response.success?\n  task = A2A::Models::Task.from_hash(response.result)\nelse\n  error = response.error\n  raise A2A::JSONRPCError.new(error[:message], code: error[:code])\nend\n</code></pre>"},{"location":"examples/#pattern-5-streaming-with-sse","title":"Pattern 5: Streaming with SSE","text":"<p>Handling Server-Sent Events for real-time updates:</p> <pre><code># Client-side streaming handler\ndef handle_streaming_task(task_id, message)\n  request = A2A::Protocol::Request.new(\n    method: \"tasks/sendSubscribe\",\n    params: {\n      taskId: task_id,\n      message: message.to_h\n    }\n  )\n\n  # Connect to SSE endpoint\n  EventSource.new(\"#{agent_url}/a2a/events\") do |source|\n    source.on_message do |event|\n      data = JSON.parse(event.data, symbolize_names: true)\n\n      case data[:type]\n      when \"taskStatus\"\n        task = A2A::Models::Task.from_hash(data[:task])\n        yield :status, task\n\n      when \"artifactUpdate\"\n        artifact = A2A::Models::Artifact.from_hash(data[:artifact])\n        yield :artifact, artifact\n\n      when \"taskComplete\"\n        task = A2A::Models::Task.from_hash(data[:task])\n        yield :complete, task\n        source.close\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"examples/#pattern-6-session-management","title":"Pattern 6: Session Management","text":"<p>Managing multi-turn conversations:</p> <pre><code>class ConversationSession\n  attr_reader :session_id, :task_history\n\n  def initialize\n    @session_id = SecureRandom.uuid\n    @task_history = []\n  end\n\n  def send_message(client, text)\n    message = A2A::Models::Message.text(role: \"user\", text: text)\n\n    task = client.send_task(\n      task_id: SecureRandom.uuid,\n      message: message,\n      session_id: session_id\n    )\n\n    @task_history &lt;&lt; task\n    task\n  end\n\n  def get_conversation_history\n    task_history.flat_map do |task|\n      messages = []\n\n      # Add user message if present in task\n      messages &lt;&lt; task.status.message if task.status.message\n\n      # Add agent responses from artifacts\n      task.artifacts&amp;.each do |artifact|\n        messages &lt;&lt; create_agent_message(artifact)\n      end\n\n      messages\n    end.compact\n  end\n\n  private\n\n  def create_agent_message(artifact)\n    A2A::Models::Message.new(\n      role: \"agent\",\n      parts: artifact.parts\n    )\n  end\nend\n</code></pre>"},{"location":"examples/#best-practices","title":"Best Practices","text":""},{"location":"examples/#1-always-validate-input","title":"1. Always Validate Input","text":"<pre><code>def validate_task_params(params)\n  raise A2A::InvalidParamsError unless params[:taskId]\n  raise A2A::InvalidParamsError unless params[:message]\n\n  # Validate message structure\n  message = A2A::Models::Message.from_hash(params[:message])\nrescue ArgumentError =&gt; e\n  raise A2A::InvalidParamsError.new(data: { reason: e.message })\nend\n</code></pre>"},{"location":"examples/#2-use-unique-task-ids","title":"2. Use Unique Task IDs","text":"<pre><code>require 'securerandom'\n\n# Always generate unique task IDs\ntask_id = SecureRandom.uuid\n# =&gt; \"a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\"\n\n# Or use a more specific format\ntask_id = \"task-#{Time.now.to_i}-#{SecureRandom.hex(4)}\"\n# =&gt; \"task-1634567890-a3f2\"\n</code></pre>"},{"location":"examples/#3-implement-proper-timeout-handling","title":"3. Implement Proper Timeout Handling","text":"<pre><code>require 'timeout'\n\ndef send_task_with_timeout(client, task_id, message, timeout: 30)\n  Timeout.timeout(timeout) do\n    client.send_task(task_id: task_id, message: message)\n  end\nrescue Timeout::Error\n  debug_me \"Task #{task_id} timed out after #{timeout} seconds\"\n  raise A2A::InternalError.new(data: { reason: \"Request timeout\" })\nend\n</code></pre>"},{"location":"examples/#4-use-metadata-for-context","title":"4. Use Metadata for Context","text":"<pre><code># Add metadata to tasks for tracking\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: { state: \"submitted\" },\n  metadata: {\n    source: \"web_app\",\n    user_id: \"user-123\",\n    priority: \"high\",\n    tags: [\"customer-support\", \"urgent\"],\n    created_at: Time.now.utc.iso8601,\n    correlation_id: request_id\n  }\n)\n\n# Add metadata to messages for context\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Help me with this issue\",\n  metadata: {\n    client_version: \"1.2.3\",\n    platform: \"ios\",\n    locale: \"en-US\"\n  }\n)\n</code></pre>"},{"location":"examples/#5-implement-graceful-degradation","title":"5. Implement Graceful Degradation","text":"<pre><code>def send_task_with_fallback(client, task_id, message)\n  # Try streaming first if supported\n  if client.agent_card&amp;.capabilities&amp;.streaming?\n    begin\n      send_task_streaming(client, task_id, message)\n    rescue A2A::UnsupportedOperationError\n      # Fallback to synchronous\n      send_task_sync(client, task_id, message)\n    end\n  else\n    send_task_sync(client, task_id, message)\n  end\nend\n</code></pre>"},{"location":"examples/#6-log-everything-for-debugging","title":"6. Log Everything for Debugging","text":"<pre><code>require 'debug_me'\n\ndef process_task(params)\n  debug_me \"Processing task: #{params[:taskId]}\"\n\n  begin\n    task = execute_task(params)\n    debug_me { [ :task, :task.id, :task.state ] }\n    task\n  rescue =&gt; e\n    debug_me \"Error processing task: #{e.class} - #{e.message}\"\n    raise\n  end\nend\n</code></pre>"},{"location":"examples/#7-test-models-in-isolation","title":"7. Test Models in Isolation","text":"<pre><code># Each method should be easily testable\nclass TaskProcessor\n  def validate_params(params)\n    # Isolated validation logic\n    raise ArgumentError, \"Missing taskId\" unless params[:taskId]\n    raise ArgumentError, \"Missing message\" unless params[:message]\n    params\n  end\n\n  def create_task(params)\n    # Isolated task creation\n    A2A::Models::Task.new(\n      id: params[:taskId],\n      status: { state: \"submitted\" }\n    )\n  end\n\n  def process(params)\n    validated = validate_params(params)\n    task = create_task(validated)\n    execute_task(task)\n  end\nend\n</code></pre>"},{"location":"examples/#8-handle-state-transitions-carefully","title":"8. Handle State Transitions Carefully","text":"<pre><code>def update_task_state(task, new_state, message: nil)\n  # Validate state transition\n  unless valid_transition?(task.state.to_s, new_state)\n    raise A2A::InvalidParamsError.new(\n      data: {\n        reason: \"Invalid state transition\",\n        from: task.state.to_s,\n        to: new_state\n      }\n    )\n  end\n\n  # Create new task with updated state\n  A2A::Models::Task.new(\n    id: task.id,\n    session_id: task.session_id,\n    status: {\n      state: new_state,\n      timestamp: Time.now.utc.iso8601,\n      message: message\n    },\n    artifacts: task.artifacts,\n    metadata: task.metadata\n  )\nend\n\ndef valid_transition?(from_state, to_state)\n  transitions = {\n    \"submitted\" =&gt; %w[working canceled failed],\n    \"working\" =&gt; %w[input-required completed failed canceled],\n    \"input-required\" =&gt; %w[working completed failed canceled]\n  }\n\n  transitions[from_state]&amp;.include?(to_state) || false\nend\n</code></pre>"},{"location":"examples/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"examples/#issue-1-invalid-json-payload","title":"Issue 1: Invalid JSON Payload","text":"<p>Problem: Receiving <code>-32700</code> JSON parse errors</p> <p>Solution: <pre><code>begin\n  data = JSON.parse(request.body.read, symbolize_names: true)\nrescue JSON::ParserError =&gt; e\n  return A2A::Protocol::Response.error(\n    id: nil,\n    error: {\n      code: -32700,\n      message: \"Invalid JSON payload\",\n      data: { reason: e.message }\n    }\n  )\nend\n</code></pre></p>"},{"location":"examples/#issue-2-task-not-found","title":"Issue 2: Task Not Found","text":"<p>Problem: <code>-32001</code> errors when querying tasks</p> <p>Solution: <pre><code>class TaskStore\n  def initialize\n    @tasks = {}\n  end\n\n  def find(task_id)\n    @tasks[task_id] or raise A2A::TaskNotFoundError\n  end\n\n  def save(task)\n    @tasks[task.id] = task\n  end\nend\n</code></pre></p>"},{"location":"examples/#issue-3-streaming-connection-drops","title":"Issue 3: Streaming Connection Drops","text":"<p>Problem: SSE connections closing unexpectedly</p> <p>Solution: <pre><code># Keep connection alive with heartbeat\ndef stream_task_updates(task_id)\n  response.headers['Content-Type'] = 'text/event-stream'\n  response.headers['Cache-Control'] = 'no-cache'\n  response.headers['X-Accel-Buffering'] = 'no'\n\n  stream :keep_open do |out|\n    # Send periodic heartbeat\n    timer = EventMachine::PeriodicTimer.new(15) do\n      out &lt;&lt; \": heartbeat\\n\\n\"\n    end\n\n    # Send updates\n    on_task_update(task_id) do |update|\n      out &lt;&lt; \"data: #{update.to_json}\\n\\n\"\n    end\n\n    # Cleanup\n    out.callback { timer.cancel }\n  end\nend\n</code></pre></p>"},{"location":"examples/#issue-4-memory-leaks-with-large-files","title":"Issue 4: Memory Leaks with Large Files","text":"<p>Problem: Server memory growing with file transfers</p> <p>Solution: <pre><code># Use URIs instead of embedding bytes for large files\ndef create_file_artifact(file_path)\n  # Instead of loading entire file into memory:\n  # bytes = File.read(file_path)\n\n  # Use a URI reference:\n  file_url = upload_to_storage(file_path)\n\n  A2A::Models::Artifact.new(\n    name: \"Large File\",\n    parts: [\n      A2A::Models::FilePart.new(\n        file: {\n          name: File.basename(file_path),\n          mime_type: detect_mime_type(file_path),\n          uri: file_url\n        }\n      )\n    ]\n  )\nend\n</code></pre></p>"},{"location":"examples/#issue-5-concurrent-task-processing","title":"Issue 5: Concurrent Task Processing","text":"<p>Problem: Race conditions with shared state</p> <p>Solution: <pre><code>require 'concurrent-ruby'\n\nclass ThreadSafeTaskStore\n  def initialize\n    @tasks = Concurrent::Hash.new\n    @locks = Concurrent::Hash.new\n  end\n\n  def update_task(task_id)\n    lock = @locks.compute_if_absent(task_id) { Mutex.new }\n\n    lock.synchronize do\n      task = @tasks[task_id] or raise A2A::TaskNotFoundError\n      updated = yield task\n      @tasks[task_id] = updated\n    end\n  end\nend\n</code></pre></p>"},{"location":"examples/#debugging-tips","title":"Debugging Tips","text":""},{"location":"examples/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>require 'debug_me'\n\n# Use debug_me for all debugging output\ndebug_me \"Starting task processing\"\ndebug_me { [ :task_id, :message, :session_id ] }\n\n# For constant strings\ndebug_me \"Task completed successfully\"\n</code></pre>"},{"location":"examples/#inspect-json-payloads","title":"Inspect JSON Payloads","text":"<pre><code>def log_request(request)\n  debug_me \"Incoming request:\"\n  debug_me JSON.pretty_generate(request.to_h)\nend\n\ndef log_response(response)\n  debug_me \"Outgoing response:\"\n  debug_me JSON.pretty_generate(response.to_h)\nend\n</code></pre>"},{"location":"examples/#test-with-curl","title":"Test with curl","text":"<pre><code># Test AgentCard endpoint\ncurl https://example.com/.well-known/agent.json\n\n# Test task submission\ncurl -X POST https://example.com/a2a \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": \"1\",\n    \"method\": \"tasks/send\",\n    \"params\": {\n      \"taskId\": \"task-123\",\n      \"message\": {\n        \"role\": \"user\",\n        \"parts\": [{\"type\": \"text\", \"text\": \"Hello\"}]\n      }\n    }\n  }'\n\n# Test SSE streaming\ncurl -N https://example.com/a2a/stream/task-123\n</code></pre>"},{"location":"examples/#additional-resources","title":"Additional Resources","text":""},{"location":"examples/#documentation","title":"Documentation","text":"<ul> <li>Basic Examples - Fundamental data model usage</li> <li>Client Examples - Building A2A HTTP clients</li> <li>Server Examples - Building A2A HTTP servers</li> <li>Gem Architecture - Gem architecture details</li> <li>A2A Protocol Specification - Full protocol spec</li> </ul>"},{"location":"examples/#external-links","title":"External Links","text":"<ul> <li>A2A Protocol GitHub</li> <li>JSON-RPC 2.0 Specification</li> <li>Server-Sent Events (SSE)</li> <li>Faraday HTTP Client</li> <li>Sinatra Web Framework</li> </ul>"},{"location":"examples/#related-gems","title":"Related Gems","text":"<ul> <li><code>faraday</code> - HTTP client library</li> <li><code>sinatra</code> - Web application framework</li> <li><code>puma</code> - Concurrent web server</li> <li><code>debug_me</code> - Debugging utility</li> </ul>"},{"location":"examples/#community","title":"Community","text":"<ul> <li>GitHub Issues</li> <li>Discussions</li> </ul>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<p>Now that you understand the overview, proceed to:</p> <ol> <li>Basic Examples to learn the fundamental data models</li> <li>Client Examples to build A2A clients</li> <li>Server Examples to build A2A servers</li> </ol> <p>Each guide contains complete, working code examples that you can copy and adapt for your own use.</p> <p>Back to Documentation Home</p>"},{"location":"examples/basic/","title":"Basic A2A Examples","text":"<p>This guide provides comprehensive examples of using the A2A gem's core data models. These examples cover all fundamental concepts you need to build A2A-compatible applications.</p>"},{"location":"examples/basic/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>AgentCard Examples</li> <li>Message Examples</li> <li>Task Examples</li> <li>Artifact Examples</li> <li>Part Type Examples</li> <li>Error Handling</li> <li>JSON Serialization</li> <li>Testing Patterns</li> <li>Complete Working Examples</li> </ul>"},{"location":"examples/basic/#overview","title":"Overview","text":"<p>The A2A gem provides rich data models that implement the A2A protocol specification. All models support:</p> <ul> <li>Immutable Construction: Objects are created with all required data</li> <li>JSON Serialization: Automatic conversion to/from JSON</li> <li>Validation: Input validation with helpful error messages</li> <li>Type Safety: Clear interfaces and expected types</li> <li>Testability: Each model can be tested in isolation</li> </ul>"},{"location":"examples/basic/#core-models","title":"Core Models","text":"<p>The gem includes these primary models:</p> <ol> <li>AgentCard - Agent metadata and capabilities</li> <li>Message - Communication turns between user and agent</li> <li>Task - The central unit of work with state management</li> <li>Artifact - Agent-generated outputs</li> <li>Part - Content components (Text, File, Data)</li> <li>TaskState - Task state enumeration</li> <li>TaskStatus - Task state with timestamp and optional message</li> </ol>"},{"location":"examples/basic/#agentcard-examples","title":"AgentCard Examples","text":"<p>An AgentCard describes an agent's capabilities and is typically served at <code>/.well-known/agent.json</code>.</p>"},{"location":"examples/basic/#example-1-minimal-agentcard","title":"Example 1: Minimal AgentCard","text":"<pre><code>require 'a2a'\n\n# Minimum required fields\nagent = A2A::Models::AgentCard.new(\n  name: \"Simple Agent\",\n  url: \"https://example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: false,\n    push_notifications: false\n  },\n  skills: [\n    {\n      id: \"help\",\n      name: \"Help\",\n      description: \"Provide help to users\"\n    }\n  ]\n)\n\nputs agent.name\n# =&gt; \"Simple Agent\"\n\nputs agent.skills.first.name\n# =&gt; \"Help\"\n\nputs agent.capabilities.streaming?\n# =&gt; false\n</code></pre>"},{"location":"examples/basic/#example-2-comprehensive-agentcard","title":"Example 2: Comprehensive AgentCard","text":"<pre><code>require 'a2a'\nrequire 'debug_me'\n\n# Full-featured AgentCard with all optional fields\nagent = A2A::Models::AgentCard.new(\n  # Required fields\n  name: \"Advanced Translation Agent\",\n  url: \"https://api.example.com/a2a\",\n  version: \"2.1.0\",\n\n  # Optional description\n  description: \"A sophisticated translation service supporting 50+ languages with context-aware translations\",\n\n  # Provider information\n  provider: {\n    organization: \"Example Translation Corp\",\n    url: \"https://example.com\",\n    support_email: \"support@example.com\"\n  },\n\n  # Documentation\n  documentation_url: \"https://docs.example.com/translation-api\",\n\n  # Capabilities\n  capabilities: {\n    streaming: true,\n    push_notifications: true,\n    state_transition_history: true\n  },\n\n  # Authentication\n  authentication: {\n    type: \"bearer\",\n    description: \"API key authentication via Authorization header\"\n  },\n\n  # Input/Output modes\n  default_input_modes: ['text', 'file'],\n  default_output_modes: ['text', 'data'],\n\n  # Skills\n  skills: [\n    {\n      id: \"translate\",\n      name: \"Translation\",\n      description: \"Translate text between languages\",\n      tags: [\"translation\", \"i18n\", \"localization\"],\n      examples: [\n        \"Translate 'Hello' to Spanish\",\n        \"Convert this document to French\"\n      ]\n    },\n    {\n      id: \"detect-language\",\n      name: \"Language Detection\",\n      description: \"Automatically detect the source language\",\n      tags: [\"detection\", \"nlp\"]\n    },\n    {\n      id: \"transliterate\",\n      name: \"Transliteration\",\n      description: \"Convert text between writing systems\",\n      tags: [\"transliteration\", \"romanization\"]\n    }\n  ]\n)\n\n# Access capabilities\ndebug_me \"Agent supports streaming: #{agent.capabilities.streaming?}\"\ndebug_me \"Agent supports push notifications: #{agent.capabilities.push_notifications?}\"\n\n# Access skills\nagent.skills.each do |skill|\n  debug_me \"Skill: #{skill.name} (#{skill.id})\"\n  debug_me \"  Description: #{skill.description}\"\n  debug_me \"  Tags: #{skill.tags.join(', ')}\" if skill.tags\nend\n\n# Access provider\nif agent.provider\n  debug_me \"Provider: #{agent.provider.organization}\"\n  debug_me \"Support: #{agent.provider.support_email}\"\nend\n</code></pre>"},{"location":"examples/basic/#example-3-creating-agentcard-from-json","title":"Example 3: Creating AgentCard from JSON","text":"<pre><code>require 'a2a'\nrequire 'json'\n\n# Load from JSON file (e.g., from /.well-known/agent.json)\njson_data = File.read('agent.json')\nagent_hash = JSON.parse(json_data, symbolize_names: true)\n\nagent = A2A::Models::AgentCard.from_hash(agent_hash)\n\nputs \"Loaded agent: #{agent.name} v#{agent.version}\"\nputs \"Skills: #{agent.skills.map(&amp;:name).join(', ')}\"\n</code></pre>"},{"location":"examples/basic/#example-4-serializing-agentcard-to-json","title":"Example 4: Serializing AgentCard to JSON","text":"<pre><code>require 'a2a'\nrequire 'json'\n\nagent = A2A::Models::AgentCard.new(\n  name: \"Example Agent\",\n  url: \"https://example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: { streaming: true },\n  skills: [{ id: \"help\", name: \"Help\", description: \"Get help\" }]\n)\n\n# Convert to hash\nagent_hash = agent.to_h\n\n# Serialize to JSON\njson = JSON.pretty_generate(agent_hash)\nputs json\n\n# Output:\n# {\n#   \"name\": \"Example Agent\",\n#   \"url\": \"https://example.com/a2a\",\n#   \"version\": \"1.0.0\",\n#   \"capabilities\": {\n#     \"streaming\": true,\n#     \"pushNotifications\": false\n#   },\n#   \"defaultInputModes\": [\"text\"],\n#   \"defaultOutputModes\": [\"text\"],\n#   \"skills\": [\n#     {\n#       \"id\": \"help\",\n#       \"name\": \"Help\",\n#       \"description\": \"Get help\"\n#     }\n#   ]\n# }\n\n# Save to file\nFile.write('.well-known/agent.json', json)\n</code></pre>"},{"location":"examples/basic/#message-examples","title":"Message Examples","text":"<p>Messages represent communication turns between users and agents. Each message contains one or more Parts.</p>"},{"location":"examples/basic/#example-5-simple-text-messages","title":"Example 5: Simple Text Messages","text":"<pre><code>require 'a2a'\n\n# User message with convenience method\nuser_msg = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"What's the weather like today?\"\n)\n\nputs user_msg.role\n# =&gt; \"user\"\n\nputs user_msg.parts.first.text\n# =&gt; \"What's the weather like today?\"\n\nputs user_msg.parts.first.type\n# =&gt; \"text\"\n\n# Agent response\nagent_msg = A2A::Models::Message.text(\n  role: \"agent\",\n  text: \"The weather is sunny with a temperature of 72\u00b0F.\"\n)\n\nputs agent_msg.role\n# =&gt; \"agent\"\n</code></pre>"},{"location":"examples/basic/#example-6-multi-part-messages","title":"Example 6: Multi-Part Messages","text":"<pre><code>require 'a2a'\n\n# Message with multiple parts\nmessage = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"Here are the search results:\"\n    ),\n    A2A::Models::DataPart.new(\n      data: {\n        results: [\n          { title: \"Result 1\", url: \"https://example.com/1\", relevance: 0.95 },\n          { title: \"Result 2\", url: \"https://example.com/2\", relevance: 0.87 },\n          { title: \"Result 3\", url: \"https://example.com/3\", relevance: 0.76 }\n        ],\n        total_count: 145,\n        query: \"ruby programming\"\n      }\n    ),\n    A2A::Models::TextPart.new(\n      text: \"Would you like me to refine these results?\"\n    )\n  ]\n)\n\n# Access parts\nmessage.parts.each_with_index do |part, i|\n  puts \"Part #{i + 1}: #{part.type}\"\n\n  case part\n  when A2A::Models::TextPart\n    puts \"  Text: #{part.text}\"\n  when A2A::Models::DataPart\n    puts \"  Data keys: #{part.data.keys.join(', ')}\"\n  end\nend\n</code></pre>"},{"location":"examples/basic/#example-7-messages-with-metadata","title":"Example 7: Messages with Metadata","text":"<pre><code>require 'a2a'\n\n# Add metadata for context\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Translate this to Spanish\",\n  metadata: {\n    client: \"mobile_app\",\n    version: \"2.1.0\",\n    platform: \"ios\",\n    locale: \"en-US\",\n    user_id: \"user-12345\",\n    request_id: \"req-#{Time.now.to_i}\",\n    timestamp: Time.now.utc.iso8601\n  }\n)\n\n# Access metadata\nputs message.metadata[:platform]\n# =&gt; \"ios\"\n\nputs message.metadata[:client]\n# =&gt; \"mobile_app\"\n</code></pre>"},{"location":"examples/basic/#example-8-file-messages","title":"Example 8: File Messages","text":"<pre><code>require 'a2a'\nrequire 'base64'\n\n# Message with file content (embedded bytes)\nfile_message = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"Please analyze this document\"\n    ),\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"document.pdf\",\n        mime_type: \"application/pdf\",\n        bytes: Base64.strict_encode64(File.read(\"document.pdf\"))\n      }\n    )\n  ]\n)\n\n# Message with file reference (URI)\nfile_ref_message = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"large_video.mp4\",\n        mime_type: \"video/mp4\",\n        uri: \"https://storage.example.com/files/video-123.mp4\"\n      }\n    )\n  ]\n)\n\n# Accessing file information\nfile_part = file_message.parts[1]\nputs file_part.file.name\n# =&gt; \"document.pdf\"\n\nputs file_part.file.mime_type\n# =&gt; \"application/pdf\"\n\n# Check if file has bytes or URI\nif file_part.file.bytes\n  puts \"File embedded (#{file_part.file.bytes.length} bytes)\"\nelsif file_part.file.uri\n  puts \"File referenced: #{file_part.file.uri}\"\nend\n</code></pre>"},{"location":"examples/basic/#task-examples","title":"Task Examples","text":"<p>Tasks are the central unit of work in the A2A protocol. They track state and contain artifacts.</p>"},{"location":"examples/basic/#example-9-creating-tasks","title":"Example 9: Creating Tasks","text":"<pre><code>require 'a2a'\nrequire 'securerandom'\n\n# Create a new task\ntask = A2A::Models::Task.new(\n  id: SecureRandom.uuid,\n  status: {\n    state: \"submitted\"\n  }\n)\n\nputs \"Task ID: #{task.id}\"\nputs \"Task state: #{task.state}\"\nputs \"Is terminal? #{task.state.terminal?}\"\n# =&gt; false\n\n# Task with session for multi-turn conversation\ntask_with_session = A2A::Models::Task.new(\n  id: SecureRandom.uuid,\n  session_id: SecureRandom.uuid,\n  status: {\n    state: \"submitted\",\n    timestamp: Time.now.utc.iso8601\n  }\n)\n\nputs \"Session ID: #{task_with_session.session_id}\"\n</code></pre>"},{"location":"examples/basic/#example-10-task-state-transitions","title":"Example 10: Task State Transitions","text":"<pre><code>require 'a2a'\nrequire 'securerandom'\nrequire 'debug_me'\n\ntask_id = SecureRandom.uuid\n\n# 1. Submitted state\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: { state: \"submitted\" }\n)\ndebug_me \"Task submitted: #{task.state}\"\n\n# 2. Working state\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: {\n    state: \"working\",\n    message: A2A::Models::Message.text(\n      role: \"agent\",\n      text: \"Processing your request...\"\n    )\n  }\n)\ndebug_me \"Task working: #{task.state}\"\n\n# 3. Input required state\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: {\n    state: \"input-required\",\n    message: A2A::Models::Message.text(\n      role: \"agent\",\n      text: \"Which language would you like to translate to?\"\n    )\n  }\n)\ndebug_me \"Task needs input: #{task.state.input_required?}\"\n\n# 4. Completed state with artifacts\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: { state: \"completed\" },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Translation\",\n      parts: [\n        A2A::Models::TextPart.new(text: \"Hola, mundo!\")\n      ]\n    )\n  ]\n)\ndebug_me \"Task completed: #{task.state.terminal?}\"\n\n# 5. Failed state\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: {\n    state: \"failed\",\n    message: A2A::Models::Message.text(\n      role: \"agent\",\n      text: \"Translation service unavailable\"\n    )\n  }\n)\ndebug_me \"Task failed: #{task.state.failed?}\"\n\n# 6. Canceled state\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: { state: \"canceled\" }\n)\ndebug_me \"Task canceled: #{task.state.canceled?}\"\n</code></pre>"},{"location":"examples/basic/#example-11-task-state-validation","title":"Example 11: Task State Validation","text":"<pre><code>require 'a2a'\n\n# All valid task states\nvalid_states = %w[\n  submitted\n  working\n  input-required\n  completed\n  canceled\n  failed\n  unknown\n]\n\nvalid_states.each do |state_name|\n  state = A2A::Models::TaskState.new(state_name)\n  puts \"#{state_name}: terminal=#{state.terminal?}\"\nend\n\n# Output:\n# submitted: terminal=false\n# working: terminal=false\n# input-required: terminal=false\n# completed: terminal=true\n# canceled: terminal=true\n# failed: terminal=true\n# unknown: terminal=false\n\n# Invalid state raises error\nbegin\n  invalid_state = A2A::Models::TaskState.new(\"invalid\")\nrescue ArgumentError =&gt; e\n  puts \"Error: #{e.message}\"\n  # =&gt; \"Invalid task state: invalid. Must be one of: submitted, working, ...\"\nend\n</code></pre>"},{"location":"examples/basic/#example-12-task-with-metadata","title":"Example 12: Task with Metadata","text":"<pre><code>require 'a2a'\nrequire 'securerandom'\n\n# Add metadata for tracking and debugging\ntask = A2A::Models::Task.new(\n  id: SecureRandom.uuid,\n  session_id: SecureRandom.uuid,\n  status: { state: \"working\" },\n  metadata: {\n    # Tracking information\n    source: \"web_app\",\n    user_id: \"user-12345\",\n    organization_id: \"org-456\",\n\n    # Priority and routing\n    priority: \"high\",\n    queue: \"translation\",\n    worker: \"worker-3\",\n\n    # Tags and categorization\n    tags: [\"translation\", \"spanish\", \"urgent\"],\n    category: \"language_services\",\n\n    # Timing\n    created_at: Time.now.utc.iso8601,\n    deadline: (Time.now + 3600).utc.iso8601,\n\n    # Correlation\n    correlation_id: \"req-789\",\n    parent_task_id: \"task-parent-123\",\n\n    # Custom data\n    estimated_duration: 30,\n    language_pair: \"en-es\"\n  }\n)\n\n# Access metadata\nputs \"Priority: #{task.metadata[:priority]}\"\nputs \"Tags: #{task.metadata[:tags].join(', ')}\"\nputs \"Estimated duration: #{task.metadata[:estimated_duration]}s\"\n</code></pre>"},{"location":"examples/basic/#artifact-examples","title":"Artifact Examples","text":"<p>Artifacts represent outputs generated by the agent during task processing.</p>"},{"location":"examples/basic/#example-13-simple-text-artifact","title":"Example 13: Simple Text Artifact","text":"<pre><code>require 'a2a'\n\n# Basic text artifact\nartifact = A2A::Models::Artifact.new(\n  name: \"Summary\",\n  description: \"Document summary\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"This document discusses the implementation of the A2A protocol...\"\n    )\n  ]\n)\n\nputs artifact.name\n# =&gt; \"Summary\"\n\nputs artifact.parts.first.text\n# =&gt; \"This document discusses...\"\n</code></pre>"},{"location":"examples/basic/#example-14-structured-data-artifact","title":"Example 14: Structured Data Artifact","text":"<pre><code>require 'a2a'\n\n# Artifact with structured data\nartifact = A2A::Models::Artifact.new(\n  name: \"Analysis Results\",\n  description: \"Sentiment and entity analysis\",\n  parts: [\n    A2A::Models::DataPart.new(\n      data: {\n        sentiment: {\n          score: 0.85,\n          label: \"positive\",\n          confidence: 0.92\n        },\n        entities: [\n          { text: \"New York\", type: \"Location\", confidence: 0.98 },\n          { text: \"Apple Inc\", type: \"Organization\", confidence: 0.95 },\n          { text: \"Tim Cook\", type: \"Person\", confidence: 0.97 }\n        ],\n        keywords: [\n          { word: \"technology\", relevance: 0.89 },\n          { word: \"innovation\", relevance: 0.76 }\n        ],\n        statistics: {\n          word_count: 452,\n          sentence_count: 23,\n          paragraph_count: 5\n        }\n      }\n    )\n  ],\n  metadata: {\n    model: \"gpt-4\",\n    processing_time_ms: 1234,\n    timestamp: Time.now.utc.iso8601\n  }\n)\n\n# Access data\ndata = artifact.parts.first.data\nputs \"Sentiment: #{data[:sentiment][:label]} (#{data[:sentiment][:score]})\"\nputs \"Entities found: #{data[:entities].length}\"\nputs \"Word count: #{data[:statistics][:word_count]}\"\n</code></pre>"},{"location":"examples/basic/#example-15-file-artifact","title":"Example 15: File Artifact","text":"<pre><code>require 'a2a'\nrequire 'base64'\n\n# Artifact with generated file\nartifact = A2A::Models::Artifact.new(\n  name: \"Generated Report\",\n  description: \"PDF report of analysis results\",\n  parts: [\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"analysis_report.pdf\",\n        mime_type: \"application/pdf\",\n        bytes: Base64.strict_encode64(File.read(\"report.pdf\"))\n      }\n    )\n  ]\n)\n\n# Or with URI reference for large files\nartifact_with_uri = A2A::Models::Artifact.new(\n  name: \"Generated Video\",\n  description: \"Promotional video\",\n  parts: [\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"promo_video.mp4\",\n        mime_type: \"video/mp4\",\n        uri: \"https://storage.example.com/videos/promo-123.mp4\"\n      }\n    )\n  ],\n  metadata: {\n    duration_seconds: 120,\n    resolution: \"1920x1080\",\n    file_size_bytes: 45_678_901\n  }\n)\n</code></pre>"},{"location":"examples/basic/#example-16-multi-part-artifact","title":"Example 16: Multi-Part Artifact","text":"<pre><code>require 'a2a'\n\n# Artifact with multiple parts (text + data + file)\nartifact = A2A::Models::Artifact.new(\n  name: \"Complete Analysis\",\n  description: \"Full analysis with summary, data, and visualizations\",\n  parts: [\n    # Part 1: Text summary\n    A2A::Models::TextPart.new(\n      text: \"Executive Summary:\\n\\nThe analysis reveals positive sentiment across all categories...\"\n    ),\n\n    # Part 2: Structured data\n    A2A::Models::DataPart.new(\n      data: {\n        overall_score: 0.87,\n        category_scores: {\n          product: 0.92,\n          service: 0.85,\n          support: 0.84\n        },\n        recommendations: [\n          \"Focus on maintaining high product quality\",\n          \"Improve response time in support\"\n        ]\n      }\n    ),\n\n    # Part 3: Visualization file\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"sentiment_chart.png\",\n        mime_type: \"image/png\",\n        uri: \"https://storage.example.com/charts/sent-123.png\"\n      }\n    )\n  ]\n)\n\n# Iterate through parts\nartifact.parts.each_with_index do |part, i|\n  puts \"Part #{i + 1} (#{part.type}):\"\n\n  case part\n  when A2A::Models::TextPart\n    puts \"  #{part.text[0..50]}...\"\n  when A2A::Models::DataPart\n    puts \"  Data keys: #{part.data.keys.join(', ')}\"\n  when A2A::Models::FilePart\n    puts \"  File: #{part.file.name}\"\n  end\nend\n</code></pre>"},{"location":"examples/basic/#example-17-streaming-artifacts","title":"Example 17: Streaming Artifacts","text":"<pre><code>require 'a2a'\n\n# Artifact chunk for streaming (first chunk)\nchunk1 = A2A::Models::Artifact.new(\n  name: \"Response\",\n  index: 0,\n  append: false,\n  last_chunk: false,\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"The answer to your question\"\n    )\n  ]\n)\n\n# Second chunk (appending)\nchunk2 = A2A::Models::Artifact.new(\n  name: \"Response\",\n  index: 0,\n  append: true,\n  last_chunk: false,\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \" is that the A2A protocol\"\n    )\n  ]\n)\n\n# Final chunk\nchunk3 = A2A::Models::Artifact.new(\n  name: \"Response\",\n  index: 0,\n  append: true,\n  last_chunk: true,\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \" enables agent interoperability.\"\n    )\n  ]\n)\n\n# Combine chunks\nfull_text = [chunk1, chunk2, chunk3]\n  .map { |c| c.parts.first.text }\n  .join\n\nputs full_text\n# =&gt; \"The answer to your question is that the A2A protocol enables agent interoperability.\"\n</code></pre>"},{"location":"examples/basic/#part-type-examples","title":"Part Type Examples","text":"<p>Parts are the building blocks of Messages and Artifacts. There are three types: Text, File, and Data.</p>"},{"location":"examples/basic/#example-18-textpart","title":"Example 18: TextPart","text":"<pre><code>require 'a2a'\n\n# Simple text part\ntext_part = A2A::Models::TextPart.new(\n  text: \"Hello, world!\"\n)\n\nputs text_part.type\n# =&gt; \"text\"\n\nputs text_part.text\n# =&gt; \"Hello, world!\"\n\n# Text part with metadata\ntext_with_meta = A2A::Models::TextPart.new(\n  text: \"Important information\",\n  metadata: {\n    language: \"en\",\n    format: \"plain\",\n    importance: \"high\"\n  }\n)\n\n# Convert to hash\nhash = text_with_meta.to_h\n# =&gt; { type: \"text\", text: \"Important information\", metadata: { ... } }\n</code></pre>"},{"location":"examples/basic/#example-19-datapart","title":"Example 19: DataPart","text":"<pre><code>require 'a2a'\n\n# Simple data part\ndata_part = A2A::Models::DataPart.new(\n  data: {\n    temperature: 72,\n    humidity: 45,\n    condition: \"sunny\"\n  }\n)\n\nputs data_part.type\n# =&gt; \"data\"\n\nputs data_part.data[:temperature]\n# =&gt; 72\n\n# Complex nested data\ncomplex_data = A2A::Models::DataPart.new(\n  data: {\n    user: {\n      id: \"user-123\",\n      name: \"John Doe\",\n      preferences: {\n        language: \"en\",\n        timezone: \"America/New_York\"\n      }\n    },\n    results: [\n      { id: 1, score: 0.95 },\n      { id: 2, score: 0.87 }\n    ],\n    metadata: {\n      timestamp: Time.now.utc.iso8601,\n      version: \"2.0\"\n    }\n  }\n)\n\n# Access nested data\nputs complex_data.data[:user][:name]\n# =&gt; \"John Doe\"\n\nputs complex_data.data[:results].first[:score]\n# =&gt; 0.95\n</code></pre>"},{"location":"examples/basic/#example-20-filepart","title":"Example 20: FilePart","text":"<pre><code>require 'a2a'\nrequire 'base64'\n\n# File with embedded bytes\nfile_with_bytes = A2A::Models::FilePart.new(\n  file: {\n    name: \"image.png\",\n    mime_type: \"image/png\",\n    bytes: Base64.strict_encode64(File.read(\"image.png\"))\n  }\n)\n\nputs file_with_bytes.type\n# =&gt; \"file\"\n\nputs file_with_bytes.file.name\n# =&gt; \"image.png\"\n\n# File with URI reference\nfile_with_uri = A2A::Models::FilePart.new(\n  file: {\n    name: \"document.pdf\",\n    mime_type: \"application/pdf\",\n    uri: \"https://storage.example.com/docs/document-123.pdf\"\n  }\n)\n\nputs file_with_uri.file.uri\n# =&gt; \"https://storage.example.com/docs/document-123.pdf\"\n\n# File part with metadata\nfile_with_meta = A2A::Models::FilePart.new(\n  file: {\n    name: \"video.mp4\",\n    mime_type: \"video/mp4\",\n    uri: \"https://cdn.example.com/video-456.mp4\"\n  },\n  metadata: {\n    duration_seconds: 120,\n    resolution: \"1920x1080\",\n    file_size_bytes: 45_678_901,\n    codec: \"h264\"\n  }\n)\n</code></pre>"},{"location":"examples/basic/#example-21-creating-parts-from-hash","title":"Example 21: Creating Parts from Hash","text":"<pre><code>require 'a2a'\n\n# The Part base class has a factory method\ntext_hash = {\n  type: \"text\",\n  text: \"Hello\"\n}\ntext_part = A2A::Models::Part.from_hash(text_hash)\n# =&gt; A2A::Models::TextPart\n\ndata_hash = {\n  type: \"data\",\n  data: { key: \"value\" }\n}\ndata_part = A2A::Models::Part.from_hash(data_hash)\n# =&gt; A2A::Models::DataPart\n\nfile_hash = {\n  type: \"file\",\n  file: {\n    name: \"file.txt\",\n    mimeType: \"text/plain\",\n    uri: \"https://example.com/file.txt\"\n  }\n}\nfile_part = A2A::Models::Part.from_hash(file_hash)\n# =&gt; A2A::Models::FilePart\n\n# Unknown type raises error\nbegin\n  invalid_hash = { type: \"unknown\" }\n  A2A::Models::Part.from_hash(invalid_hash)\nrescue ArgumentError =&gt; e\n  puts e.message\n  # =&gt; \"Unknown part type: unknown\"\nend\n</code></pre>"},{"location":"examples/basic/#error-handling","title":"Error Handling","text":"<p>The A2A gem provides a comprehensive error hierarchy for handling protocol errors.</p>"},{"location":"examples/basic/#example-22-error-types","title":"Example 22: Error Types","text":"<pre><code>require 'a2a'\n\n# All A2A errors inherit from A2A::Error\n# JSON-RPC errors inherit from A2A::JSONRPCError\n\n# 1. JSON Parse Error (-32700)\nbegin\n  raise A2A::JSONParseError.new(data: { position: 42 })\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32700\n  puts \"Message: #{e.message}\" # =&gt; \"Invalid JSON payload\"\n  puts \"Data: #{e.data}\"      # =&gt; { position: 42 }\nend\n\n# 2. Invalid Request Error (-32600)\nbegin\n  raise A2A::InvalidRequestError\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32600\n  puts \"Message: #{e.message}\" # =&gt; \"Request payload validation error\"\nend\n\n# 3. Method Not Found Error (-32601)\nbegin\n  raise A2A::MethodNotFoundError\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32601\n  puts \"Message: #{e.message}\" # =&gt; \"Method not found\"\nend\n\n# 4. Invalid Params Error (-32602)\nbegin\n  raise A2A::InvalidParamsError.new(\n    data: { missing: [\"taskId\", \"message\"] }\n  )\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32602\n  puts \"Message: #{e.message}\" # =&gt; \"Invalid parameters\"\n  puts \"Missing: #{e.data[:missing]}\" # =&gt; [\"taskId\", \"message\"]\nend\n\n# 5. Internal Error (-32603)\nbegin\n  raise A2A::InternalError.new(data: { reason: \"Database connection failed\" })\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32603\n  puts \"Message: #{e.message}\" # =&gt; \"Internal error\"\nend\n\n# 6. Task Not Found Error (-32001)\nbegin\n  raise A2A::TaskNotFoundError\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32001\n  puts \"Message: #{e.message}\" # =&gt; \"Task not found\"\nend\n\n# 7. Task Not Cancelable Error (-32002)\nbegin\n  raise A2A::TaskNotCancelableError\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32002\n  puts \"Message: #{e.message}\" # =&gt; \"Task cannot be canceled\"\nend\n\n# 8. Push Notification Not Supported Error (-32003)\nbegin\n  raise A2A::PushNotificationNotSupportedError\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32003\n  puts \"Message: #{e.message}\" # =&gt; \"Push Notification is not supported\"\nend\n\n# 9. Unsupported Operation Error (-32004)\nbegin\n  raise A2A::UnsupportedOperationError\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Code: #{e.code}\"      # =&gt; -32004\n  puts \"Message: #{e.message}\" # =&gt; \"This operation is not supported\"\nend\n</code></pre>"},{"location":"examples/basic/#example-23-error-handling-patterns","title":"Example 23: Error Handling Patterns","text":"<pre><code>require 'a2a'\nrequire 'debug_me'\n\ndef safe_create_task(params)\n  # Validate parameters\n  unless params[:taskId]\n    raise A2A::InvalidParamsError.new(\n      data: { missing: \"taskId\", message: \"Task ID is required\" }\n    )\n  end\n\n  unless params[:message]\n    raise A2A::InvalidParamsError.new(\n      data: { missing: \"message\", message: \"Message is required\" }\n    )\n  end\n\n  # Create task\n  task = A2A::Models::Task.new(\n    id: params[:taskId],\n    status: { state: \"submitted\" }\n  )\n\n  debug_me \"Task created successfully: #{task.id}\"\n  task\n\nrescue ArgumentError =&gt; e\n  # Handle validation errors from model\n  debug_me \"Validation error: #{e.message}\"\n  raise A2A::InvalidParamsError.new(data: { reason: e.message })\n\nrescue StandardError =&gt; e\n  # Catch unexpected errors\n  debug_me \"Unexpected error: #{e.class} - #{e.message}\"\n  raise A2A::InternalError.new(data: { error: e.class.name })\nend\n\n# Usage\nbegin\n  task = safe_create_task(taskId: \"task-123\", message: { role: \"user\" })\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Error code #{e.code}: #{e.message}\"\n  puts \"Data: #{e.data}\" if e.data\nend\n</code></pre>"},{"location":"examples/basic/#json-serialization","title":"JSON Serialization","text":"<p>All A2A models support bidirectional JSON serialization.</p>"},{"location":"examples/basic/#example-24-serializing-to-json","title":"Example 24: Serializing to JSON","text":"<pre><code>require 'a2a'\nrequire 'json'\n\n# Create a complete task with all features\ntask = A2A::Models::Task.new(\n  id: \"task-123\",\n  session_id: \"session-456\",\n  status: {\n    state: \"completed\",\n    message: A2A::Models::Message.text(\n      role: \"agent\",\n      text: \"Task completed successfully\"\n    ),\n    timestamp: Time.now.utc.iso8601\n  },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Results\",\n      parts: [\n        A2A::Models::TextPart.new(text: \"Here are the results\"),\n        A2A::Models::DataPart.new(data: { count: 42, status: \"success\" })\n      ]\n    )\n  ],\n  metadata: {\n    priority: \"high\",\n    tags: [\"important\"]\n  }\n)\n\n# Convert to hash\ntask_hash = task.to_h\n\n# Serialize to JSON\njson = JSON.pretty_generate(task_hash)\nputs json\n\n# Compact JSON (no pretty printing)\ncompact_json = task.to_json\n</code></pre>"},{"location":"examples/basic/#example-25-deserializing-from-json","title":"Example 25: Deserializing from JSON","text":"<pre><code>require 'a2a'\nrequire 'json'\n\n# JSON string from API response\njson_str = &lt;&lt;~JSON\n  {\n    \"id\": \"task-789\",\n    \"sessionId\": \"session-101\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"timestamp\": \"2024-01-15T10:30:00Z\"\n    },\n    \"artifacts\": [\n      {\n        \"name\": \"Translation\",\n        \"parts\": [\n          {\n            \"type\": \"text\",\n            \"text\": \"Hola, mundo!\"\n          }\n        ]\n      }\n    ]\n  }\nJSON\n\n# Parse JSON\nhash = JSON.parse(json_str, symbolize_names: true)\n\n# Create task from hash\ntask = A2A::Models::Task.from_hash(hash)\n\nputs \"Task ID: #{task.id}\"\nputs \"State: #{task.state}\"\nputs \"Artifact: #{task.artifacts.first.parts.first.text}\"\n</code></pre>"},{"location":"examples/basic/#example-26-round-trip-serialization","title":"Example 26: Round-Trip Serialization","text":"<pre><code>require 'a2a'\nrequire 'json'\n\n# Create original message\noriginal = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Hello\"),\n    A2A::Models::DataPart.new(data: { key: \"value\" })\n  ],\n  metadata: { timestamp: Time.now.utc.iso8601 }\n)\n\n# Serialize to JSON\njson = original.to_json\n\n# Deserialize back\nhash = JSON.parse(json, symbolize_names: true)\nrestored = A2A::Models::Message.from_hash(hash)\n\n# Verify equality\nputs \"Role match: #{original.role == restored.role}\"\nputs \"Parts count match: #{original.parts.length == restored.parts.length}\"\nputs \"First part text match: #{original.parts[0].text == restored.parts[0].text}\"\nputs \"Second part data match: #{original.parts[1].data == restored.parts[1].data}\"\n</code></pre>"},{"location":"examples/basic/#testing-patterns","title":"Testing Patterns","text":"<p>Examples of testing A2A models in isolation.</p>"},{"location":"examples/basic/#example-27-unit-testing-models","title":"Example 27: Unit Testing Models","text":"<pre><code>require 'a2a'\nrequire 'minitest/autorun'\n\nclass TestTaskState &lt; Minitest::Test\n  def test_valid_states\n    valid_states = %w[submitted working input-required completed canceled failed unknown]\n\n    valid_states.each do |state_name|\n      state = A2A::Models::TaskState.new(state_name)\n      assert_equal state_name, state.to_s\n    end\n  end\n\n  def test_terminal_states\n    terminal_states = %w[completed canceled failed]\n\n    terminal_states.each do |state_name|\n      state = A2A::Models::TaskState.new(state_name)\n      assert state.terminal?, \"#{state_name} should be terminal\"\n    end\n  end\n\n  def test_non_terminal_states\n    non_terminal = %w[submitted working input-required unknown]\n\n    non_terminal.each do |state_name|\n      state = A2A::Models::TaskState.new(state_name)\n      refute state.terminal?, \"#{state_name} should not be terminal\"\n    end\n  end\n\n  def test_invalid_state_raises_error\n    assert_raises(ArgumentError) do\n      A2A::Models::TaskState.new(\"invalid-state\")\n    end\n  end\n\n  def test_state_predicates\n    submitted = A2A::Models::TaskState.new(\"submitted\")\n    assert submitted.submitted?\n    refute submitted.working?\n\n    working = A2A::Models::TaskState.new(\"working\")\n    assert working.working?\n    refute working.completed?\n  end\nend\n\nclass TestMessage &lt; Minitest::Test\n  def test_text_convenience_method\n    msg = A2A::Models::Message.text(role: \"user\", text: \"Hello\")\n\n    assert_equal \"user\", msg.role\n    assert_equal 1, msg.parts.length\n    assert_instance_of A2A::Models::TextPart, msg.parts.first\n    assert_equal \"Hello\", msg.parts.first.text\n  end\n\n  def test_invalid_role_raises_error\n    assert_raises(ArgumentError) do\n      A2A::Models::Message.text(role: \"invalid\", text: \"Hello\")\n    end\n  end\n\n  def test_multi_part_message\n    msg = A2A::Models::Message.new(\n      role: \"agent\",\n      parts: [\n        A2A::Models::TextPart.new(text: \"Text\"),\n        A2A::Models::DataPart.new(data: { key: \"value\" })\n      ]\n    )\n\n    assert_equal 2, msg.parts.length\n    assert_instance_of A2A::Models::TextPart, msg.parts[0]\n    assert_instance_of A2A::Models::DataPart, msg.parts[1]\n  end\nend\n</code></pre>"},{"location":"examples/basic/#example-28-testing-json-serialization","title":"Example 28: Testing JSON Serialization","text":"<pre><code>require 'a2a'\nrequire 'json'\nrequire 'minitest/autorun'\n\nclass TestSerialization &lt; Minitest::Test\n  def test_task_serialization_round_trip\n    original = A2A::Models::Task.new(\n      id: \"task-123\",\n      status: { state: \"completed\" }\n    )\n\n    # Serialize\n    json = original.to_json\n    hash = JSON.parse(json, symbolize_names: true)\n\n    # Deserialize\n    restored = A2A::Models::Task.from_hash(hash)\n\n    assert_equal original.id, restored.id\n    assert_equal original.state.to_s, restored.state.to_s\n  end\n\n  def test_message_with_metadata_serialization\n    original = A2A::Models::Message.text(\n      role: \"user\",\n      text: \"Hello\",\n      metadata: { key: \"value\", number: 42 }\n    )\n\n    json = original.to_json\n    hash = JSON.parse(json, symbolize_names: true)\n    restored = A2A::Models::Message.from_hash(hash)\n\n    assert_equal original.metadata, restored.metadata\n  end\nend\n</code></pre>"},{"location":"examples/basic/#complete-working-examples","title":"Complete Working Examples","text":""},{"location":"examples/basic/#example-29-complete-conversation-workflow","title":"Example 29: Complete Conversation Workflow","text":"<pre><code>#!/usr/bin/env ruby\nrequire 'a2a'\nrequire 'securerandom'\nrequire 'debug_me'\n\n# Simulate a complete conversation workflow\n\n# 1. Create agent card\nagent_card = A2A::Models::AgentCard.new(\n  name: \"Translation Agent\",\n  url: \"https://api.example.com/a2a\",\n  version: \"1.0.0\",\n  capabilities: { streaming: false, push_notifications: false },\n  skills: [\n    { id: \"translate\", name: \"Translation\", description: \"Translate text\" }\n  ]\n)\n\ndebug_me \"Agent: #{agent_card.name}\"\n\n# 2. Start a session\nsession_id = SecureRandom.uuid\ndebug_me \"Session: #{session_id}\"\n\n# 3. First user message\nuser_msg_1 = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Translate 'Hello, world!' to Spanish\"\n)\n\ntask_1 = A2A::Models::Task.new(\n  id: SecureRandom.uuid,\n  session_id: session_id,\n  status: {\n    state: \"submitted\",\n    message: user_msg_1\n  }\n)\n\ndebug_me \"Task 1 created: #{task_1.id}\"\n\n# 4. Agent processes and completes\ntask_1_completed = A2A::Models::Task.new(\n  id: task_1.id,\n  session_id: session_id,\n  status: { state: \"completed\" },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Translation\",\n      parts: [\n        A2A::Models::TextPart.new(text: \"Hola, mundo!\"),\n        A2A::Models::DataPart.new(\n          data: {\n            source_language: \"en\",\n            target_language: \"es\",\n            confidence: 0.99\n          }\n        )\n      ]\n    )\n  ]\n)\n\ndebug_me \"Task 1 completed\"\ndebug_me \"Translation: #{task_1_completed.artifacts.first.parts.first.text}\"\n\n# 5. Follow-up question in same session\nuser_msg_2 = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Now translate it to French\"\n)\n\ntask_2 = A2A::Models::Task.new(\n  id: SecureRandom.uuid,\n  session_id: session_id,  # Same session\n  status: {\n    state: \"submitted\",\n    message: user_msg_2\n  }\n)\n\ndebug_me \"Task 2 created: #{task_2.id}\"\n\n# 6. Agent completes second task\ntask_2_completed = A2A::Models::Task.new(\n  id: task_2.id,\n  session_id: session_id,\n  status: { state: \"completed\" },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Translation\",\n      parts: [\n        A2A::Models::TextPart.new(text: \"Bonjour, le monde!\"),\n        A2A::Models::DataPart.new(\n          data: {\n            source_language: \"en\",\n            target_language: \"fr\",\n            confidence: 0.98\n          }\n        )\n      ]\n    )\n  ]\n)\n\ndebug_me \"Task 2 completed\"\ndebug_me \"Translation: #{task_2_completed.artifacts.first.parts.first.text}\"\n\ndebug_me \"Conversation completed successfully\"\n</code></pre>"},{"location":"examples/basic/#example-30-error-recovery-workflow","title":"Example 30: Error Recovery Workflow","text":"<pre><code>#!/usr/bin/env ruby\nrequire 'a2a'\nrequire 'securerandom'\nrequire 'debug_me'\n\ndef process_user_request(text)\n  task_id = SecureRandom.uuid\n  debug_me \"Processing request: #{task_id}\"\n\n  # Create message\n  message = A2A::Models::Message.text(role: \"user\", text: text)\n\n  # Create task\n  task = A2A::Models::Task.new(\n    id: task_id,\n    status: { state: \"submitted\", message: message }\n  )\n\n  # Simulate processing\n  begin\n    # This might raise an error\n    result = perform_translation(text)\n\n    # Success\n    A2A::Models::Task.new(\n      id: task_id,\n      status: { state: \"completed\" },\n      artifacts: [\n        A2A::Models::Artifact.new(\n          name: \"Translation\",\n          parts: [A2A::Models::TextPart.new(text: result)]\n        )\n      ]\n    )\n\n  rescue StandardError =&gt; e\n    # Error handling\n    debug_me \"Error: #{e.message}\"\n\n    A2A::Models::Task.new(\n      id: task_id,\n      status: {\n        state: \"failed\",\n        message: A2A::Models::Message.text(\n          role: \"agent\",\n          text: \"Sorry, translation failed: #{e.message}\"\n        )\n      }\n    )\n  end\nend\n\ndef perform_translation(text)\n  # Simulate translation\n  raise \"Translation service unavailable\" if text.empty?\n  \"Translated: #{text}\"\nend\n\n# Test success case\ntask1 = process_user_request(\"Hello\")\ndebug_me \"Task 1 state: #{task1.state}\"\ndebug_me \"Result: #{task1.artifacts&amp;.first&amp;.parts&amp;.first&amp;.text}\"\n\n# Test error case\ntask2 = process_user_request(\"\")\ndebug_me \"Task 2 state: #{task2.state}\"\ndebug_me \"Error message: #{task2.status.message.parts.first.text}\"\n</code></pre>"},{"location":"examples/basic/#summary","title":"Summary","text":"<p>This guide covered all fundamental aspects of the A2A gem's data models:</p> <ol> <li>AgentCard - Creating and serializing agent metadata</li> <li>Messages - Building user and agent messages with various content types</li> <li>Tasks - Managing task lifecycle and states</li> <li>Artifacts - Generating outputs with different part types</li> <li>Parts - Working with Text, File, and Data parts</li> <li>Errors - Handling protocol errors properly</li> <li>JSON - Serializing and deserializing models</li> <li>Testing - Testing models in isolation</li> </ol>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<ul> <li>Client Examples - Learn how to build A2A HTTP clients</li> <li>Server Examples - Learn how to build A2A HTTP servers</li> <li>Examples Index - Return to examples overview</li> </ul>"},{"location":"examples/basic/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>All models are immutable - create new instances for updates</li> <li>Use <code>to_h</code> and <code>to_json</code> for serialization</li> <li>Use <code>from_hash</code> for deserialization</li> <li>Validate input early and provide helpful error messages</li> <li>Use <code>debug_me</code> gem for debugging instead of <code>puts</code></li> <li>Test each model and method in isolation</li> <li>Always use unique task IDs (SecureRandom.uuid)</li> <li>Add metadata for tracking and debugging</li> </ul> <p>Back to Examples Index | Back to Documentation Home</p>"},{"location":"examples/client/","title":"Building A2A HTTP Clients","text":"<p>This guide provides complete, production-ready examples for building A2A HTTP clients that can consume A2A-compatible agent services.</p>"},{"location":"examples/client/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Client Architecture</li> <li>Simple HTTP Client with Faraday</li> <li>Complete Production Client</li> <li>Net::HTTP Implementation</li> <li>Streaming with Server-Sent Events</li> <li>Error Handling and Retries</li> <li>Push Notifications</li> <li>Authentication</li> <li>Complete Working Examples</li> <li>Testing Clients</li> <li>Best Practices</li> </ul>"},{"location":"examples/client/#overview","title":"Overview","text":"<p>An A2A client is responsible for:</p> <ol> <li>Discovering agents via AgentCard (/.well-known/agent.json)</li> <li>Sending tasks to agents with messages</li> <li>Receiving responses synchronously or via streaming</li> <li>Polling for task status when needed</li> <li>Canceling tasks that are no longer needed</li> <li>Handling errors gracefully with retries</li> <li>Managing authentication when required</li> </ol>"},{"location":"examples/client/#key-responsibilities","title":"Key Responsibilities","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           A2A HTTP Client                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                \u2502\n\u2502  1. discover()                                 \u2502\n\u2502     \u2514\u2500&gt; GET /.well-known/agent.json          \u2502\n\u2502                                                \u2502\n\u2502  2. send_task(task_id, message)               \u2502\n\u2502     \u2514\u2500&gt; POST /a2a [tasks/send]                \u2502\n\u2502                                                \u2502\n\u2502  3. send_task_streaming(task_id, message)     \u2502\n\u2502     \u2514\u2500&gt; POST /a2a [tasks/sendSubscribe]       \u2502\n\u2502         \u2514\u2500&gt; Listen to SSE stream              \u2502\n\u2502                                                \u2502\n\u2502  4. get_task(task_id)                         \u2502\n\u2502     \u2514\u2500&gt; POST /a2a [tasks/get]                 \u2502\n\u2502                                                \u2502\n\u2502  5. cancel_task(task_id)                      \u2502\n\u2502     \u2514\u2500&gt; POST /a2a [tasks/cancel]              \u2502\n\u2502                                                \u2502\n\u2502  6. set_push_notification(task_id, config)    \u2502\n\u2502     \u2514\u2500&gt; POST /a2a [tasks/pushNotification/set]\u2502\n\u2502                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/client/#client-architecture","title":"Client Architecture","text":"<p>The A2A gem provides <code>A2A::Client::Base</code> as a foundation for building clients. You subclass it and implement the HTTP transport layer.</p>"},{"location":"examples/client/#base-class-methods","title":"Base Class Methods","text":"<pre><code>class A2A::Client::Base\n  # Initialize with agent URL\n  def initialize(agent_url)\n\n  # Discover agent capabilities\n  def discover() # =&gt; A2A::Models::AgentCard\n\n  # Send task synchronously\n  def send_task(task_id:, message:, session_id: nil) # =&gt; A2A::Models::Task\n\n  # Send task with streaming\n  def send_task_streaming(task_id:, message:, session_id: nil, &amp;block)\n\n  # Get task status\n  def get_task(task_id:) # =&gt; A2A::Models::Task\n\n  # Cancel a task\n  def cancel_task(task_id:) # =&gt; A2A::Models::Task\n\n  # Configure push notifications\n  def set_push_notification(task_id:, config:)\n\n  # Get push notification config\n  def get_push_notification(task_id:) # =&gt; A2A::Models::PushNotificationConfig\nend\n</code></pre>"},{"location":"examples/client/#simple-http-client-with-faraday","title":"Simple HTTP Client with Faraday","text":"<p>Let's start with a simple client implementation using Faraday.</p>"},{"location":"examples/client/#example-1-basic-faraday-client","title":"Example 1: Basic Faraday Client","text":"<pre><code>require 'a2a'\nrequire 'faraday'\nrequire 'json'\nrequire 'securerandom'\nrequire 'debug_me'\n\nclass SimpleA2AClient &lt; A2A::Client::Base\n  def initialize(agent_url, timeout: 30)\n    super(agent_url)\n    @timeout = timeout\n    @conn = build_connection\n  end\n\n  def discover\n    debug_me \"Discovering agent at #{agent_url}\"\n\n    response = @conn.get('/.well-known/agent.json')\n\n    unless response.success?\n      raise A2A::InternalError.new(\n        data: { reason: \"Failed to fetch AgentCard\", status: response.status }\n      )\n    end\n\n    agent_data = JSON.parse(response.body, symbolize_names: true)\n    @agent_card = A2A::Models::AgentCard.from_hash(agent_data)\n\n    debug_me \"Discovered agent: #{@agent_card.name} v#{@agent_card.version}\"\n    @agent_card\n\n  rescue Faraday::Error =&gt; e\n    debug_me \"Network error during discovery: #{e.message}\"\n    raise A2A::InternalError.new(data: { reason: e.message })\n  end\n\n  def send_task(task_id:, message:, session_id: nil)\n    debug_me \"Sending task #{task_id}\"\n\n    request = build_json_rpc_request(\n      method: \"tasks/send\",\n      params: {\n        taskId: task_id,\n        message: message.to_h,\n        sessionId: session_id\n      }.compact\n    )\n\n    response = post_json_rpc(request)\n    task = A2A::Models::Task.from_hash(response.result)\n\n    debug_me \"Task submitted: #{task.state}\"\n    task\n  end\n\n  def get_task(task_id:)\n    debug_me \"Getting task #{task_id}\"\n\n    request = build_json_rpc_request(\n      method: \"tasks/get\",\n      params: { taskId: task_id }\n    )\n\n    response = post_json_rpc(request)\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def cancel_task(task_id:)\n    debug_me \"Canceling task #{task_id}\"\n\n    request = build_json_rpc_request(\n      method: \"tasks/cancel\",\n      params: { taskId: task_id }\n    )\n\n    response = post_json_rpc(request)\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  private\n\n  def build_connection\n    Faraday.new(url: agent_url) do |f|\n      f.request :json\n      f.response :json, content_type: /\\bjson$/\n      f.adapter Faraday.default_adapter\n      f.options.timeout = @timeout\n    end\n  end\n\n  def build_json_rpc_request(method:, params:)\n    A2A::Protocol::Request.new(\n      method: method,\n      params: params,\n      id: SecureRandom.uuid\n    )\n  end\n\n  def post_json_rpc(request)\n    debug_me \"Sending JSON-RPC request: #{request.method}\"\n\n    response = @conn.post('/a2a') do |req|\n      req.headers['Content-Type'] = 'application/json'\n      req.body = request.to_json\n    end\n\n    unless response.success?\n      raise A2A::InternalError.new(\n        data: { reason: \"HTTP error\", status: response.status }\n      )\n    end\n\n    rpc_response = parse_json_rpc_response(response.body)\n\n    unless rpc_response.success?\n      handle_json_rpc_error(rpc_response.error)\n    end\n\n    rpc_response\n\n  rescue Faraday::Error =&gt; e\n    debug_me \"Network error: #{e.message}\"\n    raise A2A::InternalError.new(data: { reason: e.message })\n  end\n\n  def parse_json_rpc_response(body)\n    data = JSON.parse(body, symbolize_names: true)\n    A2A::Protocol::Response.from_hash(data)\n  rescue JSON::ParserError =&gt; e\n    raise A2A::JSONParseError.new(data: { reason: e.message })\n  end\n\n  def handle_json_rpc_error(error)\n    code = error[:code]\n    message = error[:message]\n    data = error[:data]\n\n    case code\n    when -32001 then raise A2A::TaskNotFoundError\n    when -32002 then raise A2A::TaskNotCancelableError\n    when -32003 then raise A2A::PushNotificationNotSupportedError\n    when -32004 then raise A2A::UnsupportedOperationError\n    when -32600 then raise A2A::InvalidRequestError.new(data: data)\n    when -32601 then raise A2A::MethodNotFoundError.new(data: data)\n    when -32602 then raise A2A::InvalidParamsError.new(data: data)\n    when -32603 then raise A2A::InternalError.new(data: data)\n    when -32700 then raise A2A::JSONParseError.new(data: data)\n    else\n      raise A2A::JSONRPCError.new(message, code: code, data: data)\n    end\n  end\nend\n</code></pre>"},{"location":"examples/client/#example-2-using-the-simple-client","title":"Example 2: Using the Simple Client","text":"<pre><code>require_relative 'simple_a2a_client'\n\n# Create client\nclient = SimpleA2AClient.new('https://api.example.com')\n\n# Discover agent\nagent = client.discover\nputs \"Connected to: #{agent.name}\"\nputs \"Capabilities: streaming=#{agent.capabilities.streaming?}\"\n\n# Send a task\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Translate 'Hello' to Spanish\"\n)\n\ntask = client.send_task(\n  task_id: SecureRandom.uuid,\n  message: message\n)\n\nputs \"Task submitted: #{task.id}\"\nputs \"State: #{task.state}\"\n\n# Poll for completion\nuntil task.state.terminal?\n  sleep 1\n  task = client.get_task(task_id: task.id)\n  puts \"State: #{task.state}\"\nend\n\n# Get results\nif task.state.completed?\n  puts \"Result: #{task.artifacts.first.parts.first.text}\"\nelse\n  puts \"Task failed: #{task.status.message&amp;.parts&amp;.first&amp;.text}\"\nend\n</code></pre>"},{"location":"examples/client/#complete-production-client","title":"Complete Production Client","text":"<p>A production-ready client with connection pooling, retries, and comprehensive error handling.</p>"},{"location":"examples/client/#example-3-production-client-implementation","title":"Example 3: Production Client Implementation","text":"<pre><code>require 'a2a'\nrequire 'faraday'\nrequire 'faraday/retry'\nrequire 'json'\nrequire 'securerandom'\nrequire 'debug_me'\n\nclass ProductionA2AClient &lt; A2A::Client::Base\n  attr_reader :conn\n\n  DEFAULT_TIMEOUT = 30\n  DEFAULT_OPEN_TIMEOUT = 10\n  DEFAULT_MAX_RETRIES = 3\n  DEFAULT_RETRY_INTERVAL = 0.5\n\n  def initialize(\n    agent_url,\n    timeout: DEFAULT_TIMEOUT,\n    open_timeout: DEFAULT_OPEN_TIMEOUT,\n    max_retries: DEFAULT_MAX_RETRIES,\n    retry_interval: DEFAULT_RETRY_INTERVAL,\n    headers: {}\n  )\n    super(agent_url)\n\n    @timeout = timeout\n    @open_timeout = open_timeout\n    @max_retries = max_retries\n    @retry_interval = retry_interval\n    @custom_headers = headers\n    @conn = build_connection\n  end\n\n  def discover\n    debug_me \"Discovering agent at #{agent_url}\"\n\n    response = with_error_handling do\n      @conn.get('/.well-known/agent.json')\n    end\n\n    agent_data = JSON.parse(response.body, symbolize_names: true)\n    @agent_card = A2A::Models::AgentCard.from_hash(agent_data)\n\n    debug_me \"Discovered: #{@agent_card.name} v#{@agent_card.version}\"\n    debug_me \"Skills: #{@agent_card.skills.map(&amp;:name).join(', ')}\"\n\n    @agent_card\n  end\n\n  def send_task(task_id:, message:, session_id: nil)\n    debug_me { [:task_id, :session_id] }\n\n    validate_message(message)\n\n    request = build_request(\n      \"tasks/send\",\n      taskId: task_id,\n      message: message.to_h,\n      sessionId: session_id\n    )\n\n    response = execute_request(request)\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def send_task_streaming(task_id:, message:, session_id: nil, &amp;block)\n    raise NotImplementedError, \"Streaming will be implemented in Example 7\"\n  end\n\n  def get_task(task_id:)\n    debug_me \"Getting task: #{task_id}\"\n\n    request = build_request(\"tasks/get\", taskId: task_id)\n    response = execute_request(request)\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def cancel_task(task_id:)\n    debug_me \"Canceling task: #{task_id}\"\n\n    request = build_request(\"tasks/cancel\", taskId: task_id)\n    response = execute_request(request)\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def set_push_notification(task_id:, config:)\n    debug_me \"Setting push notification for task: #{task_id}\"\n\n    request = build_request(\n      \"tasks/pushNotification/set\",\n      taskId: task_id,\n      pushNotificationConfig: config.to_h\n    )\n\n    execute_request(request)\n    nil\n  end\n\n  def get_push_notification(task_id:)\n    debug_me \"Getting push notification config for task: #{task_id}\"\n\n    request = build_request(\"tasks/pushNotification/get\", taskId: task_id)\n    response = execute_request(request)\n    A2A::Models::PushNotificationConfig.from_hash(response.result)\n  end\n\n  # Helper method for polling with exponential backoff\n  def wait_for_task(task_id:, max_wait: 60, initial_interval: 1, max_interval: 10)\n    debug_me \"Waiting for task #{task_id} to complete\"\n\n    start_time = Time.now\n    interval = initial_interval\n    task = nil\n\n    loop do\n      task = get_task(task_id: task_id)\n\n      if task.state.terminal?\n        debug_me \"Task completed in state: #{task.state}\"\n        return task\n      end\n\n      elapsed = Time.now - start_time\n      if elapsed &gt;= max_wait\n        debug_me \"Task timeout after #{elapsed}s\"\n        raise A2A::InternalError.new(\n          data: { reason: \"Task timeout\", elapsed: elapsed }\n        )\n      end\n\n      debug_me \"Task state: #{task.state}, waiting #{interval}s\"\n      sleep interval\n\n      # Exponential backoff\n      interval = [interval * 1.5, max_interval].min\n    end\n\n    task\n  end\n\n  private\n\n  def build_connection\n    Faraday.new(url: agent_url) do |f|\n      # Request/Response middleware\n      f.request :json\n\n      # Retry configuration\n      f.request :retry,\n                max: @max_retries,\n                interval: @retry_interval,\n                interval_randomness: 0.5,\n                backoff_factor: 2,\n                retry_statuses: [429, 500, 502, 503, 504],\n                methods: [:get, :post],\n                retry_block: lambda { |env, opts, retries, exc|\n                  debug_me \"Retry #{retries}/#{opts[:max]}: #{exc&amp;.class}\"\n                }\n\n      # Response middleware\n      f.response :json, content_type: /\\bjson$/\n      f.response :raise_error\n\n      # Adapter\n      f.adapter Faraday.default_adapter\n\n      # Timeouts\n      f.options.timeout = @timeout\n      f.options.open_timeout = @open_timeout\n    end\n  end\n\n  def build_request(method, params)\n    A2A::Protocol::Request.new(\n      method: method,\n      params: params.compact,\n      id: SecureRandom.uuid\n    )\n  end\n\n  def execute_request(request)\n    debug_me \"Executing: #{request.method}\"\n\n    response = with_error_handling do\n      @conn.post('/a2a') do |req|\n        req.headers['Content-Type'] = 'application/json'\n        req.headers.merge!(@custom_headers)\n        req.body = request.to_json\n      end\n    end\n\n    parse_response(response)\n  end\n\n  def with_error_handling\n    yield\n  rescue Faraday::TimeoutError =&gt; e\n    debug_me \"Timeout error: #{e.message}\"\n    raise A2A::InternalError.new(data: { reason: \"Request timeout\" })\n  rescue Faraday::ConnectionFailed =&gt; e\n    debug_me \"Connection failed: #{e.message}\"\n    raise A2A::InternalError.new(data: { reason: \"Connection failed\" })\n  rescue Faraday::Error =&gt; e\n    debug_me \"Network error: #{e.message}\"\n    raise A2A::InternalError.new(data: { reason: e.message })\n  end\n\n  def parse_response(http_response)\n    unless http_response.success?\n      raise A2A::InternalError.new(\n        data: { status: http_response.status, body: http_response.body }\n      )\n    end\n\n    begin\n      data = JSON.parse(http_response.body, symbolize_names: true)\n      rpc_response = A2A::Protocol::Response.from_hash(data)\n    rescue JSON::ParserError =&gt; e\n      raise A2A::JSONParseError.new(data: { reason: e.message })\n    end\n\n    if rpc_response.success?\n      rpc_response\n    else\n      handle_error(rpc_response.error)\n    end\n  end\n\n  def handle_error(error)\n    code = error[:code]\n    message = error[:message]\n    data = error[:data]\n\n    debug_me \"JSON-RPC error #{code}: #{message}\"\n\n    case code\n    when -32001 then raise A2A::TaskNotFoundError\n    when -32002 then raise A2A::TaskNotCancelableError\n    when -32003 then raise A2A::PushNotificationNotSupportedError\n    when -32004 then raise A2A::UnsupportedOperationError\n    when -32600 then raise A2A::InvalidRequestError.new(data: data)\n    when -32601 then raise A2A::MethodNotFoundError.new(data: data)\n    when -32602 then raise A2A::InvalidParamsError.new(data: data)\n    when -32603 then raise A2A::InternalError.new(data: data)\n    when -32700 then raise A2A::JSONParseError.new(data: data)\n    else\n      raise A2A::JSONRPCError.new(message, code: code, data: data)\n    end\n  end\n\n  def validate_message(message)\n    unless message.is_a?(A2A::Models::Message)\n      raise ArgumentError, \"message must be an A2A::Models::Message\"\n    end\n\n    unless message.parts.any?\n      raise ArgumentError, \"message must have at least one part\"\n    end\n  end\nend\n</code></pre>"},{"location":"examples/client/#example-4-using-the-production-client","title":"Example 4: Using the Production Client","text":"<pre><code>require_relative 'production_a2a_client'\n\n# Create client with custom configuration\nclient = ProductionA2AClient.new(\n  'https://api.example.com',\n  timeout: 60,\n  max_retries: 5,\n  headers: {\n    'Authorization' =&gt; 'Bearer your-api-key',\n    'X-Client-Version' =&gt; '1.0.0'\n  }\n)\n\nbegin\n  # Discover agent\n  agent = client.discover\n\n  # Send task\n  message = A2A::Models::Message.text(\n    role: \"user\",\n    text: \"Translate 'Hello, world!' to French\"\n  )\n\n  task = client.send_task(\n    task_id: SecureRandom.uuid,\n    message: message\n  )\n\n  # Wait for completion with exponential backoff\n  completed_task = client.wait_for_task(\n    task_id: task.id,\n    max_wait: 120\n  )\n\n  # Handle results\n  if completed_task.state.completed?\n    puts \"Success!\"\n    completed_task.artifacts.each do |artifact|\n      puts \"Artifact: #{artifact.name}\"\n      artifact.parts.each do |part|\n        case part\n        when A2A::Models::TextPart\n          puts \"  Text: #{part.text}\"\n        when A2A::Models::DataPart\n          puts \"  Data: #{part.data.inspect}\"\n        end\n      end\n    end\n  else\n    puts \"Task failed: #{completed_task.state}\"\n  end\n\nrescue A2A::TaskNotFoundError\n  puts \"Task not found\"\nrescue A2A::InternalError =&gt; e\n  puts \"Internal error: #{e.message}\"\n  puts \"Data: #{e.data}\"\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Protocol error #{e.code}: #{e.message}\"\nend\n</code></pre>"},{"location":"examples/client/#nethttp-implementation","title":"Net::HTTP Implementation","text":"<p>For environments without external dependencies, here's a pure Ruby implementation using Net::HTTP.</p>"},{"location":"examples/client/#example-5-nethttp-client","title":"Example 5: Net::HTTP Client","text":"<pre><code>require 'a2a'\nrequire 'net/http'\nrequire 'json'\nrequire 'uri'\nrequire 'securerandom'\nrequire 'debug_me'\n\nclass NetHTTPClient &lt; A2A::Client::Base\n  def initialize(agent_url, timeout: 30)\n    super(agent_url)\n    @timeout = timeout\n    @uri = URI.parse(agent_url)\n  end\n\n  def discover\n    debug_me \"Discovering agent at #{agent_url}\"\n\n    uri = URI.join(@uri, '/.well-known/agent.json')\n    response = http_get(uri)\n\n    agent_data = JSON.parse(response.body, symbolize_names: true)\n    @agent_card = A2A::Models::AgentCard.from_hash(agent_data)\n\n    debug_me \"Discovered: #{@agent_card.name}\"\n    @agent_card\n  end\n\n  def send_task(task_id:, message:, session_id: nil)\n    request = build_request(\n      \"tasks/send\",\n      taskId: task_id,\n      message: message.to_h,\n      sessionId: session_id\n    )\n\n    response = execute_json_rpc(request)\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def get_task(task_id:)\n    request = build_request(\"tasks/get\", taskId: task_id)\n    response = execute_json_rpc(request)\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  def cancel_task(task_id:)\n    request = build_request(\"tasks/cancel\", taskId: task_id)\n    response = execute_json_rpc(request)\n    A2A::Models::Task.from_hash(response.result)\n  end\n\n  private\n\n  def http_get(uri)\n    Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https', open_timeout: 10, read_timeout: @timeout) do |http|\n      request = Net::HTTP::Get.new(uri.request_uri)\n      request['Accept'] = 'application/json'\n\n      http.request(request)\n    end\n  rescue =&gt; e\n    debug_me \"HTTP GET error: #{e.message}\"\n    raise A2A::InternalError.new(data: { reason: e.message })\n  end\n\n  def http_post(uri, body)\n    Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https', open_timeout: 10, read_timeout: @timeout) do |http|\n      request = Net::HTTP::Post.new(uri.request_uri)\n      request['Content-Type'] = 'application/json'\n      request['Accept'] = 'application/json'\n      request.body = body\n\n      http.request(request)\n    end\n  rescue =&gt; e\n    debug_me \"HTTP POST error: #{e.message}\"\n    raise A2A::InternalError.new(data: { reason: e.message })\n  end\n\n  def build_request(method, params)\n    A2A::Protocol::Request.new(\n      method: method,\n      params: params.compact,\n      id: SecureRandom.uuid\n    )\n  end\n\n  def execute_json_rpc(request)\n    uri = URI.join(@uri, '/a2a')\n    response = http_post(uri, request.to_json)\n\n    unless response.is_a?(Net::HTTPSuccess)\n      raise A2A::InternalError.new(\n        data: { status: response.code, message: response.message }\n      )\n    end\n\n    begin\n      data = JSON.parse(response.body, symbolize_names: true)\n      rpc_response = A2A::Protocol::Response.from_hash(data)\n    rescue JSON::ParserError =&gt; e\n      raise A2A::JSONParseError.new(data: { reason: e.message })\n    end\n\n    if rpc_response.success?\n      rpc_response\n    else\n      handle_error(rpc_response.error)\n    end\n  end\n\n  def handle_error(error)\n    code = error[:code]\n    message = error[:message]\n    data = error[:data]\n\n    case code\n    when -32001 then raise A2A::TaskNotFoundError\n    when -32002 then raise A2A::TaskNotCancelableError\n    when -32003 then raise A2A::PushNotificationNotSupportedError\n    when -32004 then raise A2A::UnsupportedOperationError\n    when -32602 then raise A2A::InvalidParamsError.new(data: data)\n    when -32603 then raise A2A::InternalError.new(data: data)\n    else\n      raise A2A::JSONRPCError.new(message, code: code, data: data)\n    end\n  end\nend\n</code></pre>"},{"location":"examples/client/#streaming-with-server-sent-events","title":"Streaming with Server-Sent Events","text":"<p>Implementing real-time streaming for long-running tasks.</p>"},{"location":"examples/client/#example-6-sse-streaming-client","title":"Example 6: SSE Streaming Client","text":"<pre><code>require 'a2a'\nrequire 'faraday'\nrequire 'json'\nrequire 'securerandom'\nrequire 'debug_me'\n\nclass StreamingA2AClient &lt; ProductionA2AClient\n  def send_task_streaming(task_id:, message:, session_id: nil, &amp;block)\n    debug_me \"Sending streaming task: #{task_id}\"\n\n    request = build_request(\n      \"tasks/sendSubscribe\",\n      taskId: task_id,\n      message: message.to_h,\n      sessionId: session_id\n    )\n\n    # Send initial request\n    response = execute_request(request)\n    initial_task = A2A::Models::Task.from_hash(response.result)\n\n    # Connect to SSE stream\n    stream_url = \"#{agent_url}/a2a/stream/#{task_id}\"\n    listen_to_stream(stream_url, &amp;block)\n\n    initial_task\n  end\n\n  def resubscribe(task_id:, &amp;block)\n    debug_me \"Resubscribing to task: #{task_id}\"\n\n    request = build_request(\"tasks/resubscribe\", taskId: task_id)\n    execute_request(request)\n\n    stream_url = \"#{agent_url}/a2a/stream/#{task_id}\"\n    listen_to_stream(stream_url, &amp;block)\n  end\n\n  private\n\n  def listen_to_stream(url, &amp;block)\n    debug_me \"Connecting to SSE stream: #{url}\"\n\n    uri = URI.parse(url)\n    buffer = \"\"\n\n    Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https', read_timeout: nil) do |http|\n      request = Net::HTTP::Get.new(uri.request_uri)\n      request['Accept'] = 'text/event-stream'\n      request['Cache-Control'] = 'no-cache'\n\n      http.request(request) do |response|\n        unless response.is_a?(Net::HTTPSuccess)\n          raise A2A::InternalError.new(\n            data: { status: response.code, message: \"Stream connection failed\" }\n          )\n        end\n\n        response.read_body do |chunk|\n          buffer += chunk\n\n          # Process complete events\n          while buffer.include?(\"\\n\\n\")\n            event, buffer = buffer.split(\"\\n\\n\", 2)\n            process_sse_event(event, &amp;block)\n          end\n        end\n      end\n    end\n\n  rescue =&gt; e\n    debug_me \"Stream error: #{e.message}\"\n    raise A2A::InternalError.new(data: { reason: e.message })\n  end\n\n  def process_sse_event(event_text, &amp;block)\n    lines = event_text.split(\"\\n\")\n    event_type = nil\n    event_data = nil\n\n    lines.each do |line|\n      if line.start_with?('event:')\n        event_type = line.sub('event:', '').strip\n      elsif line.start_with?('data:')\n        event_data = line.sub('data:', '').strip\n      elsif line.start_with?(':')\n        # Comment, ignore\n      end\n    end\n\n    return unless event_data\n\n    begin\n      data = JSON.parse(event_data, symbolize_names: true)\n\n      case event_type\n      when 'taskStatus'\n        task = A2A::Models::Task.from_hash(data[:task] || data)\n        block.call(:status, task)\n\n      when 'artifactUpdate'\n        artifact = A2A::Models::Artifact.from_hash(data[:artifact] || data)\n        block.call(:artifact, artifact)\n\n      when 'taskComplete'\n        task = A2A::Models::Task.from_hash(data[:task] || data)\n        block.call(:complete, task)\n\n      when 'error'\n        error = data[:error]\n        block.call(:error, error)\n\n      else\n        debug_me \"Unknown event type: #{event_type}\"\n      end\n\n    rescue JSON::ParserError =&gt; e\n      debug_me \"Failed to parse event data: #{e.message}\"\n    end\n  end\nend\n</code></pre>"},{"location":"examples/client/#example-7-using-streaming-client","title":"Example 7: Using Streaming Client","text":"<pre><code>require_relative 'streaming_a2a_client'\n\nclient = StreamingA2AClient.new('https://api.example.com')\n\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Generate a long essay about AI\"\n)\n\ntask_id = SecureRandom.uuid\nartifacts = []\n\nbegin\n  client.send_task_streaming(\n    task_id: task_id,\n    message: message\n  ) do |event_type, data|\n    case event_type\n    when :status\n      puts \"Status update: #{data.state}\"\n\n    when :artifact\n      puts \"Artifact chunk: #{data.name}\"\n      artifacts &lt;&lt; data\n\n      # Display streaming text\n      data.parts.each do |part|\n        print part.text if part.is_a?(A2A::Models::TextPart)\n      end\n\n    when :complete\n      puts \"\\nTask completed!\"\n      puts \"Final state: #{data.state}\"\n\n      if data.artifacts\n        puts \"Final artifacts: #{data.artifacts.length}\"\n      end\n\n    when :error\n      puts \"Error: #{data[:message]}\"\n    end\n  end\n\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Error: #{e.message} (code: #{e.code})\"\nend\n</code></pre>"},{"location":"examples/client/#error-handling-and-retries","title":"Error Handling and Retries","text":""},{"location":"examples/client/#example-8-retry-logic-with-exponential-backoff","title":"Example 8: Retry Logic with Exponential Backoff","text":"<pre><code>require 'a2a'\nrequire 'debug_me'\n\nmodule A2AClientHelpers\n  def with_retry(max_retries: 3, initial_wait: 1, max_wait: 30)\n    retries = 0\n    wait_time = initial_wait\n\n    begin\n      yield\n\n    rescue A2A::InternalError, A2A::JSONRPCError =&gt; e\n      retries += 1\n\n      if retries &lt;= max_retries\n        debug_me \"Retry #{retries}/#{max_retries} after #{wait_time}s (error: #{e.class})\"\n        sleep wait_time\n\n        wait_time = [wait_time * 2, max_wait].min\n        retry\n      else\n        debug_me \"Max retries exceeded\"\n        raise\n      end\n    end\n  end\n\n  def safe_execute(operation_name)\n    debug_me \"Executing: #{operation_name}\"\n\n    with_retry do\n      yield\n    end\n\n  rescue A2A::TaskNotFoundError\n    debug_me \"Task not found during: #{operation_name}\"\n    nil\n\n  rescue A2A::JSONRPCError =&gt; e\n    debug_me \"Error during #{operation_name}: #{e.code} - #{e.message}\"\n    raise\n\n  rescue StandardError =&gt; e\n    debug_me \"Unexpected error during #{operation_name}: #{e.class}\"\n    raise A2A::InternalError.new(data: { reason: e.message, backtrace: e.backtrace.first(5) })\n  end\nend\n\nclass RobustA2AClient &lt; ProductionA2AClient\n  include A2AClientHelpers\n\n  def send_task(task_id:, message:, session_id: nil)\n    safe_execute(\"send_task #{task_id}\") do\n      super\n    end\n  end\n\n  def get_task(task_id:)\n    safe_execute(\"get_task #{task_id}\") do\n      super\n    end\n  end\nend\n</code></pre>"},{"location":"examples/client/#push-notifications","title":"Push Notifications","text":""},{"location":"examples/client/#example-9-configuring-push-notifications","title":"Example 9: Configuring Push Notifications","text":"<pre><code>require_relative 'production_a2a_client'\n\nclient = ProductionA2AClient.new('https://api.example.com')\n\n# Send task\nmessage = A2A::Models::Message.text(role: \"user\", text: \"Long running task\")\ntask_id = SecureRandom.uuid\ntask = client.send_task(task_id: task_id, message: message)\n\n# Configure push notification\nnotification_config = A2A::Models::PushNotificationConfig.new(\n  url: \"https://my-server.com/webhooks/a2a\",\n  token: \"webhook-secret-token\"\n)\n\nbegin\n  client.set_push_notification(\n    task_id: task_id,\n    config: notification_config\n  )\n\n  puts \"Push notifications configured for task #{task_id}\"\n\nrescue A2A::PushNotificationNotSupportedError\n  puts \"Agent doesn't support push notifications, falling back to polling\"\n\n  # Fall back to polling\n  loop do\n    task = client.get_task(task_id: task_id)\n    break if task.state.terminal?\n    sleep 5\n  end\nend\n</code></pre>"},{"location":"examples/client/#authentication","title":"Authentication","text":""},{"location":"examples/client/#example-10-client-with-bearer-token-authentication","title":"Example 10: Client with Bearer Token Authentication","text":"<pre><code>class AuthenticatedA2AClient &lt; ProductionA2AClient\n  def initialize(agent_url, api_key:, **options)\n    @api_key = api_key\n\n    super(\n      agent_url,\n      headers: { 'Authorization' =&gt; \"Bearer #{api_key}\" },\n      **options\n    )\n  end\n\n  def refresh_token(new_api_key)\n    @api_key = new_api_key\n    @custom_headers['Authorization'] = \"Bearer #{new_api_key}\"\n  end\nend\n\n# Usage\nclient = AuthenticatedA2AClient.new(\n  'https://api.example.com',\n  api_key: ENV['A2A_API_KEY']\n)\n\nagent = client.discover\nputs \"Authenticated as: #{agent.name}\"\n</code></pre>"},{"location":"examples/client/#complete-working-examples","title":"Complete Working Examples","text":""},{"location":"examples/client/#example-11-complete-cli-client","title":"Example 11: Complete CLI Client","text":"<pre><code>#!/usr/bin/env ruby\nrequire 'a2a'\nrequire 'securerandom'\nrequire 'optparse'\nrequire 'debug_me'\nrequire_relative 'production_a2a_client'\n\nclass A2ACLI\n  def initialize(agent_url)\n    @client = ProductionA2AClient.new(agent_url)\n    @agent = nil\n  end\n\n  def run(command, **options)\n    case command\n    when 'discover'\n      discover\n\n    when 'send'\n      send_task(options[:text], options[:session])\n\n    when 'get'\n      get_task(options[:task_id])\n\n    when 'wait'\n      wait_for_task(options[:task_id])\n\n    when 'cancel'\n      cancel_task(options[:task_id])\n\n    else\n      puts \"Unknown command: #{command}\"\n      exit 1\n    end\n  end\n\n  private\n\n  def discover\n    @agent = @client.discover\n\n    puts \"Agent: #{@agent.name}\"\n    puts \"Version: #{@agent.version}\"\n    puts \"URL: #{@agent.url}\"\n    puts \"\\nCapabilities:\"\n    puts \"  Streaming: #{@agent.capabilities.streaming?}\"\n    puts \"  Push Notifications: #{@agent.capabilities.push_notifications?}\"\n    puts \"\\nSkills:\"\n    @agent.skills.each do |skill|\n      puts \"  - #{skill.name}: #{skill.description}\"\n    end\n  end\n\n  def send_task(text, session_id = nil)\n    message = A2A::Models::Message.text(role: \"user\", text: text)\n    task_id = SecureRandom.uuid\n\n    task = @client.send_task(\n      task_id: task_id,\n      message: message,\n      session_id: session_id\n    )\n\n    puts \"Task ID: #{task.id}\"\n    puts \"State: #{task.state}\"\n    puts \"Session: #{task.session_id}\" if task.session_id\n  end\n\n  def get_task(task_id)\n    task = @client.get_task(task_id: task_id)\n\n    puts \"Task ID: #{task.id}\"\n    puts \"State: #{task.state}\"\n\n    if task.artifacts\n      puts \"\\nArtifacts:\"\n      task.artifacts.each do |artifact|\n        puts \"  #{artifact.name}:\"\n        artifact.parts.each do |part|\n          case part\n          when A2A::Models::TextPart\n            puts \"    #{part.text}\"\n          when A2A::Models::DataPart\n            puts \"    Data: #{part.data.inspect}\"\n          end\n        end\n      end\n    end\n  end\n\n  def wait_for_task(task_id)\n    puts \"Waiting for task #{task_id}...\"\n\n    task = @client.wait_for_task(task_id: task_id, max_wait: 300)\n\n    puts \"Task completed: #{task.state}\"\n    get_task(task_id)\n  end\n\n  def cancel_task(task_id)\n    task = @client.cancel_task(task_id: task_id)\n    puts \"Task #{task_id} canceled: #{task.state}\"\n  end\nend\n\n# Parse command line\noptions = {}\ncommand = ARGV.shift\n\nOptionParser.new do |opts|\n  opts.banner = \"Usage: a2a_cli.rb COMMAND [options]\"\n\n  opts.on(\"--url URL\", \"Agent URL\") { |v| options[:url] = v }\n  opts.on(\"--text TEXT\", \"Message text\") { |v| options[:text] = v }\n  opts.on(\"--task-id ID\", \"Task ID\") { |v| options[:task_id] = v }\n  opts.on(\"--session ID\", \"Session ID\") { |v| options[:session] = v }\nend.parse!\n\nagent_url = options[:url] || ENV['A2A_AGENT_URL'] || 'https://api.example.com'\n\ncli = A2ACLI.new(agent_url)\ncli.run(command, **options)\n</code></pre>"},{"location":"examples/client/#example-12-multi-turn-conversation-client","title":"Example 12: Multi-Turn Conversation Client","text":"<pre><code>require 'a2a'\nrequire 'securerandom'\nrequire_relative 'production_a2a_client'\n\nclass ConversationClient\n  attr_reader :session_id, :client, :history\n\n  def initialize(agent_url)\n    @client = ProductionA2AClient.new(agent_url)\n    @session_id = SecureRandom.uuid\n    @history = []\n  end\n\n  def send(text)\n    message = A2A::Models::Message.text(role: \"user\", text: text)\n    task_id = SecureRandom.uuid\n\n    # Send task in session\n    task = @client.send_task(\n      task_id: task_id,\n      message: message,\n      session_id: @session_id\n    )\n\n    # Wait for completion\n    completed = @client.wait_for_task(task_id: task.id)\n\n    # Store in history\n    @history &lt;&lt; { user: text, task: completed }\n\n    # Extract response text\n    extract_response(completed)\n  end\n\n  def print_history\n    @history.each_with_index do |turn, i|\n      puts \"\\n--- Turn #{i + 1} ---\"\n      puts \"User: #{turn[:user]}\"\n      puts \"Agent: #{extract_response(turn[:task])}\"\n    end\n  end\n\n  private\n\n  def extract_response(task)\n    return \"Task failed: #{task.state}\" unless task.state.completed?\n\n    texts = []\n    task.artifacts&amp;.each do |artifact|\n      artifact.parts.each do |part|\n        texts &lt;&lt; part.text if part.is_a?(A2A::Models::TextPart)\n      end\n    end\n\n    texts.join(\"\\n\")\n  end\nend\n\n# Usage\nconv = ConversationClient.new('https://api.example.com')\n\nputs \"User: Translate 'Hello' to Spanish\"\nputs \"Agent: #{conv.send(\"Translate 'Hello' to Spanish\")}\"\n\nputs \"\\nUser: Now to French\"\nputs \"Agent: #{conv.send(\"Now to French\")}\"\n\nputs \"\\nUser: And to German\"\nputs \"Agent: #{conv.send(\"And to German\")}\"\n\nconv.print_history\n</code></pre>"},{"location":"examples/client/#testing-clients","title":"Testing Clients","text":""},{"location":"examples/client/#example-13-unit-testing-clients","title":"Example 13: Unit Testing Clients","text":"<pre><code>require 'a2a'\nrequire 'minitest/autorun'\nrequire 'webmock/minitest'\n\nclass TestA2AClient &lt; Minitest::Test\n  def setup\n    @agent_url = 'https://test.example.com'\n    @client = ProductionA2AClient.new(@agent_url)\n\n    # Stub AgentCard\n    stub_request(:get, \"#{@agent_url}/.well-known/agent.json\")\n      .to_return(\n        status: 200,\n        body: agent_card_json,\n        headers: { 'Content-Type' =&gt; 'application/json' }\n      )\n  end\n\n  def test_discover\n    agent = @client.discover\n\n    assert_equal \"Test Agent\", agent.name\n    assert_equal \"1.0.0\", agent.version\n    assert agent.capabilities.streaming?\n  end\n\n  def test_send_task\n    task_id = \"task-123\"\n\n    stub_request(:post, \"#{@agent_url}/a2a\")\n      .with(body: hash_including(method: \"tasks/send\"))\n      .to_return(\n        status: 200,\n        body: task_response_json(task_id, \"completed\"),\n        headers: { 'Content-Type' =&gt; 'application/json' }\n      )\n\n    message = A2A::Models::Message.text(role: \"user\", text: \"Hello\")\n    task = @client.send_task(task_id: task_id, message: message)\n\n    assert_equal task_id, task.id\n    assert task.state.completed?\n  end\n\n  def test_task_not_found_error\n    stub_request(:post, \"#{@agent_url}/a2a\")\n      .to_return(\n        status: 200,\n        body: error_response_json(-32001, \"Task not found\"),\n        headers: { 'Content-Type' =&gt; 'application/json' }\n      )\n\n    assert_raises(A2A::TaskNotFoundError) do\n      @client.get_task(task_id: \"nonexistent\")\n    end\n  end\n\n  private\n\n  def agent_card_json\n    {\n      name: \"Test Agent\",\n      version: \"1.0.0\",\n      url: @agent_url,\n      capabilities: { streaming: true },\n      skills: [{ id: \"test\", name: \"Test\", description: \"Test skill\" }]\n    }.to_json\n  end\n\n  def task_response_json(task_id, state)\n    {\n      jsonrpc: \"2.0\",\n      id: \"1\",\n      result: {\n        id: task_id,\n        status: { state: state }\n      }\n    }.to_json\n  end\n\n  def error_response_json(code, message)\n    {\n      jsonrpc: \"2.0\",\n      id: \"1\",\n      error: { code: code, message: message }\n    }.to_json\n  end\nend\n</code></pre>"},{"location":"examples/client/#best-practices","title":"Best Practices","text":""},{"location":"examples/client/#1-always-discover-first","title":"1. Always Discover First","text":"<pre><code>client = ProductionA2AClient.new(agent_url)\nagent = client.discover\n\n# Check capabilities before using them\nif agent.capabilities.streaming?\n  client.send_task_streaming(...)\nelse\n  task = client.send_task(...)\n  client.wait_for_task(task_id: task.id)\nend\n</code></pre>"},{"location":"examples/client/#2-use-unique-task-ids","title":"2. Use Unique Task IDs","text":"<pre><code># Always generate unique IDs\ntask_id = SecureRandom.uuid\n\n# Or include timestamp for debugging\ntask_id = \"task-#{Time.now.to_i}-#{SecureRandom.hex(4)}\"\n</code></pre>"},{"location":"examples/client/#3-implement-proper-timeouts","title":"3. Implement Proper Timeouts","text":"<pre><code>client = ProductionA2AClient.new(\n  agent_url,\n  timeout: 60,           # Read timeout\n  open_timeout: 10       # Connection timeout\n)\n</code></pre>"},{"location":"examples/client/#4-handle-all-error-cases","title":"4. Handle All Error Cases","text":"<pre><code>begin\n  task = client.send_task(...)\nrescue A2A::TaskNotFoundError\n  # Specific handling\nrescue A2A::InvalidParamsError =&gt; e\n  # Log validation errors\n  puts \"Invalid params: #{e.data}\"\nrescue A2A::JSONRPCError =&gt; e\n  # Generic RPC error\n  puts \"Error #{e.code}: #{e.message}\"\nrescue StandardError =&gt; e\n  # Unexpected errors\n  puts \"Unexpected: #{e.class}\"\nend\n</code></pre>"},{"location":"examples/client/#5-use-connection-pooling","title":"5. Use Connection Pooling","text":"<pre><code># Reuse client instance\n@client ||= ProductionA2AClient.new(agent_url)\n\n# Don't create new client for each request\n# BAD: ProductionA2AClient.new(url).send_task(...)\n# GOOD: @client.send_task(...)\n</code></pre>"},{"location":"examples/client/#6-log-everything","title":"6. Log Everything","text":"<pre><code>require 'debug_me'\n\ndebug_me { [:task_id, :session_id, :state] }\ndebug_me \"Sending task to #{agent_url}\"\n</code></pre>"},{"location":"examples/client/#summary","title":"Summary","text":"<p>This guide covered:</p> <ol> <li>Simple Clients - Basic Faraday implementation</li> <li>Production Clients - Full-featured with retries</li> <li>Net::HTTP - Pure Ruby implementation</li> <li>Streaming - SSE support for real-time updates</li> <li>Error Handling - Comprehensive error management</li> <li>Authentication - Bearer token support</li> <li>Testing - Unit testing with WebMock</li> <li>Best Practices - Production-ready patterns</li> </ol>"},{"location":"examples/client/#next-steps","title":"Next Steps","text":"<ul> <li>Server Examples - Build A2A servers</li> <li>Basic Examples - Review data models</li> <li>Examples Index - Return to overview</li> </ul> <p>Back to Examples Index | Back to Documentation Home</p>"},{"location":"examples/server/","title":"Building A2A HTTP Servers","text":"<p>This guide provides complete, production-ready examples for building A2A HTTP servers that expose agent services via the A2A protocol.</p>"},{"location":"examples/server/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Server Architecture</li> <li>Simple Sinatra Server</li> <li>Complete Production Server</li> <li>Task Storage and Management</li> <li>Streaming with SSE</li> <li>Background Job Processing</li> <li>Authentication and Authorization</li> <li>Complete Working Examples</li> <li>Testing Servers</li> <li>Production Deployment</li> <li>Best Practices</li> </ul>"},{"location":"examples/server/#overview","title":"Overview","text":"<p>An A2A server exposes an HTTP endpoint that implements the A2A protocol, allowing clients to:</p> <ol> <li>Discover the agent via AgentCard at <code>/.well-known/agent.json</code></li> <li>Submit tasks for processing</li> <li>Get task status and results</li> <li>Cancel tasks that are no longer needed</li> <li>Stream updates via Server-Sent Events (SSE)</li> <li>Receive push notification configs for webhook-based updates</li> </ol>"},{"location":"examples/server/#key-responsibilities","title":"Key Responsibilities","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           A2A HTTP Server                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                \u2502\n\u2502  GET /.well-known/agent.json                  \u2502\n\u2502    \u2514\u2500&gt; Return AgentCard                       \u2502\n\u2502                                                \u2502\n\u2502  POST /a2a                                     \u2502\n\u2502    \u251c\u2500&gt; tasks/send                             \u2502\n\u2502    \u2502   \u2514\u2500&gt; Create and process task            \u2502\n\u2502    \u251c\u2500&gt; tasks/sendSubscribe                    \u2502\n\u2502    \u2502   \u2514\u2500&gt; Create task and stream updates     \u2502\n\u2502    \u251c\u2500&gt; tasks/get                              \u2502\n\u2502    \u2502   \u2514\u2500&gt; Return task status                 \u2502\n\u2502    \u251c\u2500&gt; tasks/cancel                           \u2502\n\u2502    \u2502   \u2514\u2500&gt; Cancel task                        \u2502\n\u2502    \u251c\u2500&gt; tasks/pushNotification/set             \u2502\n\u2502    \u2502   \u2514\u2500&gt; Configure push notifications       \u2502\n\u2502    \u2514\u2500&gt; tasks/pushNotification/get             \u2502\n\u2502        \u2514\u2500&gt; Get notification config            \u2502\n\u2502                                                \u2502\n\u2502  GET /a2a/stream/:task_id (optional)          \u2502\n\u2502    \u2514\u2500&gt; Stream task updates via SSE            \u2502\n\u2502                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/server/#server-architecture","title":"Server Architecture","text":"<p>The A2A gem provides <code>A2A::Server::Base</code> as a foundation. You subclass it and implement the HTTP server layer.</p>"},{"location":"examples/server/#base-class-methods","title":"Base Class Methods","text":"<pre><code>class A2A::Server::Base\n  # Initialize with AgentCard\n  def initialize(agent_card)\n\n  # Handle incoming JSON-RPC request\n  def handle_request(request) # =&gt; Hash\n\n  # Handle tasks/send\n  def handle_send_task(params) # =&gt; A2A::Models::Task\n\n  # Handle tasks/sendSubscribe (streaming)\n  def handle_send_task_streaming(params, &amp;block)\n\n  # Handle tasks/get\n  def handle_get_task(params) # =&gt; A2A::Models::Task\n\n  # Handle tasks/cancel\n  def handle_cancel_task(params) # =&gt; A2A::Models::Task\n\n  # Handle tasks/pushNotification/set\n  def handle_set_push_notification(params)\n\n  # Handle tasks/pushNotification/get\n  def handle_get_push_notification(params) # =&gt; A2A::Models::PushNotificationConfig\n\n  # Handle tasks/resubscribe\n  def handle_resubscribe(params, &amp;block)\nend\n</code></pre>"},{"location":"examples/server/#simple-sinatra-server","title":"Simple Sinatra Server","text":"<p>Let's start with a basic A2A server using Sinatra.</p>"},{"location":"examples/server/#example-1-basic-sinatra-server","title":"Example 1: Basic Sinatra Server","text":"<pre><code>require 'sinatra/base'\nrequire 'a2a'\nrequire 'json'\nrequire 'securerandom'\nrequire 'debug_me'\n\nclass SimpleA2AServer &lt; A2A::Server::Base\n  attr_reader :tasks\n\n  def initialize(agent_card)\n    super(agent_card)\n    @tasks = {}\n  end\n\n  def handle_request(request)\n    debug_me \"Handling request: #{request[:method]}\"\n\n    case request[:method]\n    when 'tasks/send'\n      task = handle_send_task(request[:params])\n      { result: task.to_h }\n\n    when 'tasks/get'\n      task = handle_get_task(request[:params])\n      { result: task.to_h }\n\n    when 'tasks/cancel'\n      task = handle_cancel_task(request[:params])\n      { result: task.to_h }\n\n    else\n      {\n        error: {\n          code: -32601,\n          message: \"Method not found: #{request[:method]}\"\n        }\n      }\n    end\n  end\n\n  def handle_send_task(params)\n    task_id = params[:taskId] || params['taskId']\n    message_data = params[:message] || params['message']\n\n    raise A2A::InvalidParamsError unless task_id &amp;&amp; message_data\n\n    message = A2A::Models::Message.from_hash(message_data)\n\n    # Process task immediately (simplified)\n    result_text = process_message(message)\n\n    task = A2A::Models::Task.new(\n      id: task_id,\n      session_id: params[:sessionId] || params['sessionId'],\n      status: { state: 'completed' },\n      artifacts: [\n        A2A::Models::Artifact.new(\n          name: 'Response',\n          parts: [A2A::Models::TextPart.new(text: result_text)]\n        )\n      ]\n    )\n\n    @tasks[task_id] = task\n    debug_me \"Task #{task_id} completed\"\n    task\n  end\n\n  def handle_get_task(params)\n    task_id = params[:taskId] || params['taskId']\n    task = @tasks[task_id]\n\n    raise A2A::TaskNotFoundError unless task\n\n    task\n  end\n\n  def handle_cancel_task(params)\n    task_id = params[:taskId] || params['taskId']\n    task = @tasks[task_id]\n\n    raise A2A::TaskNotFoundError unless task\n    raise A2A::TaskNotCancelableError if task.state.terminal?\n\n    canceled_task = A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: { state: 'canceled' }\n    )\n\n    @tasks[task_id] = canceled_task\n    canceled_task\n  end\n\n  private\n\n  def process_message(message)\n    # Simple echo processor\n    text = message.parts.first.text\n    \"Echo: #{text}\"\n  end\nend\n\n# Sinatra app\nclass A2AApp &lt; Sinatra::Base\n  def initialize\n    super\n\n    # Create agent card\n    agent_card = A2A::Models::AgentCard.new(\n      name: \"Simple Echo Agent\",\n      url: \"http://localhost:4567\",\n      version: \"1.0.0\",\n      capabilities: {\n        streaming: false,\n        push_notifications: false\n      },\n      skills: [\n        {\n          id: \"echo\",\n          name: \"Echo\",\n          description: \"Echoes back your message\"\n        }\n      ]\n    )\n\n    @server = SimpleA2AServer.new(agent_card)\n  end\n\n  # Serve AgentCard\n  get '/.well-known/agent.json' do\n    content_type :json\n    @server.agent_card.to_json\n  end\n\n  # Handle JSON-RPC requests\n  post '/a2a' do\n    content_type :json\n\n    begin\n      request_data = JSON.parse(request.body.read, symbolize_names: true)\n\n      response = @server.handle_request(request_data)\n\n      {\n        jsonrpc: '2.0',\n        id: request_data[:id],\n        **response\n      }.to_json\n\n    rescue A2A::JSONRPCError =&gt; e\n      {\n        jsonrpc: '2.0',\n        id: request_data&amp;.dig(:id),\n        error: {\n          code: e.code,\n          message: e.message,\n          data: e.data\n        }\n      }.to_json\n\n    rescue JSON::ParserError\n      {\n        jsonrpc: '2.0',\n        id: nil,\n        error: {\n          code: -32700,\n          message: 'Invalid JSON'\n        }\n      }.to_json\n    end\n  end\nend\n\n# Run the server\nif __FILE__ == $0\n  A2AApp.run! port: 4567\nend\n</code></pre>"},{"location":"examples/server/#complete-production-server","title":"Complete Production Server","text":"<p>A full-featured server with proper task management, background processing, and error handling.</p>"},{"location":"examples/server/#example-2-production-server-implementation","title":"Example 2: Production Server Implementation","text":"<pre><code>require 'sinatra/base'\nrequire 'a2a'\nrequire 'json'\nrequire 'securerandom'\nrequire 'thread'\nrequire 'debug_me'\n\nclass ProductionA2AServer &lt; A2A::Server::Base\n  attr_reader :tasks, :push_configs, :sessions\n\n  def initialize(agent_card, processor:)\n    super(agent_card)\n\n    @processor = processor\n    @tasks = Concurrent::Hash.new\n    @push_configs = Concurrent::Hash.new\n    @sessions = Concurrent::Hash.new\n    @task_queue = Queue.new\n    @streaming_clients = Concurrent::Hash.new\n\n    start_background_workers\n  end\n\n  def handle_request(request)\n    validate_request(request)\n\n    case request[:method]\n    when 'tasks/send'\n      task = handle_send_task(request[:params])\n      { result: task.to_h }\n\n    when 'tasks/sendSubscribe'\n      task = handle_send_task_streaming(request[:params])\n      { result: task.to_h }\n\n    when 'tasks/get'\n      task = handle_get_task(request[:params])\n      { result: task.to_h }\n\n    when 'tasks/cancel'\n      task = handle_cancel_task(request[:params])\n      { result: task.to_h }\n\n    when 'tasks/pushNotification/set'\n      handle_set_push_notification(request[:params])\n      { result: {} }\n\n    when 'tasks/pushNotification/get'\n      config = handle_get_push_notification(request[:params])\n      { result: config.to_h }\n\n    when 'tasks/resubscribe'\n      handle_resubscribe(request[:params])\n      { result: {} }\n\n    else\n      raise A2A::MethodNotFoundError\n    end\n\n  rescue A2A::JSONRPCError =&gt; e\n    {\n      error: {\n        code: e.code,\n        message: e.message,\n        data: e.data\n      }\n    }\n  end\n\n  def handle_send_task(params)\n    task_id, message, session_id = extract_task_params(params)\n\n    task = create_task(task_id, message, session_id, streaming: false)\n    @tasks[task_id] = task\n\n    # Queue for background processing\n    @task_queue &lt;&lt; task_id\n\n    debug_me \"Task #{task_id} queued\"\n    task\n  end\n\n  def handle_send_task_streaming(params)\n    task_id, message, session_id = extract_task_params(params)\n\n    task = create_task(task_id, message, session_id, streaming: true)\n    @tasks[task_id] = task\n\n    # Queue for background processing\n    @task_queue &lt;&lt; task_id\n\n    debug_me \"Streaming task #{task_id} queued\"\n    task\n  end\n\n  def handle_get_task(params)\n    task_id = params[:taskId] || params['taskId']\n    task = @tasks[task_id]\n\n    raise A2A::TaskNotFoundError unless task\n\n    task\n  end\n\n  def handle_cancel_task(params)\n    task_id = params[:taskId] || params['taskId']\n    task = @tasks[task_id]\n\n    raise A2A::TaskNotFoundError unless task\n    raise A2A::TaskNotCancelableError if task.state.terminal?\n\n    update_task_state(task_id, 'canceled')\n  end\n\n  def handle_set_push_notification(params)\n    unless agent_card.capabilities.push_notifications?\n      raise A2A::PushNotificationNotSupportedError\n    end\n\n    task_id = params[:taskId] || params['taskId']\n    config_data = params[:pushNotificationConfig] || params['pushNotificationConfig']\n\n    raise A2A::InvalidParamsError unless task_id &amp;&amp; config_data\n\n    config = A2A::Models::PushNotificationConfig.from_hash(config_data)\n    @push_configs[task_id] = config\n\n    debug_me \"Push notification configured for #{task_id}\"\n    nil\n  end\n\n  def handle_get_push_notification(params)\n    task_id = params[:taskId] || params['taskId']\n    config = @push_configs[task_id]\n\n    raise A2A::TaskNotFoundError unless config\n\n    config\n  end\n\n  def handle_resubscribe(params)\n    task_id = params[:taskId] || params['taskId']\n    task = @tasks[task_id]\n\n    raise A2A::TaskNotFoundError unless task\n\n    # Client will reconnect to SSE stream\n    nil\n  end\n\n  # Register SSE client for streaming\n  def register_stream(task_id, client)\n    @streaming_clients[task_id] ||= []\n    @streaming_clients[task_id] &lt;&lt; client\n  end\n\n  def unregister_stream(task_id, client)\n    @streaming_clients[task_id]&amp;.delete(client)\n  end\n\n  private\n\n  def validate_request(request)\n    raise A2A::InvalidRequestError unless request[:method]\n  end\n\n  def extract_task_params(params)\n    task_id = params[:taskId] || params['taskId']\n    message_data = params[:message] || params['message']\n    session_id = params[:sessionId] || params['sessionId']\n\n    raise A2A::InvalidParamsError.new(\n      data: { missing: ['taskId', 'message'] }\n    ) unless task_id &amp;&amp; message_data\n\n    message = A2A::Models::Message.from_hash(message_data)\n\n    [task_id, message, session_id]\n  end\n\n  def create_task(task_id, message, session_id, streaming:)\n    # Store session\n    if session_id\n      @sessions[session_id] ||= []\n      @sessions[session_id] &lt;&lt; task_id\n    end\n\n    A2A::Models::Task.new(\n      id: task_id,\n      session_id: session_id,\n      status: {\n        state: 'submitted',\n        message: message,\n        timestamp: Time.now.utc.iso8601\n      },\n      metadata: {\n        streaming: streaming,\n        created_at: Time.now.utc.iso8601\n      }\n    )\n  end\n\n  def update_task_state(task_id, new_state, message: nil, artifacts: nil)\n    task = @tasks[task_id]\n    return nil unless task\n\n    updated_task = A2A::Models::Task.new(\n      id: task.id,\n      session_id: task.session_id,\n      status: {\n        state: new_state,\n        message: message,\n        timestamp: Time.now.utc.iso8601\n      },\n      artifacts: artifacts || task.artifacts,\n      metadata: task.metadata\n    )\n\n    @tasks[task_id] = updated_task\n\n    # Notify streaming clients\n    notify_streaming_clients(task_id, updated_task)\n\n    # Send push notification if configured\n    send_push_notification(task_id, updated_task)\n\n    updated_task\n  end\n\n  def notify_streaming_clients(task_id, task)\n    clients = @streaming_clients[task_id] || []\n\n    clients.each do |client|\n      begin\n        client.send_event('taskStatus', task: task.to_h)\n      rescue =&gt; e\n        debug_me \"Failed to notify client: #{e.message}\"\n        unregister_stream(task_id, client)\n      end\n    end\n  end\n\n  def send_push_notification(task_id, task)\n    config = @push_configs[task_id]\n    return unless config &amp;&amp; task.state.terminal?\n\n    # Send webhook notification\n    Thread.new do\n      begin\n        require 'net/http'\n        uri = URI.parse(config.url)\n\n        http = Net::HTTP.new(uri.host, uri.port)\n        http.use_ssl = uri.scheme == 'https'\n\n        request = Net::HTTP::Post.new(uri.request_uri)\n        request['Content-Type'] = 'application/json'\n        request['Authorization'] = \"Bearer #{config.token}\" if config.token\n        request.body = { taskId: task_id, task: task.to_h }.to_json\n\n        response = http.request(request)\n        debug_me \"Push notification sent: #{response.code}\"\n\n      rescue =&gt; e\n        debug_me \"Push notification failed: #{e.message}\"\n      end\n    end\n  end\n\n  def start_background_workers\n    # Start worker threads to process tasks\n    @workers = Array.new(4) do\n      Thread.new { worker_loop }\n    end\n  end\n\n  def worker_loop\n    loop do\n      task_id = @task_queue.pop\n      process_task(task_id)\n    end\n  rescue =&gt; e\n    debug_me \"Worker error: #{e.message}\"\n    retry\n  end\n\n  def process_task(task_id)\n    task = @tasks[task_id]\n    return unless task\n\n    debug_me \"Processing task: #{task_id}\"\n\n    # Update to working state\n    update_task_state(task_id, 'working',\n      message: A2A::Models::Message.text(\n        role: 'agent',\n        text: 'Processing your request...'\n      )\n    )\n\n    begin\n      # Process with the configured processor\n      result = @processor.process(task)\n\n      # Update to completed with results\n      artifacts = [\n        A2A::Models::Artifact.new(\n          name: 'Response',\n          parts: result.is_a?(Array) ? result : [result]\n        )\n      ]\n\n      update_task_state(task_id, 'completed', artifacts: artifacts)\n\n    rescue StandardError =&gt; e\n      debug_me \"Task processing failed: #{e.message}\"\n\n      update_task_state(task_id, 'failed',\n        message: A2A::Models::Message.text(\n          role: 'agent',\n          text: \"Processing failed: #{e.message}\"\n        )\n      )\n    end\n  end\nend\n\n# Sinatra application\nclass ProductionA2AApp &lt; Sinatra::Base\n  set :server, :puma\n  set :bind, '0.0.0.0'\n  set :port, 4567\n\n  def initialize(app = nil, processor: nil)\n    super(app)\n\n    @processor = processor || DefaultProcessor.new\n\n    agent_card = create_agent_card\n    @server = ProductionA2AServer.new(agent_card, processor: @processor)\n  end\n\n  # AgentCard endpoint\n  get '/.well-known/agent.json' do\n    content_type :json\n    cache_control :public, max_age: 3600\n    @server.agent_card.to_json\n  end\n\n  # JSON-RPC endpoint\n  post '/a2a' do\n    content_type :json\n\n    begin\n      request_data = parse_request_body\n\n      response = @server.handle_request(request_data)\n\n      build_json_rpc_response(request_data[:id], response).to_json\n\n    rescue A2A::JSONRPCError =&gt; e\n      build_error_response(request_data&amp;.dig(:id), e).to_json\n\n    rescue JSON::ParserError =&gt; e\n      build_parse_error_response.to_json\n    end\n  end\n\n  # SSE streaming endpoint\n  get '/a2a/stream/:task_id', provides: 'text/event-stream' do\n    task_id = params[:task_id]\n    task = @server.tasks[task_id]\n\n    halt 404, { error: 'Task not found' }.to_json unless task\n\n    stream :keep_open do |out|\n      client = SSEClient.new(out)\n      @server.register_stream(task_id, client)\n\n      # Send initial status\n      client.send_event('taskStatus', task: task.to_h)\n\n      # Keep connection alive\n      out.callback do\n        @server.unregister_stream(task_id, client)\n      end\n    end\n  end\n\n  # Health check\n  get '/health' do\n    content_type :json\n    { status: 'ok', timestamp: Time.now.utc.iso8601 }.to_json\n  end\n\n  private\n\n  def create_agent_card\n    A2A::Models::AgentCard.new(\n      name: ENV['AGENT_NAME'] || 'Production A2A Agent',\n      url: ENV['AGENT_URL'] || 'http://localhost:4567',\n      version: '1.0.0',\n      description: 'A production-ready A2A agent',\n      capabilities: {\n        streaming: true,\n        push_notifications: true,\n        state_transition_history: false\n      },\n      skills: @processor.skills,\n      provider: {\n        organization: ENV['PROVIDER_ORG'] || 'Example Corp',\n        url: ENV['PROVIDER_URL'] || 'https://example.com'\n      }\n    )\n  end\n\n  def parse_request_body\n    JSON.parse(request.body.read, symbolize_names: true)\n  rescue JSON::ParserError =&gt; e\n    raise A2A::JSONParseError.new(data: { reason: e.message })\n  end\n\n  def build_json_rpc_response(request_id, response)\n    {\n      jsonrpc: '2.0',\n      id: request_id,\n      **response\n    }\n  end\n\n  def build_error_response(request_id, error)\n    {\n      jsonrpc: '2.0',\n      id: request_id,\n      error: {\n        code: error.code,\n        message: error.message,\n        data: error.data\n      }\n    }\n  end\n\n  def build_parse_error_response\n    {\n      jsonrpc: '2.0',\n      id: nil,\n      error: {\n        code: -32700,\n        message: 'Invalid JSON'\n      }\n    }\n  end\nend\n\n# SSE client wrapper\nclass SSEClient\n  def initialize(stream)\n    @stream = stream\n  end\n\n  def send_event(type, data)\n    @stream &lt;&lt; \"event: #{type}\\n\"\n    @stream &lt;&lt; \"data: #{data.to_json}\\n\"\n    @stream &lt;&lt; \"\\n\"\n  end\nend\n\n# Default processor\nclass DefaultProcessor\n  def skills\n    [\n      {\n        id: 'echo',\n        name: 'Echo',\n        description: 'Echoes your message'\n      }\n    ]\n  end\n\n  def process(task)\n    # Extract user message\n    text = task.status.message.parts.first.text\n\n    # Return response part\n    A2A::Models::TextPart.new(text: \"Echo: #{text}\")\n  end\nend\n\n# Run server\nif __FILE__ == $0\n  ProductionA2AApp.run!\nend\n</code></pre>"},{"location":"examples/server/#task-storage-and-management","title":"Task Storage and Management","text":""},{"location":"examples/server/#example-3-redis-backed-task-store","title":"Example 3: Redis-Backed Task Store","text":"<pre><code>require 'redis'\nrequire 'json'\n\nclass RedisTaskStore\n  def initialize(redis_url = ENV['REDIS_URL'] || 'redis://localhost:6379')\n    @redis = Redis.new(url: redis_url)\n  end\n\n  def save(task)\n    @redis.set(\"task:#{task.id}\", task.to_json)\n    @redis.expire(\"task:#{task.id}\", 86400) # 24 hour TTL\n    task\n  end\n\n  def find(task_id)\n    data = @redis.get(\"task:#{task_id}\")\n    return nil unless data\n\n    A2A::Models::Task.from_hash(JSON.parse(data, symbolize_names: true))\n  end\n\n  def delete(task_id)\n    @redis.del(\"task:#{task_id}\")\n  end\n\n  def find_by_session(session_id)\n    keys = @redis.keys(\"task:*\")\n    tasks = keys.map { |k| @redis.get(k) }\n                .compact\n                .map { |d| JSON.parse(d, symbolize_names: true) }\n                .select { |t| t[:sessionId] == session_id }\n                .map { |t| A2A::Models::Task.from_hash(t) }\n\n    tasks\n  end\nend\n</code></pre>"},{"location":"examples/server/#streaming-with-sse","title":"Streaming with SSE","text":""},{"location":"examples/server/#example-4-advanced-sse-streaming","title":"Example 4: Advanced SSE Streaming","text":"<pre><code>require 'sinatra/base'\nrequire 'sinatra/streaming'\n\nclass StreamingA2AServer &lt; ProductionA2AServer\n  def process_task_with_streaming(task_id)\n    task = @tasks[task_id]\n    return unless task\n\n    # Update to working\n    update_task_state(task_id, 'working')\n\n    begin\n      # Process in chunks with streaming\n      @processor.process_streaming(task) do |chunk|\n        # Create artifact chunk\n        artifact = A2A::Models::Artifact.new(\n          name: 'Response',\n          index: 0,\n          append: true,\n          last_chunk: false,\n          parts: [chunk]\n        )\n\n        # Notify clients\n        clients = @streaming_clients[task_id] || []\n        clients.each do |client|\n          client.send_event('artifactUpdate', artifact: artifact.to_h)\n        end\n\n        # Small delay to simulate streaming\n        sleep 0.1\n      end\n\n      # Send final task complete event\n      final_task = update_task_state(task_id, 'completed')\n      clients = @streaming_clients[task_id] || []\n      clients.each do |client|\n        client.send_event('taskComplete', task: final_task.to_h)\n      end\n\n    rescue StandardError =&gt; e\n      debug_me \"Streaming task failed: #{e.message}\"\n      update_task_state(task_id, 'failed')\n    end\n  end\nend\n\n# Streaming processor\nclass StreamingProcessor\n  def process_streaming(task)\n    text = task.status.message.parts.first.text\n    words = text.split(' ')\n\n    words.each do |word|\n      yield A2A::Models::TextPart.new(text: \"#{word} \")\n    end\n  end\nend\n</code></pre>"},{"location":"examples/server/#background-job-processing","title":"Background Job Processing","text":""},{"location":"examples/server/#example-5-sidekiq-integration","title":"Example 5: Sidekiq Integration","text":"<pre><code>require 'sidekiq'\n\nclass TaskProcessorJob\n  include Sidekiq::Job\n\n  def perform(task_id, server_class_name)\n    # Reconstruct server instance\n    # In production, you'd use a singleton or DI container\n    server = Object.const_get(server_class_name).instance\n\n    task = server.tasks[task_id]\n    return unless task\n\n    # Process the task\n    server.send(:process_task, task_id)\n  end\nend\n\nclass SidekiqA2AServer &lt; ProductionA2AServer\n  def handle_send_task(params)\n    task = super\n\n    # Queue for background processing via Sidekiq\n    TaskProcessorJob.perform_async(task.id, self.class.name)\n\n    task\n  end\nend\n</code></pre>"},{"location":"examples/server/#authentication-and-authorization","title":"Authentication and Authorization","text":""},{"location":"examples/server/#example-6-bearer-token-authentication","title":"Example 6: Bearer Token Authentication","text":"<pre><code>class AuthenticatedA2AApp &lt; ProductionA2AApp\n  before '/a2a' do\n    authenticate!\n  end\n\n  def authenticate!\n    auth_header = request.env['HTTP_AUTHORIZATION']\n\n    unless auth_header &amp;&amp; auth_header.start_with?('Bearer ')\n      halt 401, { error: 'Unauthorized' }.to_json\n    end\n\n    token = auth_header.sub('Bearer ', '')\n\n    unless valid_token?(token)\n      halt 403, { error: 'Invalid token' }.to_json\n    end\n\n    @current_user = user_from_token(token)\n  end\n\n  def valid_token?(token)\n    # Implement token validation\n    # Check against database, JWT verification, etc.\n    ENV['VALID_API_KEYS']&amp;.split(',')&amp;.include?(token)\n  end\n\n  def user_from_token(token)\n    # Load user from token\n    { id: 'user-123', api_key: token }\n  end\nend\n</code></pre>"},{"location":"examples/server/#complete-working-examples","title":"Complete Working Examples","text":""},{"location":"examples/server/#example-7-translation-agent-server","title":"Example 7: Translation Agent Server","text":"<pre><code>#!/usr/bin/env ruby\nrequire 'sinatra/base'\nrequire 'a2a'\nrequire 'json'\nrequire 'debug_me'\n\nclass TranslationProcessor\n  LANGUAGES = {\n    'es' =&gt; 'Spanish',\n    'fr' =&gt; 'French',\n    'de' =&gt; 'German',\n    'it' =&gt; 'Italian'\n  }\n\n  def skills\n    [\n      {\n        id: 'translate',\n        name: 'Translation',\n        description: 'Translate text between languages',\n        tags: ['translation', 'i18n'],\n        examples: [\n          \"Translate 'Hello' to Spanish\",\n          \"Convert 'Good morning' to French\"\n        ]\n      }\n    ]\n  end\n\n  def process(task)\n    text = task.status.message.parts.first.text\n    target_lang = extract_target_language(text)\n\n    translation = translate(text, target_lang)\n\n    [\n      A2A::Models::TextPart.new(text: translation),\n      A2A::Models::DataPart.new(\n        data: {\n          source_language: 'en',\n          target_language: target_lang,\n          confidence: 0.95\n        }\n      )\n    ]\n  end\n\n  private\n\n  def extract_target_language(text)\n    LANGUAGES.each do |code, name|\n      return code if text.downcase.include?(name.downcase)\n    end\n\n    'es' # Default to Spanish\n  end\n\n  def translate(text, target_lang)\n    # Simple mock translation\n    translations = {\n      'es' =&gt; { 'hello' =&gt; 'hola', 'goodbye' =&gt; 'adi\u00f3s', 'thank you' =&gt; 'gracias' },\n      'fr' =&gt; { 'hello' =&gt; 'bonjour', 'goodbye' =&gt; 'au revoir', 'thank you' =&gt; 'merci' },\n      'de' =&gt; { 'hello' =&gt; 'hallo', 'goodbye' =&gt; 'auf wiedersehen', 'thank you' =&gt; 'danke' }\n    }\n\n    # Extract words to translate\n    words = text.downcase.scan(/\\w+/)\n    translated = words.map { |w| translations.dig(target_lang, w) || w }\n\n    translated.join(' ').capitalize\n  end\nend\n\n# Run the server\nif __FILE__ == $0\n  processor = TranslationProcessor.new\n  app = ProductionA2AApp.new(processor: processor)\n  app.run!\nend\n</code></pre>"},{"location":"examples/server/#example-8-multi-agent-server","title":"Example 8: Multi-Agent Server","text":"<pre><code>class MultiAgentServer\n  def initialize\n    @agents = {}\n    register_agents\n  end\n\n  def register_agent(path, agent_card, processor)\n    @agents[path] = {\n      card: agent_card,\n      server: ProductionA2AServer.new(agent_card, processor: processor)\n    }\n  end\n\n  def register_agents\n    # Register translation agent\n    register_agent(\n      '/translate',\n      create_agent_card('Translation Agent', ['translate']),\n      TranslationProcessor.new\n    )\n\n    # Register echo agent\n    register_agent(\n      '/echo',\n      create_agent_card('Echo Agent', ['echo']),\n      EchoProcessor.new\n    )\n  end\n\n  def create_agent_card(name, skills)\n    A2A::Models::AgentCard.new(\n      name: name,\n      url: \"http://localhost:4567\",\n      version: '1.0.0',\n      capabilities: { streaming: true },\n      skills: skills.map { |id|\n        { id: id, name: id.capitalize, description: \"#{id.capitalize} service\" }\n      }\n    )\n  end\n\n  def app\n    agents = @agents\n\n    Sinatra.new do\n      # Serve agent cards\n      agents.each do |path, agent|\n        get \"#{path}/.well-known/agent.json\" do\n          content_type :json\n          agent[:card].to_json\n        end\n\n        post \"#{path}/a2a\" do\n          content_type :json\n          # Handle request with appropriate server\n          # Implementation similar to ProductionA2AApp\n        end\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"examples/server/#testing-servers","title":"Testing Servers","text":""},{"location":"examples/server/#example-9-rspec-tests","title":"Example 9: RSpec Tests","text":"<pre><code>require 'rack/test'\nrequire 'rspec'\nrequire_relative '../production_a2a_app'\n\nRSpec.describe ProductionA2AApp do\n  include Rack::Test::Methods\n\n  def app\n    ProductionA2AApp.new(processor: TestProcessor.new)\n  end\n\n  describe 'GET /.well-known/agent.json' do\n    it 'returns agent card' do\n      get '/.well-known/agent.json'\n\n      expect(last_response.status).to eq(200)\n      expect(last_response.content_type).to include('application/json')\n\n      data = JSON.parse(last_response.body, symbolize_names: true)\n      expect(data[:name]).to be_a(String)\n      expect(data[:version]).to be_a(String)\n      expect(data[:capabilities]).to be_a(Hash)\n    end\n  end\n\n  describe 'POST /a2a' do\n    it 'handles tasks/send' do\n      request = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'tasks/send',\n        params: {\n          taskId: 'task-123',\n          message: {\n            role: 'user',\n            parts: [{ type: 'text', text: 'Hello' }]\n          }\n        }\n      }\n\n      post '/a2a', request.to_json, 'CONTENT_TYPE' =&gt; 'application/json'\n\n      expect(last_response.status).to eq(200)\n      data = JSON.parse(last_response.body, symbolize_names: true)\n      expect(data[:result][:id]).to eq('task-123')\n    end\n\n    it 'returns error for invalid method' do\n      request = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'invalid/method',\n        params: {}\n      }\n\n      post '/a2a', request.to_json, 'CONTENT_TYPE' =&gt; 'application/json'\n\n      expect(last_response.status).to eq(200)\n      data = JSON.parse(last_response.body, symbolize_names: true)\n      expect(data[:error][:code]).to eq(-32601)\n    end\n  end\nend\n\nclass TestProcessor\n  def skills\n    [{ id: 'test', name: 'Test', description: 'Test skill' }]\n  end\n\n  def process(task)\n    A2A::Models::TextPart.new(text: 'Test response')\n  end\nend\n</code></pre>"},{"location":"examples/server/#production-deployment","title":"Production Deployment","text":""},{"location":"examples/server/#example-10-docker-configuration","title":"Example 10: Docker Configuration","text":"<pre><code>FROM ruby:3.2-alpine\n\nRUN apk add --no-cache build-base postgresql-dev\n\nWORKDIR /app\n\nCOPY Gemfile Gemfile.lock ./\nRUN bundle install --without development test\n\nCOPY . .\n\nEXPOSE 4567\n\nCMD [\"bundle\", \"exec\", \"puma\", \"-C\", \"config/puma.rb\"]\n</code></pre>"},{"location":"examples/server/#example-11-puma-configuration","title":"Example 11: Puma Configuration","text":"<pre><code># config/puma.rb\nworkers Integer(ENV.fetch('WEB_CONCURRENCY', 2))\nthreads_count = Integer(ENV.fetch('RAILS_MAX_THREADS', 5))\nthreads threads_count, threads_count\n\npreload_app!\n\nport ENV.fetch('PORT', 4567)\nenvironment ENV.fetch('RACK_ENV', 'production')\n\non_worker_boot do\n  # Setup connections per worker\nend\n</code></pre>"},{"location":"examples/server/#best-practices","title":"Best Practices","text":""},{"location":"examples/server/#1-always-validate-input","title":"1. Always Validate Input","text":"<pre><code>def handle_send_task(params)\n  validate_params!(params, required: [:taskId, :message])\n\n  # Process task\nend\n\ndef validate_params!(params, required:)\n  missing = required.reject { |k| params[k] || params[k.to_s] }\n\n  unless missing.empty?\n    raise A2A::InvalidParamsError.new(\n      data: { missing: missing.map(&amp;:to_s) }\n    )\n  end\nend\n</code></pre>"},{"location":"examples/server/#2-use-background-jobs","title":"2. Use Background Jobs","text":"<pre><code># Don't process tasks synchronously in request handler\n# BAD:\ndef handle_send_task(params)\n  task = create_task(params)\n  process_task(task) # Blocks request!\n  task\nend\n\n# GOOD:\ndef handle_send_task(params)\n  task = create_task(params)\n  enqueue_for_processing(task)\n  task\nend\n</code></pre>"},{"location":"examples/server/#3-implement-proper-timeouts","title":"3. Implement Proper Timeouts","text":"<pre><code>def process_task(task_id)\n  Timeout.timeout(300) do # 5 minute timeout\n    # Process task\n  end\nrescue Timeout::Error\n  update_task_state(task_id, 'failed',\n    message: A2A::Models::Message.text(\n      role: 'agent',\n      text: 'Task timeout'\n    )\n  )\nend\n</code></pre>"},{"location":"examples/server/#4-log-everything","title":"4. Log Everything","text":"<pre><code>require 'debug_me'\n\ndef handle_send_task(params)\n  debug_me { [:task_id, :session_id] }\n  task = create_task(params)\n  debug_me \"Task created: #{task.id}\"\n  task\nrescue =&gt; e\n  debug_me \"Error creating task: #{e.class} - #{e.message}\"\n  raise\nend\n</code></pre>"},{"location":"examples/server/#5-handle-graceful-shutdown","title":"5. Handle Graceful Shutdown","text":"<pre><code>trap('SIGTERM') do\n  puts 'Shutting down gracefully...'\n  @workers.each(&amp;:kill)\n  exit\nend\n</code></pre>"},{"location":"examples/server/#6-monitor-health","title":"6. Monitor Health","text":"<pre><code>get '/health' do\n  content_type :json\n\n  {\n    status: 'ok',\n    tasks: {\n      active: @server.tasks.count { |_, t| !t.state.terminal? },\n      total: @server.tasks.size\n    },\n    workers: @server.workers.count(&amp;:alive?),\n    timestamp: Time.now.utc.iso8601\n  }.to_json\nend\n</code></pre>"},{"location":"examples/server/#summary","title":"Summary","text":"<p>This guide covered:</p> <ol> <li>Simple Servers - Basic Sinatra implementation</li> <li>Production Servers - Full-featured with background processing</li> <li>Task Management - Storage and lifecycle</li> <li>Streaming - SSE implementation</li> <li>Background Jobs - Sidekiq integration</li> <li>Authentication - Bearer token support</li> <li>Testing - RSpec examples</li> <li>Deployment - Docker and production config</li> </ol>"},{"location":"examples/server/#next-steps","title":"Next Steps","text":"<ul> <li>Client Examples - Build A2A clients</li> <li>Basic Examples - Review data models</li> <li>Examples Index - Return to overview</li> </ul> <p>Back to Examples Index | Back to Documentation Home</p>"},{"location":"guides/","title":"Guides","text":"<p>Comprehensive guides to help you master the A2A protocol and Ruby gem.</p>"},{"location":"guides/#getting-started","title":"Getting Started","text":"<p>New to A2A? Start here:</p> <ul> <li>Getting Started - Complete tutorial from installation to your first A2A integration</li> <li>Learn the core concepts step-by-step</li> <li>Build a simple client and server</li> <li>Understand the protocol flow</li> </ul>"},{"location":"guides/#core-concepts","title":"Core Concepts","text":"<p>Master the fundamental building blocks:</p>"},{"location":"guides/#creating-agent-cards","title":"Creating Agent Cards","text":"<ul> <li>Define your agent's capabilities</li> <li>Publish agent metadata</li> <li>Configure streaming and notifications</li> <li>Define skills and input/output modes</li> </ul>"},{"location":"guides/#working-with-tasks","title":"Working with Tasks","text":"<ul> <li>Understand the task lifecycle</li> <li>Manage task states</li> <li>Handle task progression</li> <li>Work with session IDs for multi-turn conversations</li> </ul>"},{"location":"guides/#messages-and-parts","title":"Messages and Parts","text":"<ul> <li>Create user and agent messages</li> <li>Work with polymorphic parts (Text, File, Data)</li> <li>Handle file content (bytes vs URIs)</li> <li>Structure complex messages</li> </ul>"},{"location":"guides/#handling-artifacts","title":"Handling Artifacts","text":"<ul> <li>Generate agent outputs</li> <li>Work with multiple artifacts</li> <li>Stream partial results</li> <li>Add metadata to artifacts</li> </ul>"},{"location":"guides/#error-handling","title":"Error Handling","text":"<ul> <li>Understand the error hierarchy</li> <li>Handle JSON-RPC errors</li> <li>Manage A2A-specific errors</li> <li>Implement robust error handling</li> </ul>"},{"location":"guides/#by-use-case","title":"By Use Case","text":"<p>Find guides for specific scenarios:</p> <ul> <li>Building a Client: See Client Example</li> <li>Building a Server: See Server Example</li> <li>Streaming Responses: See Streaming Guide</li> <li>Multi-turn Conversations: See Conversations Guide</li> </ul>"},{"location":"guides/#best-practices","title":"Best Practices","text":"<ul> <li>Always validate input data</li> <li>Use factory methods (<code>Message.text</code>, etc.)</li> <li>Check task states with helper methods</li> <li>Handle all error types</li> <li>Test in isolation</li> </ul>"},{"location":"guides/#quick-reference","title":"Quick Reference","text":""},{"location":"guides/#common-patterns","title":"Common Patterns","text":"<pre><code># Create agent card\nagent = A2A::Models::AgentCard.new(...)\n\n# Create message\nmsg = A2A::Models::Message.text(role: \"user\", text: \"Hello\")\n\n# Create task\ntask = A2A::Models::Task.new(id: \"123\", status: { state: \"submitted\" })\n\n# Check state\ntask.state.submitted?\ntask.state.terminal?\n\n# Handle errors\nbegin\n  # ...\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Error #{e.code}: #{e.message}\"\nend\n</code></pre>"},{"location":"guides/#additional-resources","title":"Additional Resources","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Examples - Working code examples</li> <li>Architecture - System design and principles</li> <li>A2A Specification - Official protocol spec</li> </ul> <p>Choose a guide above to continue learning!</p>"},{"location":"guides/agent-cards/","title":"Creating Agent Cards","text":"<p>Agent Cards are the foundation of A2A agent discovery. They describe an agent's capabilities, skills, and how to interact with it.</p>"},{"location":"guides/agent-cards/#what-is-an-agent-card","title":"What is an Agent Card?","text":"<p>An Agent Card is a JSON document typically served at <code>/.well-known/agent.json</code> that contains:</p> <ul> <li>Agent metadata (name, version, description)</li> <li>Communication endpoint URL</li> <li>Capabilities (streaming, push notifications)</li> <li>Skills the agent can perform</li> <li>Provider information</li> <li>Authentication requirements</li> </ul>"},{"location":"guides/agent-cards/#basic-agent-card","title":"Basic Agent Card","text":"<pre><code>require 'a2a'\n\nagent_card = A2A::Models::AgentCard.new(\n  name: \"My Agent\",\n  url: \"https://myagent.example.com/a2a\",\n  version: \"1.0.0\",\n  description: \"A helpful AI agent\",\n  capabilities: {\n    streaming: false,\n    push_notifications: false,\n    state_transition_history: false\n  },\n  skills: [\n    {\n      id: \"skill-1\",\n      name: \"Question Answering\",\n      description: \"Answer questions about various topics\"\n    }\n  ]\n)\n</code></pre>"},{"location":"guides/agent-cards/#required-fields","title":"Required Fields","text":""},{"location":"guides/agent-cards/#name","title":"name","text":"<p>The human-readable name of your agent:</p> <pre><code>name: \"Translation Agent\"\n</code></pre>"},{"location":"guides/agent-cards/#url","title":"url","text":"<p>The HTTP(S) endpoint where the agent accepts A2A requests:</p> <pre><code>url: \"https://translate.example.com/a2a\"\n</code></pre>"},{"location":"guides/agent-cards/#version","title":"version","text":"<p>Semantic version of the agent:</p> <pre><code>version: \"2.1.0\"\n</code></pre>"},{"location":"guides/agent-cards/#capabilities","title":"capabilities","text":"<p>Agent capabilities configuration:</p> <pre><code>capabilities: {\n  streaming: true,              # Supports Server-Sent Events\n  push_notifications: true,     # Supports webhook callbacks\n  state_transition_history: false  # Returns full state history\n}\n</code></pre>"},{"location":"guides/agent-cards/#skills","title":"skills","text":"<p>Array of skills the agent can perform:</p> <pre><code>skills: [\n  {\n    id: \"translate\",\n    name: \"Translation\",\n    description: \"Translate text between languages\",\n    tags: [\"translation\", \"i18n\", \"localization\"],\n    examples: [\n      \"Translate 'hello' to Spanish\",\n      \"Convert this text to French\"\n    ],\n    input_modes: [\"text\"],\n    output_modes: [\"text\", \"data\"]\n  }\n]\n</code></pre>"},{"location":"guides/agent-cards/#optional-fields","title":"Optional Fields","text":""},{"location":"guides/agent-cards/#description","title":"description","text":"<p>Detailed description of the agent:</p> <pre><code>description: \"Translates text between 100+ languages using state-of-the-art neural networks\"\n</code></pre>"},{"location":"guides/agent-cards/#provider","title":"provider","text":"<p>Information about the organization providing the agent:</p> <pre><code>provider: {\n  organization: \"Acme Translation Corp\",\n  url: \"https://acmetranslation.com\"\n}\n</code></pre>"},{"location":"guides/agent-cards/#authentication","title":"authentication","text":"<p>Authentication schemes supported:</p> <pre><code>authentication: {\n  schemes: [\"bearer\", \"api_key\"],\n  credentials: \"Contact support@example.com for API keys\"\n}\n</code></pre>"},{"location":"guides/agent-cards/#default_input_modes","title":"default_input_modes","text":"<p>Default input modalities:</p> <pre><code>default_input_modes: [\"text\", \"file\"]\n</code></pre>"},{"location":"guides/agent-cards/#default_output_modes","title":"default_output_modes","text":"<p>Default output modalities:</p> <pre><code>default_output_modes: [\"text\", \"data\", \"file\"]\n</code></pre>"},{"location":"guides/agent-cards/#serving-agent-cards","title":"Serving Agent Cards","text":""},{"location":"guides/agent-cards/#with-sinatra","title":"With Sinatra","text":"<pre><code>require 'sinatra'\nrequire 'a2a'\nrequire 'json'\n\n# Serve agent card at well-known URL\nget '/.well-known/agent.json' do\n  content_type :json\n\n  agent = A2A::Models::AgentCard.new(\n    name: \"My Agent\",\n    url: \"https://#{request.host}/a2a\",\n    version: \"1.0.0\",\n    capabilities: { streaming: false },\n    skills: [{ id: \"test\", name: \"Test\" }]\n  )\n\n  JSON.generate(agent.to_h)\nend\n</code></pre>"},{"location":"guides/agent-cards/#with-rails","title":"With Rails","text":"<pre><code># config/routes.rb\nget '/.well-known/agent.json', to: 'agent#card'\n\n# app/controllers/agent_controller.rb\nclass AgentController &lt; ApplicationController\n  def card\n    agent = A2A::Models::AgentCard.new(\n      name: \"My Agent\",\n      url: \"https://#{request.host}/a2a\",\n      version: \"1.0.0\",\n      capabilities: { streaming: false },\n      skills: [{ id: \"test\", name: \"Test\" }]\n    )\n\n    render json: agent.to_h\n  end\nend\n</code></pre>"},{"location":"guides/agent-cards/#defining-skills","title":"Defining Skills","text":"<p>Skills describe what your agent can do:</p> <pre><code>skills: [\n  {\n    id: \"sentiment-analysis\",\n    name: \"Sentiment Analysis\",\n    description: \"Analyze the emotional tone of text\",\n    tags: [\"nlp\", \"sentiment\", \"analysis\"],\n    examples: [\n      \"What's the sentiment of: 'I love this!'\",\n      \"Analyze the tone of this review\"\n    ],\n    input_modes: [\"text\"],\n    output_modes: [\"text\", \"data\"]\n  },\n  {\n    id: \"entity-extraction\",\n    name: \"Entity Extraction\",\n    description: \"Extract named entities from text\",\n    tags: [\"nlp\", \"ner\", \"entities\"],\n    examples: [\n      \"Find all people mentioned in this article\",\n      \"Extract company names from this text\"\n    ],\n    input_modes: [\"text\", \"file\"],\n    output_modes: [\"data\"]\n  }\n]\n</code></pre>"},{"location":"guides/agent-cards/#capabilities-configuration","title":"Capabilities Configuration","text":""},{"location":"guides/agent-cards/#streaming-support","title":"Streaming Support","text":"<p>Enable if your agent can stream responses via SSE:</p> <pre><code>capabilities: {\n  streaming: true\n}\n</code></pre>"},{"location":"guides/agent-cards/#push-notifications","title":"Push Notifications","text":"<p>Enable if your agent supports webhook callbacks:</p> <pre><code>capabilities: {\n  push_notifications: true\n}\n</code></pre>"},{"location":"guides/agent-cards/#state-transition-history","title":"State Transition History","text":"<p>Enable if you track and return full task state history:</p> <pre><code>capabilities: {\n  state_transition_history: true\n}\n</code></pre>"},{"location":"guides/agent-cards/#best-practices","title":"Best Practices","text":"<ol> <li>Be Specific: Clearly describe what your agent does</li> <li>Provide Examples: Help users understand how to interact with your agent</li> <li>Use Tags: Make your skills discoverable</li> <li>Version Properly: Use semantic versioning</li> <li>Keep it Current: Update when capabilities change</li> </ol>"},{"location":"guides/agent-cards/#complete-example","title":"Complete Example","text":"<pre><code>require 'a2a'\n\nagent_card = A2A::Models::AgentCard.new(\n  name: \"Advanced NLP Agent\",\n  url: \"https://nlp-agent.example.com/a2a\",\n  version: \"3.2.1\",\n  description: \"State-of-the-art natural language processing for multiple languages\",\n\n  provider: {\n    organization: \"NLP Technologies Inc.\",\n    url: \"https://nlp-tech.com\"\n  },\n\n  capabilities: {\n    streaming: true,\n    push_notifications: true,\n    state_transition_history: false\n  },\n\n  authentication: {\n    schemes: [\"bearer\"],\n    credentials: \"API keys available at https://nlp-tech.com/api-keys\"\n  },\n\n  default_input_modes: [\"text\", \"file\"],\n  default_output_modes: [\"text\", \"data\"],\n\n  skills: [\n    {\n      id: \"sentiment\",\n      name: \"Sentiment Analysis\",\n      description: \"Analyze emotional tone and sentiment\",\n      tags: [\"sentiment\", \"emotion\", \"nlp\"],\n      examples: [\"Analyze sentiment of: 'Great product!'\"],\n      input_modes: [\"text\"],\n      output_modes: [\"data\"]\n    },\n    {\n      id: \"summarization\",\n      name: \"Text Summarization\",\n      description: \"Generate concise summaries\",\n      tags: [\"summarization\", \"extraction\", \"nlp\"],\n      examples: [\"Summarize this article in 3 sentences\"],\n      input_modes: [\"text\", \"file\"],\n      output_modes: [\"text\"]\n    }\n  ]\n)\n</code></pre>"},{"location":"guides/agent-cards/#next-steps","title":"Next Steps","text":"<ul> <li>Working with Tasks - Handle agent requests</li> <li>Messages and Parts - Structure communication</li> <li>Building a Server - Implement an A2A server</li> </ul> <p>Back to Guides</p>"},{"location":"guides/artifacts/","title":"Handling Artifacts","text":"<p>Artifacts represent the outputs generated by an agent during task execution. They are the primary mechanism for delivering results, files, and structured data back to clients.</p>"},{"location":"guides/artifacts/#table-of-contents","title":"Table of Contents","text":"<ul> <li>What are Artifacts?</li> <li>Artifact Structure</li> <li>Creating Artifacts</li> </ul>"},{"location":"guides/artifacts/#what-are-artifacts","title":"What are Artifacts?","text":"<p>Artifacts are structured outputs that agents produce as the result of processing a task. Unlike status messages (which provide updates during processing), artifacts represent the final deliverables.</p> <pre><code>graph LR\n    A[Task Request] --&gt; B[Agent Processing]\n    B --&gt;|Status Updates| C[Messages]\n    B --&gt;|Final Results| D[Artifacts]\n    D --&gt; E[Client Receives Results]\n\n    style A fill:#e1f5ff\n    style B fill:#fff4e1\n    style C fill:#ffe1f5\n    style D fill:#e8f5e9\n    style E fill:#e1f5ff</code></pre>"},{"location":"guides/artifacts/#artifacts-vs-messages","title":"Artifacts vs Messages","text":"Aspect Messages Artifacts Purpose Communication/status updates Final results/deliverables Location In TaskStatus In Task.artifacts array Timing During processing At completion Mutability Updated with each status Accumulated over time"},{"location":"guides/artifacts/#artifact-structure","title":"Artifact Structure","text":"<p>Every artifact has the following structure:</p> Field Type Required Description <code>parts</code> Array Yes Array of Part objects (TextPart, FilePart, DataPart) <code>name</code> String No Human-readable name for the artifact <code>description</code> String No Description of what the artifact contains <code>index</code> Integer No Position in artifact list (default: 0) <code>append</code> Boolean No Whether to append to existing artifact (streaming) <code>last_chunk</code> Boolean No Whether this is the final chunk (streaming) <code>metadata</code> Hash No Optional metadata <pre><code>artifact = A2A::Models::Artifact.new(\n  name: \"Analysis Results\",\n  description: \"Statistical analysis of sales data\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Analysis complete\"),\n    A2A::Models::DataPart.new(data: { total: 42 })\n  ],\n  index: 0,\n  metadata: { generated_at: Time.now.iso8601 }\n)\n</code></pre>"},{"location":"guides/artifacts/#creating-artifacts","title":"Creating Artifacts","text":""},{"location":"guides/artifacts/#basic-text-artifact","title":"Basic Text Artifact","text":"<pre><code>require 'a2a'\n\nartifact = A2A::Models::Artifact.new(\n  name: \"Summary\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"Processing completed successfully.\"\n    )\n  ]\n)\n</code></pre>"},{"location":"guides/artifacts/#data-artifact","title":"Data Artifact","text":"<pre><code>artifact = A2A::Models::Artifact.new(\n  name: \"Statistical Results\",\n  description: \"Computed statistics from dataset\",\n  parts: [\n    A2A::Models::DataPart.new(\n      data: {\n        count: 1000,\n        mean: 45.5,\n        median: 42.0,\n        std_dev: 12.3,\n        quartiles: [35, 42, 55]\n      }\n    )\n  ]\n)\n</code></pre>"},{"location":"guides/artifacts/#file-artifact","title":"File Artifact","text":"<pre><code>artifact = A2A::Models::Artifact.new(\n  name: \"Generated Report\",\n  description: \"PDF report with analysis results\",\n  parts: [\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"report.pdf\",\n        mime_type: \"application/pdf\",\n        uri: \"https://storage.example.com/reports/2024-01-15.pdf\"\n      }\n    )\n  ]\n)\n</code></pre> <p>For complete examples and advanced patterns, see the Streaming Support guide.</p>"},{"location":"guides/artifacts/#see-also","title":"See Also","text":"<ul> <li>Messages and Parts - Understanding message structure</li> <li>Working with Tasks - Task lifecycle and management</li> <li>Error Handling - Handle errors gracefully</li> <li>Streaming Support - Real-time artifact streaming</li> <li>API Reference: Models - Complete model API documentation</li> </ul> <p>Back to Guides | Home</p>"},{"location":"guides/errors/","title":"Error Handling","text":"<p>The A2A gem provides a comprehensive error hierarchy for handling both JSON-RPC protocol errors and A2A-specific errors. This guide covers error types, handling strategies, and best practices.</p>"},{"location":"guides/errors/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Error Hierarchy</li> <li>JSON-RPC Standard Errors</li> <li>A2A-Specific Errors</li> <li>Error Handling Patterns</li> <li>Protocol Error Responses</li> <li>Best Practices</li> <li>Examples</li> </ul>"},{"location":"guides/errors/#error-hierarchy","title":"Error Hierarchy","text":"<p>All errors inherit from a common base:</p> <pre><code>A2A::Error (StandardError)\n  \u2514\u2500\u2500 A2A::JSONRPCError\n        \u251c\u2500\u2500 A2A::JSONParseError (-32700)\n        \u251c\u2500\u2500 A2A::InvalidRequestError (-32600)\n        \u251c\u2500\u2500 A2A::MethodNotFoundError (-32601)\n        \u251c\u2500\u2500 A2A::InvalidParamsError (-32602)\n        \u251c\u2500\u2500 A2A::InternalError (-32603)\n        \u251c\u2500\u2500 A2A::TaskNotFoundError (-32001)\n        \u251c\u2500\u2500 A2A::TaskNotCancelableError (-32002)\n        \u251c\u2500\u2500 A2A::PushNotificationNotSupportedError (-32003)\n        \u2514\u2500\u2500 A2A::UnsupportedOperationError (-32004)\n</code></pre>"},{"location":"guides/errors/#json-rpc-standard-errors","title":"JSON-RPC Standard Errors","text":""},{"location":"guides/errors/#jsonparse-error-32700","title":"JSONParse Error (-32700)","text":"<p>Invalid JSON payload:</p> <pre><code>begin\n  # Parse invalid JSON\n  raise A2A::JSONParseError.new(data: { received: \"invalid json{\" })\nrescue A2A::JSONParseError =&gt; e\n  puts e.message  # =&gt; \"Invalid JSON payload\"\n  puts e.code     # =&gt; -32700\n  puts e.data     # =&gt; { received: \"invalid json{\" }\nend\n</code></pre>"},{"location":"guides/errors/#invalidrequesterror-32600","title":"InvalidRequestError (-32600)","text":"<p>Request validation failed:</p> <pre><code>begin\n  # Missing required field\n  raise A2A::InvalidRequestError.new(\n    data: { missing_fields: [\"method\"] }\n  )\nrescue A2A::InvalidRequestError =&gt; e\n  puts e.message  # =&gt; \"Request payload validation error\"\n  puts e.code     # =&gt; -32600\nend\n</code></pre>"},{"location":"guides/errors/#methodnotfounderror-32601","title":"MethodNotFoundError (-32601)","text":"<p>RPC method not found:</p> <pre><code>begin\n  # Unknown method\n  raise A2A::MethodNotFoundError.new(\n    data: { method: \"tasks/unknownMethod\" }\n  )\nrescue A2A::MethodNotFoundError =&gt; e\n  puts e.message  # =&gt; \"Method not found\"\n  puts e.code     # =&gt; -32601\nend\n</code></pre>"},{"location":"guides/errors/#invalidparamserror-32602","title":"InvalidParamsError (-32602)","text":"<p>Invalid parameters:</p> <pre><code>begin\n  raise A2A::InvalidParamsError.new(\n    data: { param: \"taskId\", error: \"must be a string\" }\n  )\nrescue A2A::InvalidParamsError =&gt; e\n  puts e.message  # =&gt; \"Invalid parameters\"\n  puts e.code     # =&gt; -32602\nend\n</code></pre>"},{"location":"guides/errors/#internalerror-32603","title":"InternalError (-32603)","text":"<p>Server internal error:</p> <pre><code>begin\n  raise A2A::InternalError.new(\n    data: { error: \"Database connection failed\" }\n  )\nrescue A2A::InternalError =&gt; e\n  puts e.message  # =&gt; \"Internal error\"\n  puts e.code     # =&gt; -32603\nend\n</code></pre>"},{"location":"guides/errors/#a2a-specific-errors","title":"A2A-Specific Errors","text":""},{"location":"guides/errors/#tasknotfounderror-32001","title":"TaskNotFoundError (-32001)","text":"<p>Task ID not found:</p> <pre><code>begin\n  raise A2A::TaskNotFoundError.new\nrescue A2A::TaskNotFoundError =&gt; e\n  puts e.message  # =&gt; \"Task not found\"\n  puts e.code     # =&gt; -32001\nend\n</code></pre>"},{"location":"guides/errors/#tasknotcancelableerror-32002","title":"TaskNotCancelableError (-32002)","text":"<p>Task cannot be canceled:</p> <pre><code>begin\n  # Task already completed\n  raise A2A::TaskNotCancelableError.new\nrescue A2A::TaskNotCancelableError =&gt; e\n  puts e.message  # =&gt; \"Task cannot be canceled\"\n  puts e.code     # =&gt; -32002\nend\n</code></pre>"},{"location":"guides/errors/#pushnotificationnotsupportederror-32003","title":"PushNotificationNotSupportedError (-32003)","text":"<p>Push notifications not supported:</p> <pre><code>begin\n  raise A2A::PushNotificationNotSupportedError.new\nrescue A2A::PushNotificationNotSupportedError =&gt; e\n  puts e.message  # =&gt; \"Push Notification is not supported\"\n  puts e.code     # =&gt; -32003\nend\n</code></pre>"},{"location":"guides/errors/#unsupportedoperationerror-32004","title":"UnsupportedOperationError (-32004)","text":"<p>Operation not supported:</p> <pre><code>begin\n  raise A2A::UnsupportedOperationError.new\nrescue A2A::UnsupportedOperationError =&gt; e\n  puts e.message  # =&gt; \"This operation is not supported\"\n  puts e.code     # =&gt; -32004\nend\n</code></pre>"},{"location":"guides/errors/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"guides/errors/#pattern-catch-all-json-rpc-errors","title":"Pattern: Catch All JSON-RPC Errors","text":"<pre><code>begin\n  # A2A operation\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Protocol Error: #{e.message}\"\n  puts \"Error Code: #{e.code}\"\n  puts \"Data: #{e.data.inspect}\" if e.data\nend\n</code></pre>"},{"location":"guides/errors/#pattern-specific-error-handling","title":"Pattern: Specific Error Handling","text":"<pre><code>begin\n  # Client operation\n  client.get_task(task_id: \"nonexistent\")\nrescue A2A::TaskNotFoundError =&gt; e\n  puts \"Task not found - it may have been deleted\"\nrescue A2A::InvalidParamsError =&gt; e\n  puts \"Invalid task ID provided\"\nrescue A2A::JSONRPCError =&gt; e\n  puts \"Other protocol error: #{e.message}\"\nend\n</code></pre>"},{"location":"guides/errors/#pattern-error-recovery","title":"Pattern: Error Recovery","text":"<pre><code>def get_task_with_retry(client, task_id, max_retries: 3)\n  retries = 0\n\n  begin\n    client.get_task(task_id: task_id)\n  rescue A2A::InternalError =&gt; e\n    retries += 1\n    if retries &lt; max_retries\n      sleep(2 ** retries)  # Exponential backoff\n      retry\n    else\n      raise\n    end\n  rescue A2A::TaskNotFoundError\n    nil  # Return nil for not found\n  end\nend\n</code></pre>"},{"location":"guides/errors/#pattern-error-logging","title":"Pattern: Error Logging","text":"<pre><code>def handle_a2a_error(error)\n  case error\n  when A2A::TaskNotFoundError\n    logger.warn(\"Task not found: #{error.message}\")\n  when A2A::InvalidParamsError\n    logger.error(\"Invalid parameters: #{error.data}\")\n  when A2A::InternalError\n    logger.fatal(\"Internal error: #{error.message}\")\n    notify_admins(error)\n  else\n    logger.error(\"A2A error: #{error.class} - #{error.message}\")\n  end\nend\n\nbegin\n  # Operation\nrescue A2A::JSONRPCError =&gt; e\n  handle_a2a_error(e)\n  raise  # Re-raise if needed\nend\n</code></pre>"},{"location":"guides/errors/#protocol-error-responses","title":"Protocol Error Responses","text":""},{"location":"guides/errors/#creating-error-responses","title":"Creating Error Responses","text":"<pre><code>require 'a2a'\n\n# Create error response\nerror_response = A2A::Protocol::Response.error(\n  id: \"request-123\",\n  error: {\n    code: -32001,\n    message: \"Task not found\",\n    data: { task_id: \"task-456\" }\n  }\n)\n\nputs error_response.success?  # =&gt; false\nputs error_response.error     # =&gt; { code: -32001, ... }\n</code></pre>"},{"location":"guides/errors/#server-error-handling","title":"Server Error Handling","text":"<pre><code>class MyA2AServer &lt; A2A::Server::Base\n  def handle_get_task(params)\n    task_id = params['taskId']\n\n    task = find_task(task_id)\n    if task.nil?\n      raise A2A::TaskNotFoundError.new\n    end\n\n    task\n  rescue A2A::TaskNotFoundError =&gt; e\n    # Return error response\n    {\n      code: e.code,\n      message: e.message,\n      data: { task_id: task_id }\n    }\n  end\nend\n</code></pre>"},{"location":"guides/errors/#best-practices","title":"Best Practices","text":""},{"location":"guides/errors/#1-catch-specific-errors-first","title":"1. Catch Specific Errors First","text":"<pre><code># Good: Specific to general\nbegin\n  operation\nrescue A2A::TaskNotFoundError =&gt; e\n  handle_not_found\nrescue A2A::InvalidParamsError =&gt; e\n  handle_invalid_params\nrescue A2A::JSONRPCError =&gt; e\n  handle_general_error\nend\n\n# Bad: General first catches everything\nbegin\n  operation\nrescue A2A::JSONRPCError =&gt; e  # Too broad!\n  handle_error\nrescue A2A::TaskNotFoundError =&gt; e  # Never reached!\n  handle_not_found\nend\n</code></pre>"},{"location":"guides/errors/#2-include-helpful-error-data","title":"2. Include Helpful Error Data","text":"<pre><code># Good: Include context\nraise A2A::InvalidParamsError.new(\n  data: {\n    param: \"message\",\n    expected: \"Message object\",\n    received: message.class.name\n  }\n)\n\n# Basic: Minimal info\nraise A2A::InvalidParamsError.new\n</code></pre>"},{"location":"guides/errors/#3-log-errors-appropriately","title":"3. Log Errors Appropriately","text":"<pre><code># Good: Log with context\nbegin\n  task = client.get_task(task_id: id)\nrescue A2A::TaskNotFoundError =&gt; e\n  logger.warn(\"Task #{id} not found\", error: e)\n  nil\nrescue A2A::JSONRPCError =&gt; e\n  logger.error(\"A2A error fetching task #{id}\", error: e, code: e.code)\n  raise\nend\n</code></pre>"},{"location":"guides/errors/#4-provide-user-friendly-messages","title":"4. Provide User-Friendly Messages","text":"<pre><code># Good: User-friendly messages\nbegin\n  client.send_task(...)\nrescue A2A::InvalidParamsError =&gt; e\n  flash[:error] = \"Invalid request. Please check your input.\"\nrescue A2A::InternalError =&gt; e\n  flash[:error] = \"Service temporarily unavailable. Please try again later.\"\nend\n</code></pre>"},{"location":"guides/errors/#examples","title":"Examples","text":""},{"location":"guides/errors/#example-1-client-error-handling","title":"Example 1: Client Error Handling","text":"<pre><code>require 'a2a'\n\nclass A2AClient &lt; A2A::Client::Base\n  def send_message_safely(task_id, message)\n    begin\n      send_task(task_id: task_id, message: message)\n    rescue A2A::InvalidParamsError =&gt; e\n      puts \"Invalid message format: #{e.data}\"\n      nil\n    rescue A2A::InternalError =&gt; e\n      puts \"Server error. Please try again later.\"\n      nil\n    rescue A2A::JSONRPCError =&gt; e\n      puts \"Unexpected error (#{e.code}): #{e.message}\"\n      nil\n    end\n  end\nend\n</code></pre>"},{"location":"guides/errors/#example-2-validation-errors","title":"Example 2: Validation Errors","text":"<pre><code>require 'a2a'\n\ndef validate_and_create_task(params)\n  errors = []\n\n  if params[:id].nil? || params[:id].empty?\n    errors &lt;&lt; \"Task ID is required\"\n  end\n\n  if params[:status].nil?\n    errors &lt;&lt; \"Status is required\"\n  end\n\n  unless errors.empty?\n    raise A2A::InvalidParamsError.new(\n      data: { validation_errors: errors }\n    )\n  end\n\n  A2A::Models::Task.new(**params)\nrescue ArgumentError =&gt; e\n  raise A2A::InvalidParamsError.new(\n    data: { error: e.message }\n  )\nend\n\nbegin\n  task = validate_and_create_task(id: \"\", status: nil)\nrescue A2A::InvalidParamsError =&gt; e\n  puts \"Validation failed:\"\n  e.data[:validation_errors].each { |err| puts \"  - #{err}\" }\nend\n</code></pre>"},{"location":"guides/errors/#example-3-server-implementation-with-error-handling","title":"Example 3: Server Implementation with Error Handling","text":"<pre><code>require 'a2a'\n\nclass MyAgent &lt; A2A::Server::Base\n  def handle_send_task(params)\n    message = parse_message(params)\n    validate_message(message)\n\n    # Process task\n    result = process_task(message)\n\n    A2A::Models::Task.new(\n      id: params['taskId'],\n      status: { state: \"completed\" },\n      artifacts: [result]\n    )\n  rescue ArgumentError =&gt; e\n    raise A2A::InvalidParamsError.new(data: { error: e.message })\n  rescue StandardError =&gt; e\n    logger.error(\"Task processing failed\", error: e)\n    raise A2A::InternalError.new(data: { error: \"Processing failed\" })\n  end\n\n  private\n\n  def parse_message(params)\n    A2A::Models::Message.from_hash(params['message'])\n  rescue =&gt; e\n    raise A2A::InvalidParamsError.new(\n      data: { field: \"message\", error: e.message }\n    )\n  end\n\n  def validate_message(message)\n    if message.parts.empty?\n      raise A2A::InvalidParamsError.new(\n        data: { field: \"message.parts\", error: \"cannot be empty\" }\n      )\n    end\n  end\nend\n</code></pre>"},{"location":"guides/errors/#example-4-retry-with-exponential-backoff","title":"Example 4: Retry with Exponential Backoff","text":"<pre><code>def robust_task_submission(client, task_id, message, max_retries: 3)\n  retries = 0\n\n  begin\n    client.send_task(task_id: task_id, message: message)\n  rescue A2A::InternalError, A2A::Error =&gt; e\n    retries += 1\n\n    if retries &lt; max_retries\n      wait_time = 2 ** retries\n      puts \"Retry #{retries}/#{max_retries} in #{wait_time}s...\"\n      sleep(wait_time)\n      retry\n    else\n      puts \"Max retries reached. Giving up.\"\n      raise\n    end\n  rescue A2A::TaskNotFoundError\n    puts \"Task does not exist\"\n    nil\n  rescue A2A::InvalidParamsError =&gt; e\n    puts \"Invalid request: #{e.data}\"\n    nil\n  end\nend\n</code></pre>"},{"location":"guides/errors/#see-also","title":"See Also","text":"<ul> <li>Working with Tasks - Task lifecycle and management</li> <li>Messages and Parts - Understanding message structure</li> <li>API Reference: Protocol - Protocol error details</li> <li>Building a Server - Server error handling</li> <li>Building a Client - Client error handling</li> </ul> <p>Back to Guides | Home</p>"},{"location":"guides/getting-started/","title":"Getting Started with A2A","text":"<p>This comprehensive tutorial will walk you through building your first A2A application, from installation to creating a working client-server pair.</p>"},{"location":"guides/getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>Ruby 3.4.0 or higher installed</li> <li>Basic knowledge of Ruby</li> <li>Familiarity with JSON and REST APIs (helpful but not required)</li> </ul>"},{"location":"guides/getting-started/#what-youll-build","title":"What You'll Build","text":"<p>In this tutorial, you'll create:</p> <ol> <li>An A2A agent card</li> <li>A simple message exchange</li> <li>A basic task workflow</li> <li>An artifact with results</li> </ol>"},{"location":"guides/getting-started/#step-1-installation","title":"Step 1: Installation","text":"<p>Install the A2A gem:</p> <pre><code>gem install a2a\n</code></pre> <p>Verify the installation:</p> <pre><code>ruby -r a2a -e \"puts A2A.version\"\n</code></pre>"},{"location":"guides/getting-started/#step-2-understanding-the-protocol","title":"Step 2: Understanding the Protocol","text":"<p>The A2A protocol defines how agents:</p> <ol> <li>Discover each other via Agent Cards</li> <li>Communicate using Messages with Parts</li> <li>Execute work as Tasks</li> <li>Return results as Artifacts</li> </ol> <p></p>"},{"location":"guides/getting-started/#step-3-create-your-first-agent-card","title":"Step 3: Create Your First Agent Card","text":"<p>Create a file called <code>my_agent.rb</code>:</p> <pre><code>require 'a2a'\nrequire 'json'\n\n# Define your agent's capabilities\nagent_card = A2A::Models::AgentCard.new(\n  name: \"Calculator Agent\",\n  url: \"https://calculator.example.com/a2a\",\n  version: \"1.0.0\",\n  description: \"Performs basic mathematical operations\",\n\n  # Capabilities\n  capabilities: {\n    streaming: false,\n    push_notifications: false,\n    state_transition_history: false\n  },\n\n  # Skills\n  skills: [\n    {\n      id: \"add\",\n      name: \"Addition\",\n      description: \"Add two numbers\",\n      tags: [\"math\", \"arithmetic\"],\n      examples: [\"Add 5 and 3\", \"What is 10 + 20?\"]\n    },\n    {\n      id: \"multiply\",\n      name: \"Multiplication\",\n      description: \"Multiply two numbers\",\n      tags: [\"math\", \"arithmetic\"],\n      examples: [\"Multiply 4 and 6\", \"What is 8 * 7?\"]\n    }\n  ],\n\n  # Provider information\n  provider: {\n    organization: \"My Organization\",\n    url: \"https://myorg.example.com\"\n  }\n)\n\n# Print the agent card as JSON\nputs JSON.pretty_generate(agent_card.to_h)\n</code></pre> <p>Run it:</p> <pre><code>ruby my_agent.rb\n</code></pre>"},{"location":"guides/getting-started/#step-4-working-with-messages","title":"Step 4: Working with Messages","text":"<p>Messages represent communication turns. Create <code>messages_demo.rb</code>:</p> <pre><code>require 'a2a'\n\n# User asks a question\nuser_message = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"What is 15 + 27?\"\n)\n\nputs \"User: #{user_message.parts.first.text}\"\n\n# Agent responds with text and structured data\nagent_message = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"The answer is 42\"\n    ),\n    A2A::Models::DataPart.new(\n      data: {\n        operation: \"addition\",\n        operands: [15, 27],\n        result: 42\n      }\n    )\n  ]\n)\n\nputs \"Agent (text): #{agent_message.parts[0].text}\"\nputs \"Agent (data): #{agent_message.parts[1].data}\"\n</code></pre> <p>Run it:</p> <pre><code>ruby messages_demo.rb\n</code></pre>"},{"location":"guides/getting-started/#step-5-task-lifecycle","title":"Step 5: Task Lifecycle","text":"<p>Tasks progress through states. Create <code>task_demo.rb</code>:</p> <pre><code>require 'a2a'\n\ntask_id = \"task-#{Time.now.to_i}\"\n\n# 1. Task is submitted\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: {\n    state: \"submitted\",\n    timestamp: Time.now.utc.iso8601\n  }\n)\n\nputs \"1. Task #{task.id} is #{task.state}\"\nputs \"   Terminal? #{task.state.terminal?}\"\n\n# 2. Task is being worked on\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: {\n    state: \"working\",\n    message: A2A::Models::Message.text(\n      role: \"agent\",\n      text: \"Processing your request...\"\n    )\n  }\n)\n\nputs \"\\n2. Task is now: #{task.state}\"\nputs \"   Status message: #{task.status.message.parts.first.text}\"\n\n# 3. Task is completed with results\ntask = A2A::Models::Task.new(\n  id: task_id,\n  status: {\n    state: \"completed\"\n  },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Calculation Result\",\n      parts: [\n        A2A::Models::DataPart.new(\n          data: { result: 42 }\n        )\n      ]\n    )\n  ]\n)\n\nputs \"\\n3. Task is: #{task.state}\"\nputs \"   Terminal? #{task.state.terminal?}\"\nputs \"   Result: #{task.artifacts.first.parts.first.data}\"\n</code></pre> <p>Run it:</p> <pre><code>ruby task_demo.rb\n</code></pre>"},{"location":"guides/getting-started/#step-6-complete-example","title":"Step 6: Complete Example","text":"<p>Now let's put it all together in <code>calculator.rb</code>:</p> <pre><code>require 'a2a'\nrequire 'json'\n\nclass Calculator\n  def initialize\n    @agent_card = create_agent_card\n  end\n\n  attr_reader :agent_card\n\n  def process_task(task_id, message)\n    # Extract the question from the message\n    text = message.parts.first.text\n\n    # Simple parsing (in real app, use NLP or structured input)\n    if text =~ /(\\d+)\\s*\\+\\s*(\\d+)/\n      result = $1.to_i + $2.to_i\n      operation = \"addition\"\n    elsif text =~ /(\\d+)\\s*\\*\\s*(\\d+)/\n      result = $1.to_i * $2.to_i\n      operation = \"multiplication\"\n    else\n      return create_error_task(task_id, \"Could not parse mathematical expression\")\n    end\n\n    # Create completed task with result\n    A2A::Models::Task.new(\n      id: task_id,\n      status: {\n        state: \"completed\"\n      },\n      artifacts: [\n        A2A::Models::Artifact.new(\n          name: \"Calculation Result\",\n          parts: [\n            A2A::Models::TextPart.new(\n              text: \"The answer is #{result}\"\n            ),\n            A2A::Models::DataPart.new(\n              data: {\n                operation: operation,\n                result: result,\n                timestamp: Time.now.utc.iso8601\n              }\n            )\n          ]\n        )\n      ]\n    )\n  end\n\n  private\n\n  def create_agent_card\n    A2A::Models::AgentCard.new(\n      name: \"Calculator Agent\",\n      url: \"https://calculator.example.com/a2a\",\n      version: \"1.0.0\",\n      description: \"Performs basic mathematical operations\",\n      capabilities: {\n        streaming: false,\n        push_notifications: false\n      },\n      skills: [\n        {\n          id: \"math\",\n          name: \"Mathematics\",\n          description: \"Basic arithmetic operations\"\n        }\n      ]\n    )\n  end\n\n  def create_error_task(task_id, error_message)\n    A2A::Models::Task.new(\n      id: task_id,\n      status: {\n        state: \"failed\",\n        message: A2A::Models::Message.text(\n          role: \"agent\",\n          text: error_message\n        )\n      }\n    )\n  end\nend\n\n# Demo usage\ncalc = Calculator.new\n\nputs \"Agent Card:\"\nputs JSON.pretty_generate(calc.agent_card.to_h)\nputs \"\\n\" + \"=\"*50 + \"\\n\"\n\n# Process a task\nuser_message = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"What is 15 + 27?\"\n)\n\ntask = calc.process_task(\"task-123\", user_message)\n\nputs \"Task Result:\"\nputs \"State: #{task.state}\"\nputs \"Text: #{task.artifacts.first.parts[0].text}\"\nputs \"Data: #{task.artifacts.first.parts[1].data}\"\n</code></pre> <p>Run it:</p> <pre><code>ruby calculator.rb\n</code></pre>"},{"location":"guides/getting-started/#step-7-error-handling","title":"Step 7: Error Handling","text":"<p>Add robust error handling to your application:</p> <pre><code>require 'a2a'\n\ndef safe_task_creation(task_id, state)\n  begin\n    task = A2A::Models::Task.new(\n      id: task_id,\n      status: { state: state }\n    )\n    puts \"\u2713 Created task with state: #{task.state}\"\n  rescue ArgumentError =&gt; e\n    puts \"\u2717 Error: #{e.message}\"\n  end\nend\n\n# Valid states\nsafe_task_creation(\"task-1\", \"submitted\")\nsafe_task_creation(\"task-2\", \"completed\")\n\n# Invalid state\nsafe_task_creation(\"task-3\", \"invalid-state\")\n\n# Handle protocol errors\nbegin\n  raise A2A::TaskNotFoundError\nrescue A2A::JSONRPCError =&gt; e\n  puts \"\\nProtocol Error:\"\n  puts \"  Code: #{e.code}\"\n  puts \"  Message: #{e.message}\"\nend\n</code></pre>"},{"location":"guides/getting-started/#step-8-multi-turn-conversations","title":"Step 8: Multi-turn Conversations","text":"<p>Use session IDs to maintain context across tasks:</p> <pre><code>require 'a2a'\n\nsession_id = \"session-#{Time.now.to_i}\"\n\n# First question\ntask1 = A2A::Models::Task.new(\n  id: \"task-1\",\n  session_id: session_id,\n  status: { state: \"completed\" },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Answer\",\n      parts: [\n        A2A::Models::TextPart.new(text: \"15 + 27 equals 42\")\n      ]\n    )\n  ]\n)\n\nputs \"Task 1 (Session: #{task1.session_id}):\"\nputs \"  #{task1.artifacts.first.parts.first.text}\"\n\n# Follow-up question (same session)\ntask2 = A2A::Models::Task.new(\n  id: \"task-2\",\n  session_id: session_id,  # Same session!\n  status: { state: \"completed\" },\n  artifacts: [\n    A2A::Models::Artifact.new(\n      name: \"Answer\",\n      parts: [\n        A2A::Models::TextPart.new(text: \"42 * 2 equals 84\")\n      ]\n    )\n  ]\n)\n\nputs \"\\nTask 2 (Session: #{task2.session_id}):\"\nputs \"  #{task2.artifacts.first.parts.first.text}\"\n</code></pre>"},{"location":"guides/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore:</p>"},{"location":"guides/getting-started/#build-more-complex-agents","title":"Build More Complex Agents","text":"<ul> <li>Creating Agent Cards - Advanced agent configuration</li> <li>Working with Tasks - Task lifecycle management</li> <li>Messages and Parts - Complex message structures</li> </ul>"},{"location":"guides/getting-started/#implement-clientserver","title":"Implement Client/Server","text":"<ul> <li>Building a Client - HTTP client implementation</li> <li>Building a Server - HTTP server implementation</li> </ul>"},{"location":"guides/getting-started/#advanced-features","title":"Advanced Features","text":"<ul> <li>Streaming Support - Real-time updates</li> <li>Push Notifications - Webhook integration</li> <li>Multi-turn Conversations - Session management</li> </ul>"},{"location":"guides/getting-started/#reference","title":"Reference","text":"<ul> <li>API Documentation - Complete API reference</li> <li>Examples - More code examples</li> </ul>"},{"location":"guides/getting-started/#summary","title":"Summary","text":"<p>In this tutorial, you learned:</p> <p>\u2705 How to install and verify the A2A gem \u2705 Core protocol concepts (Agent Cards, Messages, Tasks, Artifacts) \u2705 How to create and work with all major data types \u2705 Task lifecycle and state management \u2705 Error handling \u2705 Multi-turn conversations</p> <p>You're now ready to build A2A applications!</p> <p>Questions? Check the API Reference or Examples.</p>"},{"location":"guides/messages/","title":"Messages and Parts","text":"<p>Messages are the fundamental communication mechanism in the A2A protocol, representing individual communication turns between a client (user) and an agent. Each message contains one or more Parts that define the content being communicated.</p>"},{"location":"guides/messages/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Message Overview</li> <li>Message Structure</li> <li>Message Roles</li> <li>Parts: Polymorphic Content</li> <li>TextPart</li> <li>FilePart</li> <li>DataPart</li> <li>Creating Messages</li> <li>Working with Parts</li> <li>Advanced Patterns</li> <li>Best Practices</li> <li>Examples</li> </ul>"},{"location":"guides/messages/#message-overview","title":"Message Overview","text":"<p>Messages represent communication turns in an A2A interaction. They are used in two key places:</p> <ol> <li>Input Messages: User messages sent to the agent via task requests</li> <li>Status Messages: Agent messages providing updates during task execution</li> </ol> <p></p>"},{"location":"guides/messages/#message-structure","title":"Message Structure","text":"<p>Every message has three main components:</p> Field Type Required Description <code>role</code> String Yes Either \"user\" or \"agent\" <code>parts</code> Array Yes Array of Part objects (TextPart, FilePart, DataPart) <code>metadata</code> Hash No Optional metadata for extensibility <pre><code>message = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Hello\")\n  ],\n  metadata: { timestamp: Time.now.iso8601 }\n)\n</code></pre>"},{"location":"guides/messages/#message-roles","title":"Message Roles","text":"<p>Messages have two valid roles:</p>"},{"location":"guides/messages/#user-role","title":"User Role","text":"<p>Represents input from the client/user:</p> <pre><code>user_message = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"Please analyze this data\"\n    )\n  ]\n)\n</code></pre>"},{"location":"guides/messages/#agent-role","title":"Agent Role","text":"<p>Represents responses from the agent:</p> <pre><code>agent_message = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"Analysis complete. Results:\"\n    ),\n    A2A::Models::DataPart.new(\n      data: { summary: \"Dataset contains 1000 records\" }\n    )\n  ]\n)\n</code></pre>"},{"location":"guides/messages/#role-validation","title":"Role Validation","text":"<p>The gem automatically validates message roles:</p> <pre><code># This will raise ArgumentError\ninvalid_message = A2A::Models::Message.new(\n  role: \"system\",  # Invalid! Must be \"user\" or \"agent\"\n  parts: []\n)\n# =&gt; ArgumentError: Invalid role: system. Must be one of: user, agent\n</code></pre>"},{"location":"guides/messages/#parts-polymorphic-content","title":"Parts: Polymorphic Content","text":"<p>Parts are the building blocks of messages. The A2A protocol supports three types of parts:</p> Part Type Purpose Content Type TextPart Plain text content String FilePart File content (bytes or URI) Binary or reference DataPart Structured JSON data Hash/Object"},{"location":"guides/messages/#part-polymorphism","title":"Part Polymorphism","text":"<p>Parts use a type-based polymorphic design:</p> <pre><code># All parts inherit from Part base class\nclass Part\n  def type\n    raise NotImplementedError\n  end\nend\n\n# Each subclass implements its own type\nclass TextPart &lt; Part\n  def type\n    'text'\n  end\nend\n\nclass FilePart &lt; Part\n  def type\n    'file'\n  end\nend\n\nclass DataPart &lt; Part\n  def type\n    'data'\n  end\nend\n</code></pre>"},{"location":"guides/messages/#textpart","title":"TextPart","text":"<p>TextPart represents plain text content - the most common type of part.</p>"},{"location":"guides/messages/#creating-textparts","title":"Creating TextParts","text":"<pre><code># Direct creation\ntext_part = A2A::Models::TextPart.new(\n  text: \"This is plain text content\",\n  metadata: { language: \"en\" }\n)\n\n# Access the text\nputs text_part.text\n# =&gt; \"This is plain text content\"\n\nputs text_part.type\n# =&gt; \"text\"\n</code></pre>"},{"location":"guides/messages/#text-messages-shortcut","title":"Text Messages (Shortcut)","text":"<p>The <code>Message.text</code> factory method creates a single-part text message:</p> <pre><code># Instead of this verbose approach:\nmessage = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Hello\")\n  ]\n)\n\n# Use this shortcut:\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"Hello\"\n)\n</code></pre>"},{"location":"guides/messages/#multi-paragraph-text","title":"Multi-paragraph Text","text":"<pre><code>long_text = &lt;&lt;~TEXT\n  This is a multi-paragraph message.\n\n  It can contain multiple lines\n  and paragraphs.\n\n  The TextPart preserves formatting.\nTEXT\n\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: long_text\n)\n</code></pre>"},{"location":"guides/messages/#markdown-content","title":"Markdown Content","text":"<pre><code>markdown_text = &lt;&lt;~MARKDOWN\n  # Analysis Results\n\n  ## Summary\n  - Total records: 1,000\n  - Valid records: 985\n  - Invalid records: 15\n\n  ## Recommendations\n  1. Review invalid records\n  2. Reprocess data\nMARKDOWN\n\nmessage = A2A::Models::Message.text(\n  role: \"agent\",\n  text: markdown_text,\n  metadata: { format: \"markdown\" }\n)\n</code></pre>"},{"location":"guides/messages/#filepart","title":"FilePart","text":"<p>FilePart represents file content, either as base64-encoded bytes or as a URI reference.</p>"},{"location":"guides/messages/#file-content-structure","title":"File Content Structure","text":"<p>Every FilePart contains a FileContent object with:</p> Field Type Required Description <code>name</code> String No Filename <code>mime_type</code> String No MIME type (e.g., \"text/csv\", \"image/png\") <code>bytes</code> String Yes* Base64-encoded file content <code>uri</code> String Yes* URI to file location <p>*Either <code>bytes</code> or <code>uri</code> must be provided, but not both.</p>"},{"location":"guides/messages/#filepart-with-uri-reference","title":"FilePart with URI Reference","text":"<p>Best for large files or files hosted elsewhere:</p> <pre><code>require 'a2a'\n\nfile_part = A2A::Models::FilePart.new(\n  file: {\n    name: \"dataset.csv\",\n    mime_type: \"text/csv\",\n    uri: \"https://example.com/data/dataset.csv\"\n  },\n  metadata: { size_bytes: 1024000 }\n)\n\nputs file_part.file.name\n# =&gt; \"dataset.csv\"\n\nputs file_part.file.uri\n# =&gt; \"https://example.com/data/dataset.csv\"\n</code></pre>"},{"location":"guides/messages/#filepart-with-inline-bytes","title":"FilePart with Inline Bytes","text":"<p>Best for small files that should be embedded:</p> <pre><code>require 'a2a'\nrequire 'base64'\n\n# Read a file\nfile_content = File.binread(\"report.pdf\")\n\n# Create FilePart with inline bytes\nfile_part = A2A::Models::FilePart.new(\n  file: {\n    name: \"report.pdf\",\n    mime_type: \"application/pdf\",\n    bytes: Base64.strict_encode64(file_content)\n  }\n)\n\n# Decode bytes back to original\ndecoded = Base64.strict_decode64(file_part.file.bytes)\n</code></pre>"},{"location":"guides/messages/#images-as-fileparts","title":"Images as FileParts","text":"<pre><code>require 'base64'\n\n# PNG image by URI\nimage_uri = A2A::Models::FilePart.new(\n  file: {\n    name: \"chart.png\",\n    mime_type: \"image/png\",\n    uri: \"https://example.com/charts/sales-2024.png\"\n  }\n)\n\n# JPEG image as inline bytes\nimage_data = File.binread(\"photo.jpg\")\nimage_bytes = A2A::Models::FilePart.new(\n  file: {\n    name: \"photo.jpg\",\n    mime_type: \"image/jpeg\",\n    bytes: Base64.strict_encode64(image_data)\n  }\n)\n</code></pre>"},{"location":"guides/messages/#csv-files","title":"CSV Files","text":"<pre><code>csv_part = A2A::Models::FilePart.new(\n  file: {\n    name: \"results.csv\",\n    mime_type: \"text/csv\",\n    uri: \"https://storage.example.com/results/2024-01-15.csv\"\n  },\n  metadata: {\n    rows: 1000,\n    columns: 12,\n    generated_at: Time.now.iso8601\n  }\n)\n</code></pre>"},{"location":"guides/messages/#filecontent-validation","title":"FileContent Validation","text":"<p>The FileContent class enforces that exactly one of bytes or uri is provided:</p> <pre><code># This will raise ArgumentError\ninvalid_file = A2A::Models::FilePart.new(\n  file: {\n    name: \"file.txt\"\n    # Missing both bytes and uri!\n  }\n)\n# =&gt; ArgumentError: Either bytes or uri must be provided\n\n# This will also raise ArgumentError\ninvalid_file = A2A::Models::FilePart.new(\n  file: {\n    name: \"file.txt\",\n    bytes: \"...\",\n    uri: \"...\"  # Cannot provide both!\n  }\n)\n# =&gt; ArgumentError: Only one of bytes or uri can be provided, not both\n</code></pre>"},{"location":"guides/messages/#datapart","title":"DataPart","text":"<p>DataPart represents structured JSON data - perfect for forms, structured results, or machine-readable content.</p>"},{"location":"guides/messages/#creating-dataparts","title":"Creating DataParts","text":"<pre><code>data_part = A2A::Models::DataPart.new(\n  data: {\n    user_id: 12345,\n    name: \"John Doe\",\n    email: \"john@example.com\",\n    preferences: {\n      theme: \"dark\",\n      notifications: true\n    }\n  },\n  metadata: { schema_version: \"1.0\" }\n)\n\nputs data_part.data[:name]\n# =&gt; \"John Doe\"\n\nputs data_part.type\n# =&gt; \"data\"\n</code></pre>"},{"location":"guides/messages/#form-data","title":"Form Data","text":"<pre><code>form_data = A2A::Models::DataPart.new(\n  data: {\n    form_type: \"user_registration\",\n    fields: [\n      {\n        name: \"email\",\n        type: \"email\",\n        required: true,\n        value: nil\n      },\n      {\n        name: \"password\",\n        type: \"password\",\n        required: true,\n        value: nil\n      },\n      {\n        name: \"age\",\n        type: \"number\",\n        required: false,\n        value: nil\n      }\n    ]\n  }\n)\n</code></pre>"},{"location":"guides/messages/#analysis-results","title":"Analysis Results","text":"<pre><code>analysis_data = A2A::Models::DataPart.new(\n  data: {\n    analysis_type: \"sentiment\",\n    results: {\n      positive: 0.75,\n      negative: 0.15,\n      neutral: 0.10\n    },\n    confidence: 0.92,\n    processed_at: Time.now.utc.iso8601\n  }\n)\n</code></pre>"},{"location":"guides/messages/#structured-errors","title":"Structured Errors","text":"<pre><code>error_data = A2A::Models::DataPart.new(\n  data: {\n    error_code: \"VALIDATION_FAILED\",\n    error_message: \"Input validation failed\",\n    fields: {\n      email: [\"Must be a valid email address\"],\n      age: [\"Must be between 0 and 120\"]\n    }\n  }\n)\n</code></pre>"},{"location":"guides/messages/#complex-nested-data","title":"Complex Nested Data","text":"<pre><code>complex_data = A2A::Models::DataPart.new(\n  data: {\n    dataset: {\n      name: \"Sales Data 2024\",\n      records: 1000,\n      schema: {\n        columns: [\n          { name: \"date\", type: \"datetime\" },\n          { name: \"product\", type: \"string\" },\n          { name: \"revenue\", type: \"decimal\" }\n        ]\n      }\n    },\n    statistics: {\n      total_revenue: 125000.50,\n      average_sale: 125.00,\n      top_products: [\n        { name: \"Widget A\", sales: 450 },\n        { name: \"Widget B\", sales: 320 }\n      ]\n    }\n  }\n)\n</code></pre>"},{"location":"guides/messages/#creating-messages","title":"Creating Messages","text":""},{"location":"guides/messages/#simple-text-message","title":"Simple Text Message","text":"<pre><code>message = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"What is the weather today?\"\n)\n</code></pre>"},{"location":"guides/messages/#multi-part-message","title":"Multi-Part Message","text":"<pre><code>message = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"Please analyze this dataset:\"\n    ),\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"data.csv\",\n        mime_type: \"text/csv\",\n        uri: \"https://example.com/data.csv\"\n      }\n    ),\n    A2A::Models::DataPart.new(\n      data: {\n        analysis_type: \"statistical\",\n        include_charts: true\n      }\n    )\n  ]\n)\n</code></pre>"},{"location":"guides/messages/#message-with-metadata","title":"Message with Metadata","text":"<pre><code>message = A2A::Models::Message.text(\n  role: \"agent\",\n  text: \"Processing complete\",\n  metadata: {\n    processing_time_ms: 1250,\n    model_version: \"2.1.0\",\n    confidence: 0.95\n  }\n)\n</code></pre>"},{"location":"guides/messages/#working-with-parts","title":"Working with Parts","text":""},{"location":"guides/messages/#iterating-over-parts","title":"Iterating Over Parts","text":"<pre><code>message = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Results:\"),\n    A2A::Models::DataPart.new(data: { count: 42 }),\n    A2A::Models::FilePart.new(\n      file: { name: \"report.pdf\", uri: \"https://...\" }\n    )\n  ]\n)\n\n# Iterate over all parts\nmessage.parts.each do |part|\n  puts \"Part type: #{part.type}\"\n\n  case part.type\n  when 'text'\n    puts \"  Text: #{part.text}\"\n  when 'data'\n    puts \"  Data: #{part.data.inspect}\"\n  when 'file'\n    puts \"  File: #{part.file.name}\"\n  end\nend\n</code></pre>"},{"location":"guides/messages/#finding-specific-part-types","title":"Finding Specific Part Types","text":"<pre><code># Find all text parts\ntext_parts = message.parts.select { |p| p.type == 'text' }\n\n# Find all file parts\nfile_parts = message.parts.select { |p| p.type == 'file' }\n\n# Find first data part\ndata_part = message.parts.find { |p| p.type == 'data' }\n</code></pre>"},{"location":"guides/messages/#extracting-text-content","title":"Extracting Text Content","text":"<pre><code># Get all text from a message\nall_text = message.parts\n  .select { |p| p.is_a?(A2A::Models::TextPart) }\n  .map(&amp;:text)\n  .join(\"\\n\\n\")\n\nputs all_text\n</code></pre>"},{"location":"guides/messages/#extracting-data-content","title":"Extracting Data Content","text":"<pre><code># Combine all data parts\nall_data = message.parts\n  .select { |p| p.is_a?(A2A::Models::DataPart) }\n  .map(&amp;:data)\n\n# Merge data parts (if they're hashes)\nmerged_data = all_data.reduce({}) do |acc, data|\n  acc.merge(data)\nend\n</code></pre>"},{"location":"guides/messages/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/messages/#pattern-mixed-content-message","title":"Pattern: Mixed Content Message","text":"<p>Combine text explanation with structured data and file attachments:</p> <pre><code>def create_analysis_response(text, statistics, chart_uri)\n  A2A::Models::Message.new(\n    role: \"agent\",\n    parts: [\n      A2A::Models::TextPart.new(\n        text: text\n      ),\n      A2A::Models::DataPart.new(\n        data: statistics\n      ),\n      A2A::Models::FilePart.new(\n        file: {\n          name: \"chart.png\",\n          mime_type: \"image/png\",\n          uri: chart_uri\n        }\n      )\n    ]\n  )\nend\n\nresponse = create_analysis_response(\n  \"Analysis shows strong positive trend in Q4 2024.\",\n  {\n    revenue: 125000,\n    growth_rate: 0.15,\n    top_category: \"Electronics\"\n  },\n  \"https://storage.example.com/charts/q4-2024.png\"\n)\n</code></pre>"},{"location":"guides/messages/#pattern-serialization-and-deserialization","title":"Pattern: Serialization and Deserialization","text":"<pre><code>require 'json'\n\n# Create a message\nmessage = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Hello\"),\n    A2A::Models::DataPart.new(data: { foo: \"bar\" })\n  ]\n)\n\n# Convert to hash\nhash = message.to_h\n\n# Serialize to JSON\njson_string = JSON.generate(hash)\nputs json_string\n\n# Deserialize from JSON\nparsed_hash = JSON.parse(json_string, symbolize_names: true)\nrestored_message = A2A::Models::Message.from_hash(parsed_hash)\n\n# Verify\nputs restored_message.role\n# =&gt; \"user\"\n\nputs restored_message.parts.first.text\n# =&gt; \"Hello\"\n</code></pre>"},{"location":"guides/messages/#pattern-progressive-message-building","title":"Pattern: Progressive Message Building","text":"<pre><code>class MessageBuilder\n  def initialize(role)\n    @role = role\n    @parts = []\n    @metadata = {}\n  end\n\n  def add_text(text)\n    @parts &lt;&lt; A2A::Models::TextPart.new(text: text)\n    self\n  end\n\n  def add_file(name:, mime_type:, uri: nil, bytes: nil)\n    file_content = { name: name, mime_type: mime_type }\n    file_content[:uri] = uri if uri\n    file_content[:bytes] = bytes if bytes\n\n    @parts &lt;&lt; A2A::Models::FilePart.new(file: file_content)\n    self\n  end\n\n  def add_data(data)\n    @parts &lt;&lt; A2A::Models::DataPart.new(data: data)\n    self\n  end\n\n  def with_metadata(metadata)\n    @metadata.merge!(metadata)\n    self\n  end\n\n  def build\n    A2A::Models::Message.new(\n      role: @role,\n      parts: @parts,\n      metadata: @metadata.empty? ? nil : @metadata\n    )\n  end\nend\n\n# Usage\nmessage = MessageBuilder.new(\"agent\")\n  .add_text(\"Here are your results:\")\n  .add_data({ count: 42, status: \"success\" })\n  .add_file(\n    name: \"details.json\",\n    mime_type: \"application/json\",\n    uri: \"https://example.com/results.json\"\n  )\n  .with_metadata({ processing_time: 150 })\n  .build\n</code></pre>"},{"location":"guides/messages/#pattern-message-validation","title":"Pattern: Message Validation","text":"<pre><code>def validate_message(message)\n  errors = []\n\n  # Check role\n  unless ['user', 'agent'].include?(message.role)\n    errors &lt;&lt; \"Invalid role: #{message.role}\"\n  end\n\n  # Check parts\n  if message.parts.empty?\n    errors &lt;&lt; \"Message must have at least one part\"\n  end\n\n  # Validate each part\n  message.parts.each_with_index do |part, index|\n    case part\n    when A2A::Models::TextPart\n      if part.text.nil? || part.text.empty?\n        errors &lt;&lt; \"Part #{index}: Text cannot be empty\"\n      end\n    when A2A::Models::FilePart\n      if part.file.name.nil?\n        errors &lt;&lt; \"Part #{index}: File name is missing\"\n      end\n    when A2A::Models::DataPart\n      if part.data.nil?\n        errors &lt;&lt; \"Part #{index}: Data cannot be nil\"\n      end\n    end\n  end\n\n  errors\nend\n\n# Usage\nmessage = A2A::Models::Message.text(role: \"user\", text: \"\")\nerrors = validate_message(message)\nif errors.any?\n  puts \"Validation errors:\"\n  errors.each { |e| puts \"  - #{e}\" }\nend\n</code></pre>"},{"location":"guides/messages/#pattern-part-type-filtering","title":"Pattern: Part Type Filtering","text":"<pre><code>class MessageAnalyzer\n  def initialize(message)\n    @message = message\n  end\n\n  def text_parts\n    @message.parts.select { |p| p.is_a?(A2A::Models::TextPart) }\n  end\n\n  def file_parts\n    @message.parts.select { |p| p.is_a?(A2A::Models::FilePart) }\n  end\n\n  def data_parts\n    @message.parts.select { |p| p.is_a?(A2A::Models::DataPart) }\n  end\n\n  def has_text?\n    text_parts.any?\n  end\n\n  def has_files?\n    file_parts.any?\n  end\n\n  def has_data?\n    data_parts.any?\n  end\n\n  def summary\n    {\n      role: @message.role,\n      total_parts: @message.parts.size,\n      text_parts: text_parts.size,\n      file_parts: file_parts.size,\n      data_parts: data_parts.size\n    }\n  end\nend\n\n# Usage\nmessage = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(text: \"Results\"),\n    A2A::Models::DataPart.new(data: { count: 10 }),\n    A2A::Models::FilePart.new(file: { name: \"f.csv\", uri: \"...\" })\n  ]\n)\n\nanalyzer = MessageAnalyzer.new(message)\nputs analyzer.summary.inspect\n# =&gt; {:role=&gt;\"agent\", :total_parts=&gt;3, :text_parts=&gt;1, :file_parts=&gt;1, :data_parts=&gt;1}\n</code></pre>"},{"location":"guides/messages/#best-practices","title":"Best Practices","text":""},{"location":"guides/messages/#1-use-factory-methods","title":"1. Use Factory Methods","text":"<pre><code># Good: Use factory method for simple text messages\nmessage = A2A::Models::Message.text(role: \"user\", text: \"Hello\")\n\n# Verbose: Manual construction\nmessage = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [A2A::Models::TextPart.new(text: \"Hello\")]\n)\n</code></pre>"},{"location":"guides/messages/#2-choose-appropriate-part-types","title":"2. Choose Appropriate Part Types","text":"<pre><code># Good: Use DataPart for structured data\nA2A::Models::DataPart.new(\n  data: { temperature: 72, unit: \"fahrenheit\" }\n)\n\n# Bad: Don't encode structured data as text\nA2A::Models::TextPart.new(\n  text: '{\"temperature\": 72, \"unit\": \"fahrenheit\"}'\n)\n</code></pre>"},{"location":"guides/messages/#3-use-uri-for-large-files","title":"3. Use URI for Large Files","text":"<pre><code># Good: URI reference for large files\nA2A::Models::FilePart.new(\n  file: {\n    name: \"large-dataset.csv\",\n    mime_type: \"text/csv\",\n    uri: \"https://storage.example.com/datasets/large.csv\"\n  }\n)\n\n# Bad: Embedding large files as bytes (inefficient)\nlarge_content = File.binread(\"large-dataset.csv\")  # 100MB file!\nA2A::Models::FilePart.new(\n  file: {\n    name: \"large-dataset.csv\",\n    mime_type: \"text/csv\",\n    bytes: Base64.strict_encode64(large_content)  # Huge base64 string!\n  }\n)\n</code></pre>"},{"location":"guides/messages/#4-add-metadata-for-context","title":"4. Add Metadata for Context","text":"<pre><code># Good: Include helpful metadata\nmessage = A2A::Models::Message.text(\n  role: \"agent\",\n  text: \"Processing complete\",\n  metadata: {\n    processing_time_ms: 1500,\n    model_version: \"2.1.0\",\n    timestamp: Time.now.utc.iso8601\n  }\n)\n</code></pre>"},{"location":"guides/messages/#5-set-correct-mime-types","title":"5. Set Correct MIME Types","text":"<pre><code># Good: Accurate MIME types\nA2A::Models::FilePart.new(\n  file: {\n    name: \"report.pdf\",\n    mime_type: \"application/pdf\",\n    uri: \"...\"\n  }\n)\n\nA2A::Models::FilePart.new(\n  file: {\n    name: \"data.json\",\n    mime_type: \"application/json\",\n    uri: \"...\"\n  }\n)\n</code></pre>"},{"location":"guides/messages/#6-validate-before-sending","title":"6. Validate Before Sending","text":"<pre><code>def safe_message_creation(role, parts)\n  begin\n    message = A2A::Models::Message.new(\n      role: role,\n      parts: parts\n    )\n    puts \"Message created successfully\"\n    message\n  rescue ArgumentError =&gt; e\n    puts \"Validation error: #{e.message}\"\n    nil\n  end\nend\n</code></pre>"},{"location":"guides/messages/#examples","title":"Examples","text":""},{"location":"guides/messages/#example-1-user-question","title":"Example 1: User Question","text":"<pre><code>require 'a2a'\n\nmessage = A2A::Models::Message.text(\n  role: \"user\",\n  text: \"What is the capital of France?\"\n)\n\nputs \"Role: #{message.role}\"\nputs \"Text: #{message.parts.first.text}\"\n</code></pre>"},{"location":"guides/messages/#example-2-agent-response-with-data","title":"Example 2: Agent Response with Data","text":"<pre><code>require 'a2a'\n\nmessage = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"The capital of France is Paris.\"\n    ),\n    A2A::Models::DataPart.new(\n      data: {\n        city: \"Paris\",\n        country: \"France\",\n        population: 2_161_000,\n        coordinates: {\n          latitude: 48.8566,\n          longitude: 2.3522\n        }\n      }\n    )\n  ]\n)\n\ntext = message.parts[0].text\ndata = message.parts[1].data\n\nputs text\nputs \"Population: #{data[:population].to_s.reverse.gsub(/(\\d{3})(?=\\d)/, '\\\\1,').reverse}\"\n</code></pre>"},{"location":"guides/messages/#example-3-file-upload-request","title":"Example 3: File Upload Request","text":"<pre><code>require 'a2a'\nrequire 'base64'\n\n# Read a CSV file\ncsv_content = File.read(\"sales_data.csv\")\n\nmessage = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"Please analyze this sales data and provide insights.\"\n    ),\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"sales_data.csv\",\n        mime_type: \"text/csv\",\n        bytes: Base64.strict_encode64(csv_content)\n      }\n    ),\n    A2A::Models::DataPart.new(\n      data: {\n        analysis_options: {\n          include_trends: true,\n          time_period: \"monthly\",\n          metrics: [\"revenue\", \"units_sold\", \"profit_margin\"]\n        }\n      }\n    )\n  ]\n)\n\nputs \"Message with #{message.parts.size} parts created\"\n</code></pre>"},{"location":"guides/messages/#example-4-multi-part-agent-response","title":"Example 4: Multi-part Agent Response","text":"<pre><code>require 'a2a'\n\n# Simulate agent providing analysis with chart\nmessage = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: &lt;&lt;~TEXT\n        # Sales Analysis Results\n\n        I've analyzed your sales data for Q4 2024. Here are the key findings:\n\n        - Total Revenue: $125,000\n        - Growth Rate: 15% compared to Q3\n        - Top Product: Widget A (450 units)\n\n        See the attached chart for visual representation.\n      TEXT\n    ),\n    A2A::Models::DataPart.new(\n      data: {\n        period: \"Q4 2024\",\n        total_revenue: 125000,\n        growth_rate: 0.15,\n        top_products: [\n          { name: \"Widget A\", units: 450, revenue: 45000 },\n          { name: \"Widget B\", units: 320, revenue: 38400 },\n          { name: \"Widget C\", units: 280, revenue: 30800 }\n        ],\n        recommendations: [\n          \"Increase inventory for Widget A\",\n          \"Consider promotion for Widget C\",\n          \"Monitor Widget B pricing\"\n        ]\n      }\n    ),\n    A2A::Models::FilePart.new(\n      file: {\n        name: \"q4_sales_chart.png\",\n        mime_type: \"image/png\",\n        uri: \"https://storage.example.com/charts/q4-2024-sales.png\"\n      }\n    )\n  ],\n  metadata: {\n    analysis_completed_at: Time.now.utc.iso8601,\n    processing_time_seconds: 3.5\n  }\n)\n\nputs \"Created comprehensive response with:\"\nputs \"  - #{message.parts.count { |p| p.is_a?(A2A::Models::TextPart) }} text part(s)\"\nputs \"  - #{message.parts.count { |p| p.is_a?(A2A::Models::DataPart) }} data part(s)\"\nputs \"  - #{message.parts.count { |p| p.is_a?(A2A::Models::FilePart) }} file part(s)\"\n</code></pre>"},{"location":"guides/messages/#example-5-form-input-message","title":"Example 5: Form Input Message","text":"<pre><code>require 'a2a'\n\n# User submitting a form via DataPart\nmessage = A2A::Models::Message.new(\n  role: \"user\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"I'd like to register a new account.\"\n    ),\n    A2A::Models::DataPart.new(\n      data: {\n        form_type: \"user_registration\",\n        fields: {\n          email: \"user@example.com\",\n          username: \"johndoe\",\n          full_name: \"John Doe\",\n          preferences: {\n            newsletter: true,\n            notifications: {\n              email: true,\n              sms: false\n            }\n          }\n        }\n      }\n    )\n  ]\n)\n\n# Extract form data\ndata_part = message.parts.find { |p| p.is_a?(A2A::Models::DataPart) }\nform_data = data_part.data\n\nputs \"Registration for: #{form_data[:fields][:email]}\"\n</code></pre>"},{"location":"guides/messages/#example-6-error-response","title":"Example 6: Error Response","text":"<pre><code>require 'a2a'\n\n# Agent returning an error with structured details\nerror_message = A2A::Models::Message.new(\n  role: \"agent\",\n  parts: [\n    A2A::Models::TextPart.new(\n      text: \"Unable to process your request due to validation errors.\"\n    ),\n    A2A::Models::DataPart.new(\n      data: {\n        error_type: \"validation_error\",\n        error_code: \"INVALID_INPUT\",\n        errors: [\n          {\n            field: \"email\",\n            message: \"Email address is not valid\",\n            received: \"not-an-email\"\n          },\n          {\n            field: \"age\",\n            message: \"Age must be between 0 and 120\",\n            received: 150\n          }\n        ],\n        timestamp: Time.now.utc.iso8601\n      }\n    )\n  ]\n)\n\n# Extract error details\nerror_data = error_message.parts\n  .find { |p| p.is_a?(A2A::Models::DataPart) }\n  .data\n\nputs \"Error: #{error_data[:error_code]}\"\nerror_data[:errors].each do |err|\n  puts \"  - #{err[:field]}: #{err[:message]}\"\nend\n</code></pre>"},{"location":"guides/messages/#see-also","title":"See Also","text":"<ul> <li>Working with Tasks - Task lifecycle and management</li> <li>Handling Artifacts - Working with agent outputs</li> <li>Creating Agent Cards - Define agent capabilities</li> <li>Error Handling - Handle errors gracefully</li> <li>API Reference: Models - Complete model API documentation</li> </ul> <p>Back to Guides | Home</p>"},{"location":"guides/tasks/","title":"Working with Tasks","text":"<p>Tasks are the central unit of work in the A2A protocol. They represent a piece of work requested by a client and processed by an agent.</p>"},{"location":"guides/tasks/#task-lifecycle","title":"Task Lifecycle","text":""},{"location":"guides/tasks/#task-states","title":"Task States","text":"<ul> <li>submitted: Task has been received but not yet started</li> <li>working: Agent is actively processing the task</li> <li>input-required: Agent needs additional input from the user</li> <li>completed: Task finished successfully</li> <li>failed: Task encountered an error</li> <li>canceled: Task was canceled by request</li> <li>unknown: State is unknown (rare)</li> </ul>"},{"location":"guides/tasks/#creating-tasks","title":"Creating Tasks","text":"<pre><code>require 'a2a'\n\ntask = A2A::Models::Task.new(\n  id: \"task-#{SecureRandom.uuid}\",\n  session_id: \"session-123\",  # Optional, for multi-turn\n  status: {\n    state: \"submitted\",\n    timestamp: Time.now.utc.iso8601\n  }\n)\n</code></pre>"},{"location":"guides/tasks/#checking-task-state","title":"Checking Task State","text":"<pre><code># Use helper methods\ntask.state.submitted?  # =&gt; true\ntask.state.working?    # =&gt; false\ntask.state.completed?  # =&gt; false\ntask.state.terminal?   # =&gt; false\n\n# Terminal states\nterminal_states = [\"completed\", \"failed\", \"canceled\"]\n</code></pre>"},{"location":"guides/tasks/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Messages and Parts</li> <li>Multi-turn Conversations</li> </ul>"}]}